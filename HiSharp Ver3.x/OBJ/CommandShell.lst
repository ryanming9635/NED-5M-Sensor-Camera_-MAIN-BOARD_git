C51 COMPILER V9.50a   COMMANDSHELL                                                         03/03/2016 17:29:31 PAGE 1   


C51 COMPILER V9.50a, COMPILATION OF MODULE COMMANDSHELL
OBJECT MODULE PLACED IN .\OBJ\CommandShell.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE CommandShell.c LARGE OPTIMIZE(9,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\OB
                    -J\CommandShell.lst) TABS(2) OBJECT(.\OBJ\CommandShell.obj)

line level    source

   1          //  **************************************************************************
   2          //
   3          //       Copyright (c) 1992-2006 Professonal Computer Technology Co., Ltd
   4          //
   5          //      All rights are reserved. Reproduction in whole or in parts is
   6          //  prohibited without the prior written consent of the copyright owner.
   7          //  --------------------------------------------------------------------------
   8          //
   9          //  Module: CommandSell.C
  10          //
  11          //  Purpose: Implementation of CommandSell.
  12          //
  13          //  Version: 0.01                                   2006/10/22 10:39¤U¤È
  14          //
  15          //  Compiler: Keil 8051 C Compiler v7.2
  16          //
  17          //  Reference:
  18          //
  19          //
  20          //
  21          //  --------------------------------------------------------------------------
  22          //  Modification:
  23          //
  24          //  R0.01 2006/10/22 10:39¤U¤È Phoenix Chuang
  25          //  Reason:
  26          //    1. Original.
  27          //  Solution:
  28          //  
  29          //  **************************************************************************
  30          //  -----------------------------------
  31          //      Header Files
  32          //  ----------------------------------- 
  33          #include "types.h"
  34          #include "CommandShell.h"
  35          #include "UART.h"
  36          #include "Timer.h"
  37          #include "BusCtrl.h"
  38          #include "TW2835_Init.h"
  39          #include "TW28xx_Audio.h"
  40          #include "TW28xx_Video.h"
  41          #include "OSDCtrl.h"
  42          #include "OSDAction.h"
  43          #include "Main.h"
  44          
  45          #include "NED.h"
*** WARNING C320 IN LINE 70 OF NED.h: "NED-5M-Sensor-Camera V0.a.4"
  46          
  47          // Table define on code
  48          
  49          
  50          //  ------------------------------------
  51          //      Macro Definitions
  52          //  ------------------------------------ 
  53          #define WINCH     sysdat.channel_link
C51 COMPILER V9.50a   COMMANDSHELL                                                         03/03/2016 17:29:31 PAGE 2   

  54          #define RECWINTYPE  sysdat.video_mix_type
  55          #define RECLKTP   sysdat.link_type
  56          #define OSDREFALSH  msg.osd_falsh
  57          #define selwintype  msg.video_mix_type
  58            
  59          //  ------------------------------------
  60          //      Type Definitions
  61          //  ------------------------------------
  62          #define VERSION "34" //Kane @HS 2007 0725 Ver3.4  //
  63          
  64          //  ------------------------------------
  65          //      Variables Definitions
  66          //  ------------------------------------
  67            SYS_DATA sysdat;
  68            SYS_MESSAGE msg;
  69          
  70          extern U8 Com_pos;
  71          extern  U8 Com_addr;
  72          extern U8 Monitor_mode;
  73          extern U8 Com_run;
  74          //  ------------------------------------
  75          //      Function Prototypes
  76          //  ------------------------------------
  77          
  78          
  79          
  80          // ***************************************************************************
  81          
  82          // ===========================================================================
  83          //                      Parallel function description
  84          // ===========================================================================
  85          //
  86          // Get Command String from Command Buffer
  87          //
  88          U8 PCT_GetFirstStr(char **tagStr, char **sourceStr) 
  89          {
  90   1        if( **sourceStr == '\0' ) return false;
  91   1        while(**sourceStr == ' ' ) (*sourceStr)++;
  92   1        *tagStr = *sourceStr;
  93   1        (*sourceStr)++;
  94   1        while(1) {
  95   2          if( **sourceStr==' ' ) {
  96   3            **sourceStr = '\0';
  97   3            (*sourceStr)++;
  98   3            return true;
  99   3          } else if( **sourceStr == '\0' ) {
 100   3            return true;
 101   3          } else (*sourceStr)++;
 102   2        }
 103   1        
 104   1      
 105   1      
 106   1      }
 107          
 108          // ===========================================================================
 109          //
 110          // String Transfer to Command Code 
 111          //
 112          U16 PCT_StrToCommCode(char *Str)
 113          {
 114   1        data U16 ret=0;
 115   1        
C51 COMPILER V9.50a   COMMANDSHELL                                                         03/03/2016 17:29:31 PAGE 3   

 116   1        while(*Str != '\0' ) ret+=*Str++;
 117   1        return ret;
 118   1      }
 119          
 120          // ===========================================================================
 121          //
 122          // Send ACK to TW8806
 123          //
 124          void PCT_SendACK(void)
 125          {
 126   1        #ifdef  SC16IS750_DEBUG_PRINT 
                RS_tx('A');
                RS_tx('C');
                RS_tx('K');
                #endif
 131   1      }
 132          
 133          
 134          // ===========================================================================
 135          //
 136          //
 137          //
 138          
 139          // ===========================================================================
 140          //
 141          //
 142          //
 143          void PCT_CheckVMixType(U8 _typ)
 144          {
 145   1        data U8 tmplktp=0;
 146   1        
 147   1        tmplktp += (WINCH[0]&0x03); 
 148   1        tmplktp += (WINCH[1]&0x03)<<2; 
 149   1        tmplktp += (WINCH[2]&0x03)<<4; 
 150   1        tmplktp += (WINCH[3]&0x03)<<6; 
 151   1        
 152   1        if((RECWINTYPE==_typ)&&(tmplktp==RECLKTP)) {
 153   2          OSDREFALSH = OFF;
 154   2          return; 
 155   2        }
 156   1        OSDREFALSH = ON;
 157   1        RECLKTP = tmplktp;
 158   1        RECWINTYPE = _typ;
 159   1      }
 160          
 161          
 162          // ===========================================================================
 163          
 164          // ***************************************************************************
 165          // Process Command Shell Function
 166          // ***************************************************************************
 167          //
 168          // This is to communicate with PC AP 
 169          //
 170          void MoniReadPageBuffer(PCHAR szParam)
 171          {
 172   1        data U8 page, start, end;
 173   1      
 174   1        sscanf(szParam, "%bx %bx %bx", &page, &start, &end); 
 175   1      
 176   1        do {
 177   2          printf("\n<R>%02bx[%02bx]=%02bx", page, start, TW28_ReadByte(page, start) );
C51 COMPILER V9.50a   COMMANDSHELL                                                         03/03/2016 17:29:31 PAGE 4   

 178   2          start++;
 179   2        }while(start != end);
 180   1      }
 181          
 182          // ***************************************************************************
 183          //
 184          // This is to communicate with PC AP 
 185          //
 186          void MoniReadOneBuffer(PCHAR szParam)
 187          {
 188   1        data U8 page, addr;
 189   1      
 190   1        sscanf(szParam, "%bx %bx", &page, &addr); 
 191   1      
 192   1        printf("\n<R>%02bx[%02bx]=%02bx", page, addr, TW28_ReadByte(page, addr) );
 193   1      }
 194          
 195          // ***************************************************************************
 196          //
 197          // This is to communicate with PC AP 
 198          //
 199          void MoniWriteOneBuffer(PCHAR szParam)
 200          {
 201   1        data U8 page, addr, dat;
 202   1      
 203   1        sscanf(szParam, "%bx %bx %bx", &page, &addr, &dat); 
 204   1        TW28_WriteByte(page, addr, dat);
 205   1      }
 206          
 207          // ***************************************************************************
 208          //
 209          // Monitor ASCIBUS Write Byte
 210          //
 211          void MoniWriteAsicByte(PCHAR szParam)
 212          {
 213   1        data U8 _dev=0;
 214   1        data U8 _pg=0;
 215   1        data U8 _addr=0;
 216   1        data U8 _wdat=0;
 217   1        
 218   1        sscanf(szParam, "%bx %bx %bx %bx ", &_dev, &_pg, &_addr, &_wdat);
 219   1        TW28_WriteByte(_pg, _addr, _wdat);
 220   1      }
 221          
 222          // ***************************************************************************
 223          //
 224          // Monitor ASCIBUS Write Byte
 225          //
 226          void MoniReadAsicByte(PCHAR szParam)
 227          {
 228   1        data U8 _dev=0;
 229   1        data U8 _pg=0;
 230   1        data U8 _addr=0;
 231   1        data U8 _rdat=0;
 232   1        
 233   1        sscanf(szParam, "%1bx %1bx %1bx ", &_dev, &_pg, &_addr);
 234   1        _rdat = TW28_ReadByte(_pg, _addr);
 235   1        printf("ReadAsicByte == %bx \n", _rdat);
 236   1      }
 237          
 238          // ***************************************************************************
 239          //
C51 COMPILER V9.50a   COMMANDSHELL                                                         03/03/2016 17:29:31 PAGE 5   

 240          // Monitor Audio Mixing 
 241          // Format : amix N ch0:val ch1:val ch2:val ch3:val ch4:val 
 242          //
 243          void MoniAudioMixing(PCHAR szParam)
 244          {
 245   1        data U8 selch0,selch1,selch2,selch3,selch4; 
 246   1        data U8 valch0,valch1,valch2,valch3,valch4; 
 247   1        char *getStr;
 248   1        code U8 chaddr[] = {ADO_MIX_MUTE_AIN0, \
 249   1                  ADO_MIX_MUTE_AIN1, \
 250   1                  ADO_MIX_MUTE_AIN2, \
 251   1                  ADO_MIX_MUTE_AIN3, \
 252   1                  ADO_MIX_MUTE_PBAI \
 253   1        };  
 254   1      
 255   1        PCT_GetFirstStr(&getStr,&szParam);
 256   1      
 257   1        PCT_AudioMixMute(0, ADO_MIX_MUTE_AIN0+ \
 258   1                  ADO_MIX_MUTE_AIN1+ \
 259   1                  ADO_MIX_MUTE_AIN2+ \
 260   1                  ADO_MIX_MUTE_AIN3+ \
 261   1                  ADO_MIX_MUTE_PBAI, OFF);
 262   1      
 263   1        switch( atoi(getStr) ) {
 264   2        case 1:
 265   2          sscanf(szParam,"ch%bd:%bd ",&selch0,&valch0);
 266   2          PCT_AudioMixCtrl(0, selch0, valch0);
 267   2          PCT_AudioMixMute(0, chaddr[selch0], ON);
 268   2          break;
 269   2        
 270   2        case 2:
 271   2          sscanf(szParam,"ch%bd:%bd ch%bd:%bd ", \
 272   2            &selch0, &valch0, &selch1, &valch1);
 273   2          PCT_AudioMixCtrl(0, selch0, valch0);
 274   2          PCT_AudioMixCtrl(0, selch1, valch1);
 275   2          PCT_AudioMixMute(0, chaddr[selch0]+chaddr[selch1], ON);
 276   2          break;
 277   2        
 278   2        case 3:
 279   2          sscanf(szParam,"ch%bd:%bd ch%bd:%bd ch%bd:%bd ", \
 280   2            &selch0, &valch0, &selch1, &valch1, &selch2, &valch2);
 281   2          PCT_AudioMixCtrl(0, selch0, valch0);
 282   2          PCT_AudioMixCtrl(0, selch1, valch1);
 283   2          PCT_AudioMixCtrl(0, selch2, valch2);
 284   2          PCT_AudioMixMute(0, chaddr[selch0]+chaddr[selch1]+chaddr[selch2], ON);
 285   2          break;
 286   2        
 287   2        case 4:
 288   2          sscanf(szParam,"ch%bd:%bd ch%bd:%bd ch%bd:%bd ch%bd:%bd ", \
 289   2            &selch0, &valch0, &selch1, &valch1, &selch2, &valch2, &selch3, &valch3);
 290   2          PCT_AudioMixCtrl(0, selch0, valch0);
 291   2          PCT_AudioMixCtrl(0, selch1, valch1);
 292   2          PCT_AudioMixCtrl(0, selch2, valch2);
 293   2          PCT_AudioMixCtrl(0, selch3, valch3);
 294   2      
 295   2          PCT_AudioMixMute(0, chaddr[selch0]+chaddr[selch1]+chaddr[selch2]+chaddr[selch3], ON);
 296   2          break;
 297   2      
 298   2        case 5:
 299   2          sscanf(szParam,"ch%bd:%bd ch%bd:%bd ch%bd:%bd ch%bd:%bd ch%bd:%bd ", \
 300   2            &selch0, &valch0, &selch1, &valch1, &selch2, &valch2, &selch3, &valch3,  &selch4, &valch4 );
 301   2          PCT_AudioMixCtrl(0, selch0, valch0);
C51 COMPILER V9.50a   COMMANDSHELL                                                         03/03/2016 17:29:31 PAGE 6   

 302   2          PCT_AudioMixCtrl(0, selch1, valch1);
 303   2          PCT_AudioMixCtrl(0, selch2, valch2);
 304   2          PCT_AudioMixCtrl(0, selch3, valch3);
 305   2          PCT_AudioMixCtrl(0, selch4, valch4);
 306   2      
 307   2          PCT_AudioMixMute(0, chaddr[selch0]+chaddr[selch1]+chaddr[selch2]+chaddr[selch3]+chaddr[selch4], ON);
 308   2          break;
 309   2        
 310   2        default:
 311   2          break;
 312   2        }
 313   1      }
 314          
 315          // ***************************************************************************
 316          //
 317          // Monitor Audio Mute 
 318          // Format : amute
 319          //
 320          void MoniAudioMute(void)
 321          {
 322   1        PCT_AudioMixMute(0, ADO_MIX_MUTE_AIN0+ \
 323   1                  ADO_MIX_MUTE_AIN1+ \
 324   1                  ADO_MIX_MUTE_AIN2+ \
 325   1                  ADO_MIX_MUTE_AIN3+ \
 326   1                  ADO_MIX_MUTE_PBAI, OFF);
 327   1        PCT_AudioSelLive(0, 0xFF);
 328   1      }
 329          
 330          // ***************************************************************************
 331          //
 332          // Monitor Audio Mixing 
 333          // Format : again N ch0:val ch1:val ch2:val ch3:val ch5:val
 334          //
 335          void MoniAudioGain(PCHAR szParam)
 336          {
 337   1        data U8 selch0,selch1,selch2,selch3,selch4; 
 338   1        data U8 ch0val,ch1val,ch2val,ch3val,ch4val; 
 339   1        char *getStr;
 340   1      
 341   1        PCT_GetFirstStr(&getStr,&szParam);
 342   1      
 343   1        switch( atoi(getStr) ) {
 344   2        case 1:
 345   2          sscanf(szParam,"ch%bd:%bd ",&selch0,&ch0val);
 346   2          PCT_AudioGainCtrl(0, selch0, ch0val);
 347   2          break;
 348   2        
 349   2        case 2:
 350   2          sscanf(szParam,"ch%bd:%bd ch%bd:%bd ", \
 351   2            &selch0, &ch0val, &selch1, &ch1val);
 352   2          PCT_AudioGainCtrl(0, selch0, ch0val);
 353   2          PCT_AudioGainCtrl(0, selch1, ch1val);
 354   2          break;
 355   2        
 356   2        case 3:
 357   2          sscanf(szParam,"ch%bd:%bd ch%bd:%bd ch%bd:%bd ", \
 358   2            &selch0, &ch0val, &selch1, &ch1val, &selch2, &ch2val);
 359   2          PCT_AudioGainCtrl(0, selch0, ch0val);
 360   2          PCT_AudioGainCtrl(0, selch1, ch1val);
 361   2          PCT_AudioGainCtrl(0, selch2, ch2val);
 362   2          break;
 363   2        
C51 COMPILER V9.50a   COMMANDSHELL                                                         03/03/2016 17:29:31 PAGE 7   

 364   2        case 4:
 365   2          sscanf(szParam,"ch%bd:%bd ch%bd:%bd ch%bd:%bd ch%bd:%bd ", \
 366   2            &selch0, &ch0val, &selch1, &ch1val, &selch2, &ch2val, &selch3, &ch3val);
 367   2          PCT_AudioGainCtrl(0, selch0, ch0val);
 368   2          PCT_AudioGainCtrl(0, selch1, ch1val);
 369   2          PCT_AudioGainCtrl(0, selch2, ch2val);
 370   2          PCT_AudioGainCtrl(0, selch3, ch3val);
 371   2          break;
 372   2        
 373   2        case 5:
 374   2          sscanf(szParam,"ch%bd:%bd ch%bd:%bd ch%bd:%bd ch%bd:%bd ch%bd:%bd ", \
 375   2            &selch0, &ch0val, &selch1, &ch1val, &selch2, &ch2val, &selch3, &ch3val, &selch4, &ch4val);
 376   2          PCT_AudioGainCtrl(0, selch0, ch0val);
 377   2          PCT_AudioGainCtrl(0, selch1, ch1val);
 378   2          PCT_AudioGainCtrl(0, selch2, ch2val);
 379   2          PCT_AudioGainCtrl(0, selch3, ch3val);
 380   2          PCT_AudioGainCtrl(0, selch4, ch4val);
 381   2          break;
 382   2        
 383   2        default:
 384   2          break;
 385   2        }
 386   1      }
 387          
 388          // ***************************************************************************
 389          //
 390          // Monitor Select Live or Mixing Mode 
 391          // alive chan (chan=0xFF is Mixing Mode)
 392          //
 393          void MoniAudioLive(PCHAR szParam)
 394          {
 395   1        data U8 chan;
 396   1      
 397   1        sscanf(szParam, "%bd ", &chan);
 398   1      
 399   1        PCT_AudioSelLive(0,chan);
 400   1      }
 401          
 402          // ***************************************************************************
 403          //
 404          // TW2835 Register All Dump
 405          //
 406          void MoniRegisterDump(void)
 407          {
 408   1        data U8 addr,page;
 409   1        
 410   1      
 411   1        for(page=0;page<3;page++) {
 412   2          printf("\n ======== PAGE %b2x =============\n",page);
 413   2          addr = 0;
 414   2          do {
 415   3            printf("%b2x\t", TW28_ReadByte(page, addr));
 416   3            addr++;
 417   3            if((addr%16)==0)  printf("\n"); 
 418   3          } while( addr );
 419   2        }
 420   1      }
 421          
 422          // ***************************************************************************
 423          //
 424          // video signal mixing to windows
 425          //
C51 COMPILER V9.50a   COMMANDSHELL                                                         03/03/2016 17:29:31 PAGE 8   

 426          void MoniVideoMixWin(PCHAR szParam)
 427          {
 428   1        data U8 chose,wintp;
 429   1      
 430   1        sscanf(szParam, "%1bx %1bx ch%1bx ch%1bx ch%1bx ch%1bx ",
 431   1                &chose, &wintp, &WINCH[0], &WINCH[1], &WINCH[2], &WINCH[3]);
 432   1        chose = (chose<<4)+(wintp&0x0F);
 433   1        PCT_SetXVideoMixing(chose, WINCH);  
 434   1      }
 435          
 436          
 437          
 438          
 439          // ***************************************************************************
 440          //
 441          // setting windows attribute
 442          //
 443          void MoniVideoMixAttr(PCHAR szParam)
 444          {
 445   1        data U16 chose;
 446   1        data U8 attrsel,setval;
 447   1        data U8   winNm[4],wincnt=0;
 448   1        data U8   division;
 449   1        char *getStr;
 450   1      
 451   1        PCT_GetFirstStr(&getStr,&szParam);
 452   1        division = atoi(getStr); 
 453   1      
 454   1        PCT_GetFirstStr(&getStr,&szParam);
 455   1        chose = PCT_StrToCommCode(getStr); 
 456   1      
 457   1        if( chose==PCT_StrToCommCode("enrecall") ) {
 458   2          attrsel = WIN_RECALL_EN;
 459   2          setval  = ON;
 460   2        } else if ( chose==PCT_StrToCommCode("enfreeze") ) {
 461   2          attrsel = WIN_FREEZE;
 462   2          setval  = ON;
 463   2        } else if ( chose==PCT_StrToCommCode("enhmirror") ) {
 464   2          attrsel = WIN_HMIRROR;
 465   2          setval  = ON;
 466   2        } else if ( chose==PCT_StrToCommCode("envmirror") ) {
 467   2          attrsel = WIN_VMIRROR;
 468   2          setval  = ON;
 469   2        } else if ( chose==PCT_StrToCommCode("enenhance") ) {
 470   2          attrsel = WIN_ENHANCE;
 471   2          setval  = ON;
 472   2        } else if ( chose==PCT_StrToCommCode("enblank") ) {
 473   2          attrsel = WIN_BLANK;
 474   2          setval  = ON;
 475   2        } else if ( chose==PCT_StrToCommCode("enbound") ) {
 476   2          attrsel = WIN_BOUND;
 477   2          setval  = ON;
 478   2        } else if ( chose==PCT_StrToCommCode("enblink") ) {
 479   2          attrsel = WIN_BLINK;
 480   2          setval  = ON;
 481   2        } else if ( chose==PCT_StrToCommCode("disrecall") ) {
 482   2          attrsel = WIN_RECALL_EN;
 483   2          setval  = OFF;
 484   2        } else if ( chose==PCT_StrToCommCode("disfreeze") ) {
 485   2          attrsel = WIN_FREEZE;
 486   2          setval  = OFF;
 487   2        } else if ( chose==PCT_StrToCommCode("dishmirror") ) {
C51 COMPILER V9.50a   COMMANDSHELL                                                         03/03/2016 17:29:31 PAGE 9   

 488   2          attrsel = WIN_HMIRROR;
 489   2          setval  = OFF;
 490   2        } else if ( chose==PCT_StrToCommCode("disvmirror") ) {
 491   2          attrsel = WIN_VMIRROR;
 492   2          setval  = OFF;
 493   2        } else if ( chose==PCT_StrToCommCode("disenhance") ) {
 494   2          attrsel = WIN_ENHANCE;
 495   2          setval  = OFF;
 496   2        } else if ( chose==PCT_StrToCommCode("disblank") ) {
 497   2          attrsel = WIN_BLANK;
 498   2          setval  = OFF;
 499   2        } else if ( chose==PCT_StrToCommCode("disbound") ) {
 500   2          attrsel = WIN_BOUND;
 501   2          setval  = OFF;
 502   2        } else if ( chose==PCT_StrToCommCode("disblink") ) {
 503   2          attrsel = WIN_BLINK;
 504   2          setval  = OFF;
 505   2        } else {
 506   2          return;
 507   2        }
 508   1      
 509   1        while( PCT_GetFirstStr(&getStr,&szParam) ) {
 510   2          if(*getStr=='w' && *(getStr+1)=='i' && *(getStr+2)=='n') 
 511   2          {
 512   3            winNm[wincnt] = atoi(getStr+3);
 513   3            wincnt++;
 514   3          }
 515   2        }
 516   1        for( ; wincnt!=0; wincnt--) {
 517   2          if( winNm[wincnt-1]<division ) {
 518   3            PCT_WinAttrCtrl(winNm[wincnt-1], attrsel, setval);
 519   3          }
 520   2        }
 521   1      }
 522          
 523          // ***************************************************************************
 524          //
 525          // Monitor Video Y Channel Select Live or Mixing Mode 
 526          // yvmix chan (chan=0x04 is Mixing Mode)
 527          //
 528          void MoniYVideoMix(PCHAR szParam)
 529          {
 530   1        data U8 chan;
 531   1      
 532   1        sscanf(szParam, "%bd ", &chan);
 533   1        PCT_SetYVideoMixing(chan);
 534   1      }
 535          
 536          // ***************************************************************************
 537          //
 538          // Monitor Video Auto Detect Format 
 539          //
 540          void MoniVideoAutoDetect(void)
 541          {
 542   1        printf("===== Format : ch0=[%bx] ch1=[%bx] ch2=[%bx] ch3=[%bx] =====\n",  \ 
 543   1            PCT_DetectVideoFormat(0x00), \
 544   1            PCT_DetectVideoFormat(0x01), \
 545   1            PCT_DetectVideoFormat(0x02), \
 546   1            PCT_DetectVideoFormat(0x03) \
 547   1        );
 548   1      }
 549          
C51 COMPILER V9.50a   COMMANDSHELL                                                         03/03/2016 17:29:31 PAGE 10  

 550          // ***************************************************************************
 551          //
 552          // Monitor Setting Video Format 
 553          //
 554          void MoniSetVideoFormat(PCHAR szParam)
 555          {
 556   1        data U8 selch0,selch1,selch2,selch3;  
 557   1        data U8 valch0,valch1,valch2,valch3;  
 558   1        char *getStr;
 559   1      
 560   1        PCT_GetFirstStr(&getStr,&szParam);
 561   1      
 562   1        switch( atoi(getStr) ) {
 563   2        case 1:
 564   2          sscanf(szParam,"ch%bd:%bd ",&selch0,&valch0);
 565   2          PCT_SetVideoFormat(0, selch0, valch0<<4);
 566   2          break;
 567   2        
 568   2        case 2:
 569   2          sscanf(szParam,"ch%bd:%bd ch%bd:%bd ", \
 570   2            &selch0, &valch0, &selch1, &valch1);
 571   2          PCT_SetVideoFormat(0, selch0, valch0<<4);
 572   2          PCT_SetVideoFormat(0, selch1, valch1<<4);
 573   2          break;
 574   2        
 575   2        case 3:
 576   2          sscanf(szParam,"ch%bd:%bd ch%bd:%bd ch%bd:%bd ", \
 577   2            &selch0, &valch0, &selch1, &valch1, &selch2, &valch2);
 578   2          PCT_SetVideoFormat(0, selch0, valch0<<4);
 579   2          PCT_SetVideoFormat(0, selch1, valch1<<4);
 580   2          PCT_SetVideoFormat(0, selch2, valch2<<4);
 581   2          break;
 582   2        
 583   2        case 4:
 584   2          sscanf(szParam,"ch%bd:%bd ch%bd:%bd ch%bd:%bd ch%bd:%bd ", \
 585   2            &selch0, &valch0, &selch1, &valch1, &selch2, &valch2, &selch3, &valch3);
 586   2          PCT_SetVideoFormat(0, selch0, valch0<<4);
 587   2          PCT_SetVideoFormat(0, selch1, valch1<<4);
 588   2          PCT_SetVideoFormat(0, selch2, valch2<<4);
 589   2          PCT_SetVideoFormat(0, selch3, valch3<<4);
 590   2          break;
 591   2      
 592   2        default:
 593   2          break;
 594   2        }
 595   1      }
 596          
 597          // ***************************************************************************
 598          //
 599          // Monitor Setting Video Format 
 600          //
 601          void MoniShowSODStr(PCHAR szParam)
 602          {
 603   1        data U8 addrx,addry;
 604   1        char *getStr;
 605   1        
 606   1        PCT_GetFirstStr(&getStr,&szParam);
 607   1        addrx=atoi(getStr);
 608   1        PCT_GetFirstStr(&getStr,&szParam);
 609   1        addry=atoi(getStr);
 610   1      
 611   1        PCT_PreSetForegroundColor(OSD_COL_100WHT);
C51 COMPILER V9.50a   COMMANDSHELL                                                         03/03/2016 17:29:31 PAGE 11  

 612   1        PCT_PreSetBackgroundColor(OSD_COL_BLU);
 613   1        PCT_SetOSDDrawPage(WRPHX_PAGE5);
 614   1        PCT_ShowOSDString(PTH_X, addrx, addry, szParam);
 615   1        PCT_EnShowOSDPage(WRPHX_PAGE5);
 616   1      }
 617          
 618          // ***************************************************************************
 619          //
 620          // Audio Control for HiSarp
 621          //
 622          void PCT_AudioActionForHS(void)
 623          {
 624   1        data U8 winid;
 625   1        data U8 muteFlage=true;
 626   1      
 627   1        // ------------- Control Audio ------------
 628   1        for(winid=0; winid<4; winid++) {
 629   2          if(SYSWINATTR[winid]&BIT4) {
 630   3            PCT_AudioSelLive(0,WINCH[winid]);
 631   3            muteFlage = false;
 632   3          }
 633   2        }
 634   1      
 635   1        if(muteFlage) {
 636   2          // Audio Mute
 637   2          PCT_AudioMixMute(0, ADO_MIX_MUTE_AIN0+ \
 638   2                    ADO_MIX_MUTE_AIN1+ \
 639   2                    ADO_MIX_MUTE_AIN2+ \
 640   2                    ADO_MIX_MUTE_AIN3+ \
 641   2                    ADO_MIX_MUTE_PBAI, OFF);
 642   2          PCT_AudioSelLive(0, 0xFF);
 643   2        }
 644   1        // ----------------------------------------
 645   1      }
 646          
 647          // ***************************************************************************
 648          //
 649          // Command Shell for HiSarp
 650          //
 651          BYTE xdata Original_selwintype = 0;//Kane @HS 2007 0724 Ver3.4
 652          void MoniHSComm(PCHAR szParam) {
 653   1        data U8 winid;
 654   1        data U8 chose,wintp;
 655   1        
 656   1        sscanf(szParam, "%bx %bx ch%bx:%bx ch%bx:%bx ch%bx:%bx ch%bx:%bx ",
 657   1        &chose, &wintp, &WINCH[0], &SYSWINATTR[0], &WINCH[1], &SYSWINATTR[1], &WINCH[2], &SYSWINATTR[2], &WINCH[3
             -], &SYSWINATTR[3]);
 658   1      
 659   1        selwintype = (SYSTYPE<<7)+(chose<<4)+(wintp&0x0F);
 660   1      
 661   1        // ----------- Y Chanle setting windows horizontal mirror ----------
 662   1          
 663   1        SYSCHATTR[WINCH[0]]=SYSWINATTR[0];
 664   1        SYSCHATTR[WINCH[1]]=SYSWINATTR[1];
 665   1        SYSCHATTR[WINCH[2]]=SYSWINATTR[2];
 666   1        SYSCHATTR[WINCH[3]]=SYSWINATTR[3];
 667   1      
 668   1        PCT_WinAttrCtrlY(0, WIN_HMIRROR, SYSCHATTR[0]&BIT0);  
 669   1        PCT_WinAttrCtrlY(1, WIN_HMIRROR, SYSCHATTR[1]&BIT0);  
 670   1        PCT_WinAttrCtrlY(2, WIN_HMIRROR, SYSCHATTR[2]&BIT0);  
 671   1        PCT_WinAttrCtrlY(3, WIN_HMIRROR, SYSCHATTR[3]&BIT0);  
 672   1        // -----------------------------------------------------------------
C51 COMPILER V9.50a   COMMANDSHELL                                                         03/03/2016 17:29:31 PAGE 12  

 673   1      
 674   1        // ------------- Control Video ------------
 675   1        //if(Original_selwintype != selwintype)//Kane @HS 2007 0724 Ver3.4
 676   1      
 677   1      
 678   1        PCT_RecompenseYHdelay(SYSCHATTR);
 679   1        PCT_SetVideoHDelay(selwintype, WINCH, SYSWINATTR);
 680   1      
 681   1        
 682   1        PCT_SetXVideoMixing(selwintype, WINCH);
 683   1        
 684   1        //PCT_VideoLastModify();
 685   1        for(winid=0; winid<4; winid++) 
 686   1          PCT_WinAttrCtrl(winid, WIN_HMIRROR, SYSWINATTR[winid]&BIT0);  
 687   1        // ----------------------------------------
 688   1      
 689   1      #if 1
 690   1        // ------------- Control OSD ------------
 691   1        DisUserTimer(USERTMID0);    // Disable real-time detect VLoss
 692   1        EnUserTimer(USERTMID1,5);   // Enable OSD Delay Timer
 693   1        PCT_FlashOSDCtrl(ON);
 694   1        
 695   1        PCT_CheckVMixType(selwintype);
 696   1        PCT_DisShowOSDPage(DISOSD_PHX);
 697   1        PCT_ClearOSDPageX(WRPHX_PAGE0);
 698   1        PCT_ShowModeIcon();
 699   1        PCT_OSD_ActionPthX(SYSWINATTR);
 700   1        Original_selwintype = selwintype;//Kane @HS 2007 0724 Ver3.4
 701   1      #else
                // ------------- Control OSD ------------
                DisUserTimer(USERTMID0);    // Disable real-time detect VLoss
                EnUserTimer(USERTMID1,5);   // Enable OSD Delay Timer
                PCT_FlashOSDCtrl(ON);
                PCT_CheckVMixType(selwintype);
                PCT_DisShowOSDPage(DISOSD_PHX);
                PCT_ClearOSDPageX(WRPHX_PAGE0);
                PCT_ShowModeIcon();
                PCT_OSD_ActionPthX(SYSWINATTR);
                Original_selwintype = selwintype;//Kane @HS 2007 0724 Ver3.4
              #endif
 713   1      
 714   1      
 715   1      
 716   1      
 717   1        // --------------------------------------
 718   1      }
 719          
 720          
 721          // ***************************************************************************
 722          //
 723          // Real Time Check System Type PAL or NTSC
 724          //
 725          bit PCT_CheckSystem(void)
 726          {
 727   1        //Kane add>>>>
 728   1        char TempSystem;
 729   1        TempSystem = PCT_DetectVideoFormat(SENSORCHANNEL);
 730   1        //if(SYSTYPE == PCT_DetectVideoFormat(SENSORCHANNEL)) return true;//Kane canceled
 731   1        if(TempSystem == NONE_SYSTEM)
 732   1          return FALSE;
 733   1        if(TempSystem == SYSTYPE)
 734   1          return TRUE;
C51 COMPILER V9.50a   COMMANDSHELL                                                         03/03/2016 17:29:31 PAGE 13  

 735   1        SYSTYPE = TempSystem;
 736   1        //Kane Add<<<<
 737   1        //SYSTYPE = PCT_DetectVideoFormat(SENSORCHANNEL);//Kane canceled
 738   1        SYSMIXTYP = (SYSTYPE<<7)|(SYSMIXTYP&0x7F);
 739   1      
 740   1        PCT_EnShowOSDPage(WRPHX_PAGE1);
 741   1      
 742   1      
 743   1        // ------------- Control Video ------------
 744   1        PCT_ChangeSystemType(SYSTYPE);
 745   1        PCT_RecompenseYHdelay(SYSCHATTR); // preset Y Recompense
 746   1        PCT_SetVideoHDelay(RECWINTYPE, WINCH, SYSWINATTR);
 747   1        
 748   1        PCT_SetXVideoMixing(RECWINTYPE, WINCH);
 749   1        //PCT_VideoLastModify();
 750   1          
 751   1        // ------------- Control OSD ------------
 752   1        PCT_ClearOSDPageX(WRPHX_PAGE0);
 753   1        PCT_ShowModeIcon();
 754   1        PCT_OSD_ActionPthX(SYSWINATTR);
 755   1        PCT_OSDActionForHS();
 756   1        // --------------------------------------
 757   1        
 758   1        return 1;
 759   1      }
 760          
 761          
 762          // ***************************************************************************
 763          //
 764          // Command Shell for HiSarp Setting S or J Mode
 765          //
 766          void MoniHSCommSJmode(PCHAR szParam)
 767          {
 768   1        sscanf(szParam, "%bd ", &SYSMODE);
 769   1      }
 770          
 771          // ***************************************************************************
 772          //
 773          // Command Shell for HiSarp Setting S or J Mode
 774          //
 775          void MoniHSCommDisScroll(void)
 776          {
 777   1        PCT_EnShowOSDPage(WRPHX_PAGE1);
 778   1      }
 779          
 780          // ***************************************************************************
 781          //
 782          // Command Shell for HiSarp Setting S or J Mode
 783          //
 784          void MoniHSCommVersion(void)
 785          {
 786   1        RS_tx(VERSION[0]);
 787   1        RS_tx(VERSION[1]);
 788   1      }
 789          
 790          // ***************************************************************************
 791          //
 792          // Runing Command Shell
 793          //
 794          
 795          U8 PCT_RunCommShell(char *strptr)
 796          {
C51 COMPILER V9.50a   COMMANDSHELL                                                         03/03/2016 17:29:31 PAGE 14  

 797   1        U16 commcode;
 798   1        char *getStr;  
 799   1       
 800   1      
 801   1      //printf("char *strptr=%s\r\n",strptr);//ryan..
 802   1      
 803   1      
 804   1                //MoniHSComm(strptr);
 805   1          //PCT_AudioActionForHS();
 806   1          //PCT_OSDActionForHS();  
 807   1                 //PCT_FlashOSDCtrl(OFF);
 808   1                // return 0;
 809   1       //    getStr=&CommTable[0];
 810   1        // ---------- Run Command Shell Entry ----------
 811   1        //Kane @HS 2007 0809 Ver3.5>>>>
 812   1        PCT_GetFirstStr(&getStr, &strptr);
 813   1        //getStr=strptr+4;
 814   1        //Kane @HS 2007 0809 Ver3.5<<<<
 815   1        commcode = PCT_StrToCommCode(getStr); 
 816   1        #if 0
                if (commcode == PCT_StrToCommCode("&")) {
                  //printf("Read Page Buffer Data");
                  MoniReadPageBuffer(strptr);
                }else if( commcode == PCT_StrToCommCode("(")) {
                  //printf("Read One Buffer Data");
                  MoniReadOneBuffer(strptr);
                }else if( commcode == PCT_StrToCommCode(")")) {
                  //printf("Write One Buffer Data");
                  MoniWriteOneBuffer(strptr);
                  
                }
              
                else
              #endif
 831   1          if( commcode == PCT_StrToCommCode("busw")) {
 832   2          // ===== ASICBUS Write Byte ======
 833   2          //printf("Command is Write Bus");
 834   2          MoniWriteAsicByte(strptr);
 835   2      
 836   2        } 
 837   1      
 838   1      #if 0
                else if (commcode == PCT_StrToCommCode("busr")) {
                  // ===== ASICBUS Read Byte =======
                  //printf("Command is Read Bus");
                  MoniReadAsicByte(strptr);
                }
              
                else if (commcode == PCT_StrToCommCode("amix")) {
                  // ===== Audio mix =======
                  //printf("Command is Audio Mixing");
                  MoniAudioMixing(strptr);
                } else if (commcode == PCT_StrToCommCode("amute")) {
                  // ===== Audio Mute =======
                  //printf("Command is Audio Mute");
                  MoniAudioMute();
                } else if (commcode == PCT_StrToCommCode("adump")) {
                  // ===== List Audio Register Value =======
                  //printf("List Audio Register Value");
                  PCT_AudioRegList();
                } else if (commcode == PCT_StrToCommCode("again")) {
                  // ===== Audio Gain Control =======
C51 COMPILER V9.50a   COMMANDSHELL                                                         03/03/2016 17:29:31 PAGE 15  

                  //printf("Audio Gain Control");
                  MoniAudioGain(strptr);
                } else if (commcode == PCT_StrToCommCode("alive")) {
                  // ===== Audio Select Live & Mixing Mode =======
                  //printf("Audio Select Live & Mixing Mode");
                  MoniAudioLive(strptr);
                } else if (commcode == PCT_StrToCommCode("busrt")) {
                  // ===== All Register Dump =======
                  //printf("All Register Dump");
                  MoniRegisterDump();
                } else if (commcode == PCT_StrToCommCode("vmix")) {
                  // ===== Video Mix's Windows Type Select =======
                  //printf("Video Mix's Windows Type Select");
                  PCT_WinAttrClear(WIN_FREEZE);
                  MoniVideoMixWin(strptr);
                  PCT_SendACK();
                } else if (commcode == PCT_StrToCommCode("vmixerr")) {
                  // ===== Video Mix's Windows Type Select =======
                  //printf("Video Mixerr's Windows Type Select");
                  MoniVideoMixWin(strptr); 
                } else if (commcode == PCT_StrToCommCode("vattr")) {
                  // ===== Video Mixing Control =======
                  //printf("Video Attribute Control");
                  MoniVideoMixAttr(strptr);
                  
                } 
              
              
                else
              #endif
 889   1          else if (commcode == PCT_StrToCommCode("yvmix")) {    // HiSharp has used
 890   2          // ===== Video Mixing Control =======
 891   2          PCT_SendACK();
 892   2          //printf("Video Attribute Control");
 893   2          MoniYVideoMix(strptr);
 894   2          
 895   2        }
 896   1        #if 0
                else if (commcode == PCT_StrToCommCode("init")) {
                  // ===== TW2835 initial =======
                  //printf("Initial TW2835");
                  PCT_InitialTW2835();
                } else if (commcode == PCT_StrToCommCode("vdet")) {
                  // ===== Video Mixing Control =======
                  //printf("Auto Detectation Video Format");
                  MoniVideoAutoDetect();
                } else if (commcode == PCT_StrToCommCode("vsetf")) {
                  // ===== Video Mixing Control =======
                  //printf("Setting Video Format Control");
                  MoniSetVideoFormat(strptr);
                } else if (commcode == PCT_StrToCommCode("sstr")) {
                  // ===== Show String on OSD =======
                  //printf("Show String on OSD");
                  MoniShowSODStr(strptr);
              // --------------------------------------------------------------------------------
              
                }
              #endif  
 917   1        else if (commcode == PCT_StrToCommCode("hscom")) {    // HiSharp has used
 918   2          PCT_SendACK();
 919   2          //printf("Command Shell for HiSharp");
 920   2          MoniHSComm(strptr);
C51 COMPILER V9.50a   COMMANDSHELL                                                         03/03/2016 17:29:31 PAGE 16  

 921   2      
 922   2      #if 1
 923   2          PCT_OSDActionForHS();
 924   2          PCT_FlashOSDCtrl(OFF);
 925   2      #else
                  //PCT_AudioActionForHS();
                  PCT_OSDActionForHS();
                  PCT_FlashOSDCtrl(OFF);
              #endif
 930   2      
 931   2          #ifdef TW2835_degug
                  TW2835_get(0, 0, 0x36);
                  #endif    
 934   2      
 935   2      
 936   2          
 937   2        } else if (commcode == PCT_StrToCommCode("mode")) {     // HiSharp has used
 938   2          PCT_SendACK();
 939   2          //printf("Command Shell for HiSharp Set S or J Mode");
 940   2          MoniHSCommSJmode(strptr);
 941   2        } 
 942   1      #if 0
                else if (commcode == PCT_StrToCommCode("disscroll")) {  // HiSharp has used
                  PCT_SendACK();
                  //printf("Command Shell for HiSharp Disable Scroll!");
                  MoniHSCommDisScroll();
                } else if (commcode == PCT_StrToCommCode("ver")) {  // HiSharp has used
                  PCT_SendACK();
                  //printf("Command Shell for HiSharp Disable Scroll!");
                  MoniHSCommVersion();
                  //PCT_InitialTW2835();//Kane @HS 2007 0723 Ver3.4
              // --------------------------------------------------------------------------------
                } 
              #endif
 955   1        else if(commcode == PCT_StrToCommCode("7"))
 956   1            {
 957   2              //Monitor_set((Com_pos)); 
 958   2               Monitor_mode=Com_run;
 959   2               
 960   2            #ifdef  SC16IS750_DEBUG_PRINT 
                    printf("\r\nget Monitor=%x",(U16) Com_run);
                    #endif
 963   2            }
 964   1             else if(commcode == PCT_StrToCommCode("8"))
 965   1              {
 966   2      
 967   2                Repeat_PWM_Com();
 968   2              PWM_set(Com_run); 
 969   2              
 970   2              #ifdef  SC16IS750_DEBUG_PRINT 
                      printf("\r\nget PWM=%x",(U16)Com_run);
                      #endif
 973   2      
 974   2              
 975   2              }
 976   1             #if 0//ryan@20150818
                      else if (commcode == PCT_StrToCommCode("1"))
                      {     
                      if(SC16_Com[2]==0x31)
                      {
                      Temp_check();
                      #ifdef  SC16IS750_DEBUG_PRINT 
C51 COMPILER V9.50a   COMMANDSHELL                                                         03/03/2016 17:29:31 PAGE 17  

                      printf("\r\nget temp=%x",(U16)ADT75_GetTemp());
                      #endif
                      }
                      else if(SC16_Com[2]==0x33)
                      {
                      Press_check();
                      #ifdef  SC16IS750_DEBUG_PRINT 
                      printf("\r\nget Press_check=%x",(U16)ADC_FPBS());
                      #endif
                      }
                      else if(SC16_Com[2]==0x50)
                        {
                        Version_check();
                        #ifdef  SC16IS750_DEBUG_PRINT 
                        printf("\r\nget Version=%x%x%x",(U16)Ver0,(U16)Ver1,(U16)Ver2);
                        #endif
                        }
                    
                      
                      }
                    #endif
1004   1            else
1005   1              {
1006   2              }
1007   1      
1008   1        //ResetCommSell(); 
1009   1            
1010   1        // ---------------------------------------------
1011   1        return true;
1012   1      }
1013          
1014          
1015          // ===========================================================================
1016          // END of File 
1017          // ===========================================================================
1018          
1019          
1020          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   3800    ----
   CONSTANT SIZE    =    638    ----
   XDATA SIZE       =     29      47
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----      70
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  1 WARNING(S),  0 ERROR(S)
