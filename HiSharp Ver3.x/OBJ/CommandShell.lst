C51 COMPILER V9.01   COMMANDSHELL                                                          12/17/2018 16:46:12 PAGE 1   


C51 COMPILER V9.01, COMPILATION OF MODULE COMMANDSHELL
OBJECT MODULE PLACED IN .\OBJ\CommandShell.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE CommandShell.c LARGE OPTIMIZE(9,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\OB
                    -J\CommandShell.lst) OBJECT(.\OBJ\CommandShell.obj)

line level    source

   1          //  **************************************************************************
   2          //
   3          //       Copyright (c) 1992-2006 Professonal Computer Technology Co., Ltd
   4          //
   5          //      All rights are reserved. Reproduction in whole or in parts is
   6          //  prohibited without the prior written consent of the copyright owner.
   7          //  --------------------------------------------------------------------------
   8          //
   9          //  Module: CommandSell.C
  10          //
  11          //  Purpose: Implementation of CommandSell.
  12          //
  13          //  Version: 0.01                                   2006/10/22 10:39¤U¤È
  14          //
  15          //  Compiler: Keil 8051 C Compiler v7.2
  16          //
  17          //  Reference:
  18          //
  19          //
  20          //
  21          //  --------------------------------------------------------------------------
  22          //  Modification:
  23          //
  24          //      R0.01 2006/10/22 10:39¤U¤È Phoenix Chuang
  25          //      Reason:
  26          //              1. Original.
  27          //      Solution:
  28          //      
  29          //  **************************************************************************
  30          //      -----------------------------------
  31          //                      Header Files
  32          //      ----------------------------------- 
  33          #include "types.h"
  34          #include "CommandShell.h"
  35          #include "UART.h"
  36          #include "Timer.h"
  37          #include "BusCtrl.h"
  38          #include "TW2835_Init.h"
  39          #include "TW28xx_Audio.h"
  40          #include "TW28xx_Video.h"
  41          #include "OSDCtrl.h"
  42          #include "OSDAction.h"
  43          #include "Main.h"
  44          
  45          #include "NED.h"
  46          
  47          // Table define on code
  48          
  49          
  50          //      ------------------------------------
  51          //                      Macro Definitions
  52          //      ------------------------------------ 
  53          #define WINCH           sysdat.channel_link
  54          #define RECWINTYPE      sysdat.video_mix_type
C51 COMPILER V9.01   COMMANDSHELL                                                          12/17/2018 16:46:12 PAGE 2   

  55          #define RECLKTP         sysdat.link_type
  56          #define OSDREFALSH      msg.osd_falsh
  57          #define selwintype      msg.video_mix_type
  58                  
  59          //      ------------------------------------
  60          //                      Type Definitions
  61          //      ------------------------------------
  62          #define VERSION "34" //Kane @HS 2007 0725 Ver3.4  //
  63          
  64          //      ------------------------------------
  65          //                      Variables Definitions
  66          //      ------------------------------------
  67                  SYS_DATA sysdat;
  68                  SYS_MESSAGE msg;
  69          
  70          extern U8 Com_pos;
  71          extern  U8 Com_addr;
  72          extern U8 Monitor_mode;
  73          extern U8 Com_run;
  74          //      ------------------------------------
  75          //                      Function Prototypes
  76          //      ------------------------------------
  77          
  78          
  79          
  80          // ***************************************************************************
  81          
  82          // ===========================================================================
  83          //                      Parallel function description
  84          // ===========================================================================
  85          //
  86          // Get Command String from Command Buffer
  87          //
  88          U8 PCT_GetFirstStr(char **tagStr, char **sourceStr) 
  89          {
  90   1              if( **sourceStr == '\0' ) return false;
  91   1              while(**sourceStr == ' ' ) (*sourceStr)++;
  92   1              *tagStr = *sourceStr;
  93   1              (*sourceStr)++;
  94   1              while(1) {
  95   2                      if( **sourceStr==' ' ) {
  96   3                              **sourceStr = '\0';
  97   3                              (*sourceStr)++;
  98   3                              return true;
  99   3                      } else if( **sourceStr == '\0' ) {
 100   3                              return true;
 101   3                      } else (*sourceStr)++;
 102   2              }
 103   1              
 104   1      
 105   1      
 106   1      }
 107          
 108          // ===========================================================================
 109          //
 110          // String Transfer to Command Code 
 111          //
 112          U16 PCT_StrToCommCode(char *Str)
 113          {
 114   1              data U16 ret=0;
 115   1              
 116   1              while(*Str != '\0' ) ret+=*Str++;
C51 COMPILER V9.01   COMMANDSHELL                                                          12/17/2018 16:46:12 PAGE 3   

 117   1              return ret;
 118   1      }
 119          
 120          // ===========================================================================
 121          //
 122          // Send ACK to TW8806
 123          //
 124          void PCT_SendACK(void)
 125          {
 126   1              #ifdef  SC16IS750_DEBUG_PRINT 
                      RS_tx('A');
                      RS_tx('C');
                      RS_tx('K');
                      #endif
 131   1      }
 132          
 133          
 134          // ===========================================================================
 135          //
 136          //
 137          //
 138          
 139          // ===========================================================================
 140          //
 141          //
 142          //
 143          void PCT_CheckVMixType(U8 _typ)
 144          {
 145   1              data U8 tmplktp=0;
 146   1              
 147   1              tmplktp += (WINCH[0]&0x03); 
 148   1              tmplktp += (WINCH[1]&0x03)<<2; 
 149   1              tmplktp += (WINCH[2]&0x03)<<4; 
 150   1              tmplktp += (WINCH[3]&0x03)<<6; 
 151   1              
 152   1              if((RECWINTYPE==_typ)&&(tmplktp==RECLKTP)) {
 153   2                      OSDREFALSH = OFF;
 154   2                      return; 
 155   2              }
 156   1              OSDREFALSH = ON;
 157   1              RECLKTP = tmplktp;
 158   1              RECWINTYPE = _typ;
 159   1      }
 160          
 161          
 162          // ===========================================================================
 163          
 164          // ***************************************************************************
 165          // Process Command Shell Function
 166          // ***************************************************************************
 167          //
 168          // This is to communicate with PC AP 
 169          //
 170          #if 0
              void MoniReadPageBuffer(PCHAR szParam)
              {
                      data U8 page, start, end;
              
                      sscanf(szParam, "%bx %bx %bx", &page, &start, &end); 
              
                      do {
                              printf("\n<R>%02bx[%02bx]=%02bx", page, start, TW28_ReadByte(page, start) );
C51 COMPILER V9.01   COMMANDSHELL                                                          12/17/2018 16:46:12 PAGE 4   

                              start++;
                      }while(start != end);
              }
              
              // ***************************************************************************
              //
              // This is to communicate with PC AP 
              //
              void MoniReadOneBuffer(PCHAR szParam)
              {
                      data U8 page, addr;
              
                      sscanf(szParam, "%bx %bx", &page, &addr); 
              
                      printf("\n<R>%02bx[%02bx]=%02bx", page, addr, TW28_ReadByte(page, addr) );
              }
              
              // ***************************************************************************
              //
              // This is to communicate with PC AP 
              //
              void MoniWriteOneBuffer(PCHAR szParam)
              {
                      data U8 page, addr, dat;
              
                      sscanf(szParam, "%bx %bx %bx", &page, &addr, &dat); 
                      TW28_WriteByte(page, addr, dat);
              }
              #endif
 208          // ***************************************************************************
 209          //
 210          // Monitor ASCIBUS Write Byte
 211          //
 212          void MoniWriteAsicByte(PCHAR szParam)
 213          {
 214   1              data U8 _dev=0;
 215   1              data U8 _pg=0;
 216   1              data U8 _addr=0;
 217   1              data U8 _wdat=0;
 218   1              
 219   1              sscanf(szParam, "%bx %bx %bx %bx ", &_dev, &_pg, &_addr, &_wdat);
 220   1              TW28_WriteByte(_pg, _addr, _wdat);
 221   1      }
 222          
 223          // ***************************************************************************
 224          //
 225          // Monitor ASCIBUS Write Byte
 226          //
 227          #if 0
              void MoniReadAsicByte(PCHAR szParam)
              {
                      data U8 _dev=0;
                      data U8 _pg=0;
                      data U8 _addr=0;
                      data U8 _rdat=0;
                      
                      sscanf(szParam, "%1bx %1bx %1bx ", &_dev, &_pg, &_addr);
                      _rdat = TW28_ReadByte(_pg, _addr);
                      printf("ReadAsicByte == %bx \n", _rdat);
              }
              #endif
 240          // ***************************************************************************
C51 COMPILER V9.01   COMMANDSHELL                                                          12/17/2018 16:46:12 PAGE 5   

 241          //
 242          // Monitor Audio Mixing 
 243          // Format : amix N ch0:val ch1:val ch2:val ch3:val ch4:val 
 244          //
 245          #if 0
              void MoniAudioMixing(PCHAR szParam)
              {
                      data U8 selch0,selch1,selch2,selch3,selch4;     
                      data U8 valch0,valch1,valch2,valch3,valch4;     
                      char *getStr;
                      code U8 chaddr[] = {ADO_MIX_MUTE_AIN0, \
                                                              ADO_MIX_MUTE_AIN1, \
                                                              ADO_MIX_MUTE_AIN2, \
                                                              ADO_MIX_MUTE_AIN3, \
                                                              ADO_MIX_MUTE_PBAI \
                      };      
              
                      PCT_GetFirstStr(&getStr,&szParam);
              
                      PCT_AudioMixMute(0, ADO_MIX_MUTE_AIN0+ \
                                                              ADO_MIX_MUTE_AIN1+ \
                                                              ADO_MIX_MUTE_AIN2+ \
                                                              ADO_MIX_MUTE_AIN3+ \
                                                              ADO_MIX_MUTE_PBAI, OFF);
              
                      switch( atoi(getStr) ) {
                      case 1:
                              sscanf(szParam,"ch%bd:%bd ",&selch0,&valch0);
                              PCT_AudioMixCtrl(0, selch0, valch0);
                              PCT_AudioMixMute(0, chaddr[selch0], ON);
                              break;
                      
                      case 2:
                              sscanf(szParam,"ch%bd:%bd ch%bd:%bd ", \
                                      &selch0, &valch0, &selch1, &valch1);
                              PCT_AudioMixCtrl(0, selch0, valch0);
                              PCT_AudioMixCtrl(0, selch1, valch1);
                              PCT_AudioMixMute(0, chaddr[selch0]+chaddr[selch1], ON);
                              break;
                      
                      case 3:
                              sscanf(szParam,"ch%bd:%bd ch%bd:%bd ch%bd:%bd ", \
                                      &selch0, &valch0, &selch1, &valch1, &selch2, &valch2);
                              PCT_AudioMixCtrl(0, selch0, valch0);
                              PCT_AudioMixCtrl(0, selch1, valch1);
                              PCT_AudioMixCtrl(0, selch2, valch2);
                              PCT_AudioMixMute(0, chaddr[selch0]+chaddr[selch1]+chaddr[selch2], ON);
                              break;
                      
                      case 4:
                              sscanf(szParam,"ch%bd:%bd ch%bd:%bd ch%bd:%bd ch%bd:%bd ", \
                                      &selch0, &valch0, &selch1, &valch1, &selch2, &valch2, &selch3, &valch3);
                              PCT_AudioMixCtrl(0, selch0, valch0);
                              PCT_AudioMixCtrl(0, selch1, valch1);
                              PCT_AudioMixCtrl(0, selch2, valch2);
                              PCT_AudioMixCtrl(0, selch3, valch3);
              
                              PCT_AudioMixMute(0, chaddr[selch0]+chaddr[selch1]+chaddr[selch2]+chaddr[selch3], ON);
                              break;
              
                      case 5:
                              sscanf(szParam,"ch%bd:%bd ch%bd:%bd ch%bd:%bd ch%bd:%bd ch%bd:%bd ", \
C51 COMPILER V9.01   COMMANDSHELL                                                          12/17/2018 16:46:12 PAGE 6   

                                      &selch0, &valch0, &selch1, &valch1, &selch2, &valch2, &selch3, &valch3,  &selch4, &valch4 );
                              PCT_AudioMixCtrl(0, selch0, valch0);
                              PCT_AudioMixCtrl(0, selch1, valch1);
                              PCT_AudioMixCtrl(0, selch2, valch2);
                              PCT_AudioMixCtrl(0, selch3, valch3);
                              PCT_AudioMixCtrl(0, selch4, valch4);
              
                              PCT_AudioMixMute(0, chaddr[selch0]+chaddr[selch1]+chaddr[selch2]+chaddr[selch3]+chaddr[selch4], ON);
                              break;
                      
                      default:
                              break;
                      }
              }
              
              // ***************************************************************************
              //
              // Monitor Audio Mute 
              // Format : amute
              //
              void MoniAudioMute(void)
              {
                      PCT_AudioMixMute(0, ADO_MIX_MUTE_AIN0+ \
                                                              ADO_MIX_MUTE_AIN1+ \
                                                              ADO_MIX_MUTE_AIN2+ \
                                                              ADO_MIX_MUTE_AIN3+ \
                                                              ADO_MIX_MUTE_PBAI, OFF);
                      PCT_AudioSelLive(0, 0xFF);
              }
              
              // ***************************************************************************
              //
              // Monitor Audio Mixing 
              // Format : again N ch0:val ch1:val ch2:val ch3:val ch5:val
              //
              void MoniAudioGain(PCHAR szParam)
              {
                      data U8 selch0,selch1,selch2,selch3,selch4;     
                      data U8 ch0val,ch1val,ch2val,ch3val,ch4val;     
                      char *getStr;
              
                      PCT_GetFirstStr(&getStr,&szParam);
              
                      switch( atoi(getStr) ) {
                      case 1:
                              sscanf(szParam,"ch%bd:%bd ",&selch0,&ch0val);
                              PCT_AudioGainCtrl(0, selch0, ch0val);
                              break;
                      
                      case 2:
                              sscanf(szParam,"ch%bd:%bd ch%bd:%bd ", \
                                      &selch0, &ch0val, &selch1, &ch1val);
                              PCT_AudioGainCtrl(0, selch0, ch0val);
                              PCT_AudioGainCtrl(0, selch1, ch1val);
                              break;
                      
                      case 3:
                              sscanf(szParam,"ch%bd:%bd ch%bd:%bd ch%bd:%bd ", \
                                      &selch0, &ch0val, &selch1, &ch1val, &selch2, &ch2val);
                              PCT_AudioGainCtrl(0, selch0, ch0val);
                              PCT_AudioGainCtrl(0, selch1, ch1val);
                              PCT_AudioGainCtrl(0, selch2, ch2val);
C51 COMPILER V9.01   COMMANDSHELL                                                          12/17/2018 16:46:12 PAGE 7   

                              break;
                      
                      case 4:
                              sscanf(szParam,"ch%bd:%bd ch%bd:%bd ch%bd:%bd ch%bd:%bd ", \
                                      &selch0, &ch0val, &selch1, &ch1val, &selch2, &ch2val, &selch3, &ch3val);
                              PCT_AudioGainCtrl(0, selch0, ch0val);
                              PCT_AudioGainCtrl(0, selch1, ch1val);
                              PCT_AudioGainCtrl(0, selch2, ch2val);
                              PCT_AudioGainCtrl(0, selch3, ch3val);
                              break;
                      
                      case 5:
                              sscanf(szParam,"ch%bd:%bd ch%bd:%bd ch%bd:%bd ch%bd:%bd ch%bd:%bd ", \
                                      &selch0, &ch0val, &selch1, &ch1val, &selch2, &ch2val, &selch3, &ch3val, &selch4, &ch4val);
                              PCT_AudioGainCtrl(0, selch0, ch0val);
                              PCT_AudioGainCtrl(0, selch1, ch1val);
                              PCT_AudioGainCtrl(0, selch2, ch2val);
                              PCT_AudioGainCtrl(0, selch3, ch3val);
                              PCT_AudioGainCtrl(0, selch4, ch4val);
                              break;
                      
                      default:
                              break;
                      }
              }
              
              // ***************************************************************************
              //
              // Monitor Select Live or Mixing Mode 
              // alive chan (chan=0xFF is Mixing Mode)
              //
              void MoniAudioLive(PCHAR szParam)
              {
                      data U8 chan;
              
                      sscanf(szParam, "%bd ", &chan);
              
                      PCT_AudioSelLive(0,chan);
              }
              
              // ***************************************************************************
              //
              // TW2835 Register All Dump
              //
              void MoniRegisterDump(void)
              {
                      data U8 addr,page;
                      
              
                      for(page=0;page<3;page++) {
                              printf("\n ======== PAGE %b2x =============\n",page);
                              addr = 0;
                              do {
                                      printf("%b2x\t", TW28_ReadByte(page, addr));
                                      addr++;
                                      if((addr%16)==0)  printf("\n"); 
                              } while( addr );
                      }
              }
              
              // ***************************************************************************
              //
C51 COMPILER V9.01   COMMANDSHELL                                                          12/17/2018 16:46:12 PAGE 8   

              // video signal mixing to windows
              //
              void MoniVideoMixWin(PCHAR szParam)
              {
                      data U8 chose,wintp;
              
                      sscanf(szParam, "%1bx %1bx ch%1bx ch%1bx ch%1bx ch%1bx ",
                                                      &chose, &wintp, &WINCH[0], &WINCH[1], &WINCH[2], &WINCH[3]);
                      chose = (chose<<4)+(wintp&0x0F);
                      PCT_SetXVideoMixing(chose, WINCH);      
              }
              
              
              
              
              // ***************************************************************************
              //
              // setting windows attribute
              //
              void MoniVideoMixAttr(PCHAR szParam)
              {
                      data U16 chose;
                      data U8 attrsel,setval;
                      data U8         winNm[4],wincnt=0;
                      data U8         division;
                      char *getStr;
              
                      PCT_GetFirstStr(&getStr,&szParam);
                      division = atoi(getStr); 
              
                      PCT_GetFirstStr(&getStr,&szParam);
                      chose = PCT_StrToCommCode(getStr); 
              
                      if( chose==PCT_StrToCommCode("enrecall") ) {
                              attrsel = WIN_RECALL_EN;
                              setval  = ON;
                      } else if ( chose==PCT_StrToCommCode("enfreeze") ) {
                              attrsel = WIN_FREEZE;
                              setval  = ON;
                      } else if ( chose==PCT_StrToCommCode("enhmirror") ) {
                              attrsel = WIN_HMIRROR;
                              setval  = ON;
                      } else if ( chose==PCT_StrToCommCode("envmirror") ) {
                              attrsel = WIN_VMIRROR;
                              setval  = ON;
                      } else if ( chose==PCT_StrToCommCode("enenhance") ) {
                              attrsel = WIN_ENHANCE;
                              setval  = ON;
                      } else if ( chose==PCT_StrToCommCode("enblank") ) {
                              attrsel = WIN_BLANK;
                              setval  = ON;
                      } else if ( chose==PCT_StrToCommCode("enbound") ) {
                              attrsel = WIN_BOUND;
                              setval  = ON;
                      } else if ( chose==PCT_StrToCommCode("enblink") ) {
                              attrsel = WIN_BLINK;
                              setval  = ON;
                      } else if ( chose==PCT_StrToCommCode("disrecall") ) {
                              attrsel = WIN_RECALL_EN;
                              setval  = OFF;
                      } else if ( chose==PCT_StrToCommCode("disfreeze") ) {
                              attrsel = WIN_FREEZE;
C51 COMPILER V9.01   COMMANDSHELL                                                          12/17/2018 16:46:12 PAGE 9   

                              setval  = OFF;
                      } else if ( chose==PCT_StrToCommCode("dishmirror") ) {
                              attrsel = WIN_HMIRROR;
                              setval  = OFF;
                      } else if ( chose==PCT_StrToCommCode("disvmirror") ) {
                              attrsel = WIN_VMIRROR;
                              setval  = OFF;
                      } else if ( chose==PCT_StrToCommCode("disenhance") ) {
                              attrsel = WIN_ENHANCE;
                              setval  = OFF;
                      } else if ( chose==PCT_StrToCommCode("disblank") ) {
                              attrsel = WIN_BLANK;
                              setval  = OFF;
                      } else if ( chose==PCT_StrToCommCode("disbound") ) {
                              attrsel = WIN_BOUND;
                              setval  = OFF;
                      } else if ( chose==PCT_StrToCommCode("disblink") ) {
                              attrsel = WIN_BLINK;
                              setval  = OFF;
                      } else {
                              return;
                      }
              
                      while( PCT_GetFirstStr(&getStr,&szParam) ) {
                              if(*getStr=='w' && *(getStr+1)=='i' && *(getStr+2)=='n') 
                              {
                                      winNm[wincnt] = atoi(getStr+3);
                                      wincnt++;
                              }
                      }
                      for( ; wincnt!=0; wincnt--) {
                              if( winNm[wincnt-1]<division ) {
                                      PCT_WinAttrCtrl(winNm[wincnt-1], attrsel, setval);
                              }
                      }
              }
              #endif
 526          // ***************************************************************************
 527          //
 528          // Monitor Video Y Channel Select Live or Mixing Mode 
 529          // yvmix chan (chan=0x04 is Mixing Mode)
 530          //
 531          void MoniYVideoMix(PCHAR szParam)
 532          {
 533   1              data U8 chan;
 534   1      
 535   1              sscanf(szParam, "%bd ", &chan);
 536   1              PCT_SetYVideoMixing(chan);
 537   1      }
 538          
 539          // ***************************************************************************
 540          //
 541          // Monitor Video Auto Detect Format 
 542          //
 543          #if 0
              void MoniVideoAutoDetect(void)
              {
                      printf("===== Format : ch0=[%bx] ch1=[%bx] ch2=[%bx] ch3=[%bx] =====\n",        \ 
                                      PCT_DetectVideoFormat(0x00), \
                                      PCT_DetectVideoFormat(0x01), \
                                      PCT_DetectVideoFormat(0x02), \
                                      PCT_DetectVideoFormat(0x03) \
C51 COMPILER V9.01   COMMANDSHELL                                                          12/17/2018 16:46:12 PAGE 10  

                      );
              }
              
              // ***************************************************************************
              //
              // Monitor Setting Video Format 
              //
              void MoniSetVideoFormat(PCHAR szParam)
              {
                      data U8 selch0,selch1,selch2,selch3;    
                      data U8 valch0,valch1,valch2,valch3;    
                      char *getStr;
              
                      PCT_GetFirstStr(&getStr,&szParam);
              
                      switch( atoi(getStr) ) {
                      case 1:
                              sscanf(szParam,"ch%bd:%bd ",&selch0,&valch0);
                              PCT_SetVideoFormat(0, selch0, valch0<<4);
                              break;
                      
                      case 2:
                              sscanf(szParam,"ch%bd:%bd ch%bd:%bd ", \
                                      &selch0, &valch0, &selch1, &valch1);
                              PCT_SetVideoFormat(0, selch0, valch0<<4);
                              PCT_SetVideoFormat(0, selch1, valch1<<4);
                              break;
                      
                      case 3:
                              sscanf(szParam,"ch%bd:%bd ch%bd:%bd ch%bd:%bd ", \
                                      &selch0, &valch0, &selch1, &valch1, &selch2, &valch2);
                              PCT_SetVideoFormat(0, selch0, valch0<<4);
                              PCT_SetVideoFormat(0, selch1, valch1<<4);
                              PCT_SetVideoFormat(0, selch2, valch2<<4);
                              break;
                      
                      case 4:
                              sscanf(szParam,"ch%bd:%bd ch%bd:%bd ch%bd:%bd ch%bd:%bd ", \
                                      &selch0, &valch0, &selch1, &valch1, &selch2, &valch2, &selch3, &valch3);
                              PCT_SetVideoFormat(0, selch0, valch0<<4);
                              PCT_SetVideoFormat(0, selch1, valch1<<4);
                              PCT_SetVideoFormat(0, selch2, valch2<<4);
                              PCT_SetVideoFormat(0, selch3, valch3<<4);
                              break;
              
                      default:
                              break;
                      }
              }
              
              // ***************************************************************************
              //
              // Monitor Setting Video Format 
              //
              #endif
 606          void MoniShowSODStr(PCHAR szParam)
 607          {
 608   1              data U8 addrx,addry;
 609   1              char *getStr;
 610   1              
 611   1              PCT_GetFirstStr(&getStr,&szParam);
 612   1              addrx=atoi(getStr);
C51 COMPILER V9.01   COMMANDSHELL                                                          12/17/2018 16:46:12 PAGE 11  

 613   1              PCT_GetFirstStr(&getStr,&szParam);
 614   1              addry=atoi(getStr);
 615   1      
 616   1              PCT_PreSetForegroundColor(OSD_COL_100WHT);
 617   1              PCT_PreSetBackgroundColor(OSD_COL_BLU);
 618   1              PCT_SetOSDDrawPage(WRPHX_PAGE5);
 619   1              PCT_ShowOSDString(PTH_X, addrx, addry, szParam);
 620   1              PCT_EnShowOSDPage(WRPHX_PAGE5);
 621   1      }
 622          
 623          // ***************************************************************************
 624          //
 625          // Audio Control for HiSarp
 626          //
 627          #if 0
              void PCT_AudioActionForHS(void)
              {
                      data U8 winid;
                      data U8 muteFlage=true;
              
                      // ------------- Control Audio ------------
                      for(winid=0; winid<4; winid++) {
                              if(SYSWINATTR[winid]&BIT4) {
                                      PCT_AudioSelLive(0,WINCH[winid]);
                                      muteFlage = false;
                              }
                      }
              
                      if(muteFlage) {
                              // Audio Mute
                              PCT_AudioMixMute(0, ADO_MIX_MUTE_AIN0+ \
                                                                      ADO_MIX_MUTE_AIN1+ \
                                                                      ADO_MIX_MUTE_AIN2+ \
                                                                      ADO_MIX_MUTE_AIN3+ \
                                                                      ADO_MIX_MUTE_PBAI, OFF);
                              PCT_AudioSelLive(0, 0xFF);
                      }
                      // ----------------------------------------
              }
              #endif
 653          // ***************************************************************************
 654          //
 655          // Command Shell for HiSarp
 656          //
 657          BYTE xdata Original_selwintype = 0;//Kane @HS 2007 0724 Ver3.4
 658          void MoniHSComm(PCHAR szParam) {
 659   1              data U8 winid;
 660   1              data U8 chose,wintp;
 661   1              
 662   1              sscanf(szParam, "%bx %bx ch%bx:%bx ch%bx:%bx ch%bx:%bx ch%bx:%bx ",
 663   1              &chose, &wintp, &WINCH[0], &SYSWINATTR[0], &WINCH[1], &SYSWINATTR[1], &WINCH[2], &SYSWINATTR[2], &WINCH[3
             -], &SYSWINATTR[3]);
 664   1      
 665   1              selwintype = (SYSTYPE<<7)+(chose<<4)+(wintp&0x0F);
 666   1      
 667   1              // ----------- Y Chanle setting windows horizontal mirror ----------
 668   1                      
 669   1              SYSCHATTR[WINCH[0]]=SYSWINATTR[0];
 670   1              SYSCHATTR[WINCH[1]]=SYSWINATTR[1];
 671   1              SYSCHATTR[WINCH[2]]=SYSWINATTR[2];
 672   1              SYSCHATTR[WINCH[3]]=SYSWINATTR[3];
 673   1      
C51 COMPILER V9.01   COMMANDSHELL                                                          12/17/2018 16:46:12 PAGE 12  

 674   1              PCT_WinAttrCtrlY(0, WIN_HMIRROR, SYSCHATTR[0]&BIT0);    
 675   1              PCT_WinAttrCtrlY(1, WIN_HMIRROR, SYSCHATTR[1]&BIT0);    
 676   1              PCT_WinAttrCtrlY(2, WIN_HMIRROR, SYSCHATTR[2]&BIT0);    
 677   1              PCT_WinAttrCtrlY(3, WIN_HMIRROR, SYSCHATTR[3]&BIT0);    
 678   1              // -----------------------------------------------------------------
 679   1      
 680   1              // ------------- Control Video ------------
 681   1              //if(Original_selwintype != selwintype)//Kane @HS 2007 0724 Ver3.4
 682   1      
 683   1      
 684   1              PCT_RecompenseYHdelay(SYSCHATTR);
 685   1              PCT_SetVideoHDelay(selwintype, WINCH, SYSWINATTR);
 686   1      
 687   1              
 688   1              PCT_SetXVideoMixing(selwintype, WINCH);
 689   1              
 690   1              //PCT_VideoLastModify();
 691   1              for(winid=0; winid<4; winid++) 
 692   1                      PCT_WinAttrCtrl(winid, WIN_HMIRROR, SYSWINATTR[winid]&BIT0);    
 693   1              // ----------------------------------------
 694   1      
 695   1      #if 1
 696   1              // ------------- Control OSD ------------
 697   1              DisUserTimer(USERTMID0);                // Disable real-time detect VLoss
 698   1              EnUserTimer(USERTMID1,5);               // Enable OSD Delay Timer
 699   1              PCT_FlashOSDCtrl(ON);
 700   1              
 701   1              PCT_CheckVMixType(selwintype);
 702   1              PCT_DisShowOSDPage(DISOSD_PHX);
 703   1              PCT_ClearOSDPageX(WRPHX_PAGE0);
 704   1              PCT_ShowModeIcon();
 705   1              PCT_OSD_ActionPthX(SYSWINATTR);
 706   1              Original_selwintype = selwintype;//Kane @HS 2007 0724 Ver3.4
 707   1      #else
                      // ------------- Control OSD ------------
                      DisUserTimer(USERTMID0);                // Disable real-time detect VLoss
                      EnUserTimer(USERTMID1,5);               // Enable OSD Delay Timer
                      PCT_FlashOSDCtrl(ON);
                      PCT_CheckVMixType(selwintype);
                      PCT_DisShowOSDPage(DISOSD_PHX);
                      PCT_ClearOSDPageX(WRPHX_PAGE0);
                      PCT_ShowModeIcon();
                      PCT_OSD_ActionPthX(SYSWINATTR);
                      Original_selwintype = selwintype;//Kane @HS 2007 0724 Ver3.4
              #endif
 719   1      
 720   1      
 721   1      
 722   1      
 723   1              // --------------------------------------
 724   1      }
 725          
 726          
 727          // ***************************************************************************
 728          //
 729          // Real Time Check System Type PAL or NTSC
 730          //
 731          bit PCT_CheckSystem(void)
 732          {
 733   1              //Kane add>>>>
 734   1              char TempSystem;
 735   1              TempSystem = PCT_DetectVideoFormat(SENSORCHANNEL);
C51 COMPILER V9.01   COMMANDSHELL                                                          12/17/2018 16:46:12 PAGE 13  

 736   1              //if(SYSTYPE == PCT_DetectVideoFormat(SENSORCHANNEL)) return true;//Kane canceled
 737   1              if(TempSystem == NONE_SYSTEM)
 738   1                      return FALSE;
 739   1              if(TempSystem == SYSTYPE)
 740   1                      return TRUE;
 741   1              SYSTYPE = TempSystem;
 742   1              //Kane Add<<<<
 743   1              //SYSTYPE = PCT_DetectVideoFormat(SENSORCHANNEL);//Kane canceled
 744   1              SYSMIXTYP = (SYSTYPE<<7)|(SYSMIXTYP&0x7F);
 745   1      
 746   1              PCT_EnShowOSDPage(WRPHX_PAGE1);
 747   1      
 748   1      
 749   1              // ------------- Control Video ------------
 750   1              PCT_ChangeSystemType(SYSTYPE);
 751   1              PCT_RecompenseYHdelay(SYSCHATTR);       // preset Y Recompense
 752   1              PCT_SetVideoHDelay(RECWINTYPE, WINCH, SYSWINATTR);
 753   1              
 754   1              PCT_SetXVideoMixing(RECWINTYPE, WINCH);
 755   1              //PCT_VideoLastModify();
 756   1          
 757   1              // ------------- Control OSD ------------
 758   1              PCT_ClearOSDPageX(WRPHX_PAGE0);
 759   1              PCT_ShowModeIcon();
 760   1              PCT_OSD_ActionPthX(SYSWINATTR);
 761   1              PCT_OSDActionForHS();
 762   1              // --------------------------------------
 763   1              
 764   1              return 1;
 765   1      }
 766          
 767          
 768          // ***************************************************************************
 769          //
 770          // Command Shell for HiSarp Setting S or J Mode
 771          //
 772          void MoniHSCommSJmode(PCHAR szParam)
 773          {
 774   1              sscanf(szParam, "%bd ", &SYSMODE);
 775   1      }
 776          
 777          // ***************************************************************************
 778          //
 779          // Command Shell for HiSarp Setting S or J Mode
 780          //
 781          #if 0
              void MoniHSCommDisScroll(void)
              {
                      PCT_EnShowOSDPage(WRPHX_PAGE1);
              }
              // ***************************************************************************
              //
              // Command Shell for HiSarp Setting S or J Mode
              //
              void MoniHSCommVersion(void)
              {
                      RS_tx(VERSION[0]);
                      RS_tx(VERSION[1]);
              }
              #endif
 796          
 797          // ***************************************************************************
C51 COMPILER V9.01   COMMANDSHELL                                                          12/17/2018 16:46:12 PAGE 14  

 798          //
 799          // Runing Command Shell
 800          //
 801          
 802          U8 PCT_RunCommShell(char *strptr)
 803          {
 804   1              U16 commcode;
 805   1              char *getStr;  
 806   1       
 807   1      
 808   1      //printf("char *strptr=%s\r\n",strptr);//ryan..
 809   1      
 810   1      
 811   1                      //MoniHSComm(strptr);
 812   1                      //PCT_AudioActionForHS();
 813   1                      //PCT_OSDActionForHS();  
 814   1                 //PCT_FlashOSDCtrl(OFF);
 815   1                // return 0;
 816   1       //    getStr=&CommTable[0];
 817   1              // ---------- Run Command Shell Entry ----------
 818   1              //Kane @HS 2007 0809 Ver3.5>>>>
 819   1              PCT_GetFirstStr(&getStr, &strptr);
 820   1              //getStr=strptr+4;
 821   1              //Kane @HS 2007 0809 Ver3.5<<<<
 822   1              commcode = PCT_StrToCommCode(getStr); 
 823   1              #if 0
                      if (commcode == PCT_StrToCommCode("&")) {
                              //printf("Read Page Buffer Data");
                              MoniReadPageBuffer(strptr);
                      }else if( commcode == PCT_StrToCommCode("(")) {
                              //printf("Read One Buffer Data");
                              MoniReadOneBuffer(strptr);
                      }else if( commcode == PCT_StrToCommCode(")")) {
                              //printf("Write One Buffer Data");
                              MoniWriteOneBuffer(strptr);
                              
                      }
              
                      else
              #endif
 838   1                      if( commcode == PCT_StrToCommCode("busw")) {
 839   2                      // ===== ASICBUS Write Byte ======
 840   2                      //printf("Command is Write Bus");
 841   2                      MoniWriteAsicByte(strptr);
 842   2      
 843   2              } 
 844   1      
 845   1      #if 0
                      else if (commcode == PCT_StrToCommCode("busr")) {
                              // ===== ASICBUS Read Byte =======
                              //printf("Command is Read Bus");
                              MoniReadAsicByte(strptr);
                      }
              
                      else if (commcode == PCT_StrToCommCode("amix")) {
                              // ===== Audio mix =======
                              //printf("Command is Audio Mixing");
                              MoniAudioMixing(strptr);
                      } else if (commcode == PCT_StrToCommCode("amute")) {
                              // ===== Audio Mute =======
                              //printf("Command is Audio Mute");
                              MoniAudioMute();
C51 COMPILER V9.01   COMMANDSHELL                                                          12/17/2018 16:46:12 PAGE 15  

                      } else if (commcode == PCT_StrToCommCode("adump")) {
                              // ===== List Audio Register Value =======
                              //printf("List Audio Register Value");
                              PCT_AudioRegList();
                      } else if (commcode == PCT_StrToCommCode("again")) {
                              // ===== Audio Gain Control =======
                              //printf("Audio Gain Control");
                              MoniAudioGain(strptr);
                      } else if (commcode == PCT_StrToCommCode("alive")) {
                              // ===== Audio Select Live & Mixing Mode =======
                              //printf("Audio Select Live & Mixing Mode");
                              MoniAudioLive(strptr);
                      } else if (commcode == PCT_StrToCommCode("busrt")) {
                              // ===== All Register Dump =======
                              //printf("All Register Dump");
                              MoniRegisterDump();
                      } else if (commcode == PCT_StrToCommCode("vmix")) {
                              // ===== Video Mix's Windows Type Select =======
                              //printf("Video Mix's Windows Type Select");
                              PCT_WinAttrClear(WIN_FREEZE);
                              MoniVideoMixWin(strptr);
                              PCT_SendACK();
                      } else if (commcode == PCT_StrToCommCode("vmixerr")) {
                              // ===== Video Mix's Windows Type Select =======
                              //printf("Video Mixerr's Windows Type Select");
                              MoniVideoMixWin(strptr); 
                      } else if (commcode == PCT_StrToCommCode("vattr")) {
                              // ===== Video Mixing Control =======
                              //printf("Video Attribute Control");
                              MoniVideoMixAttr(strptr);
                              
                      } 
              
              
                      else
              #endif
 896   1                      else if (commcode == PCT_StrToCommCode("yvmix")) {              // HiSharp has used
 897   2                      // ===== Video Mixing Control =======
 898   2                      PCT_SendACK();
 899   2                      //printf("Video Attribute Control");
 900   2                      MoniYVideoMix(strptr);
 901   2                      
 902   2              }
 903   1              #if 0
                      else if (commcode == PCT_StrToCommCode("init")) {
                              // ===== TW2835 initial =======
                              //printf("Initial TW2835");
                              PCT_InitialTW2835();
                      } else if (commcode == PCT_StrToCommCode("vdet")) {
                              // ===== Video Mixing Control =======
                              //printf("Auto Detectation Video Format");
                              MoniVideoAutoDetect();
                      } else if (commcode == PCT_StrToCommCode("vsetf")) {
                              // ===== Video Mixing Control =======
                              //printf("Setting Video Format Control");
                              MoniSetVideoFormat(strptr);
                      } else if (commcode == PCT_StrToCommCode("sstr")) {
                              // ===== Show String on OSD =======
                              //printf("Show String on OSD");
                              MoniShowSODStr(strptr);
              // --------------------------------------------------------------------------------
              
C51 COMPILER V9.01   COMMANDSHELL                                                          12/17/2018 16:46:12 PAGE 16  

                      }
              #endif  
 924   1              else if (commcode == PCT_StrToCommCode("hscom")) {              // HiSharp has used
 925   2                      PCT_SendACK();
 926   2                      //printf("Command Shell for HiSharp");
 927   2                      MoniHSComm(strptr);
 928   2      
 929   2      #if 1
 930   2                      PCT_OSDActionForHS();
 931   2                      PCT_FlashOSDCtrl(OFF);
 932   2      #else
                              //PCT_AudioActionForHS();
                              PCT_OSDActionForHS();
                              PCT_FlashOSDCtrl(OFF);
              #endif
 937   2      
 938   2                      #ifdef TW2835_degug
                              TW2835_get(0);
                              #endif          
 941   2      
 942   2      
 943   2                      
 944   2              } else if (commcode == PCT_StrToCommCode("mode")) {                     // HiSharp has used
 945   2                      PCT_SendACK();
 946   2                      //printf("Command Shell for HiSharp Set S or J Mode");
 947   2                      MoniHSCommSJmode(strptr);
 948   2              } 
 949   1      #if 0
                      else if (commcode == PCT_StrToCommCode("disscroll")) {  // HiSharp has used
                              PCT_SendACK();
                              //printf("Command Shell for HiSharp Disable Scroll!");
                              MoniHSCommDisScroll();
                      } else if (commcode == PCT_StrToCommCode("ver")) {      // HiSharp has used
                              PCT_SendACK();
                              //printf("Command Shell for HiSharp Disable Scroll!");
                              MoniHSCommVersion();
                              //PCT_InitialTW2835();//Kane @HS 2007 0723 Ver3.4
              // --------------------------------------------------------------------------------
                      } 
              #endif
 962   1              else if(commcode == PCT_StrToCommCode("7"))
 963   1                              {
 964   2                                      //Monitor_set((Com_pos));       
 965   2                                       Monitor_mode=Com_run;
 966   2                                       
 967   2                              #ifdef  SC16IS750_DEBUG_PRINT 
                                      printf("\r\nget Monitor=%x",(U16) Com_run);
                                      #endif
 970   2                              }
 971   1                         else if(commcode == PCT_StrToCommCode("8"))
 972   1                              {
 973   2      
 974   2                                      Repeat_PWM_Com();
 975   2                                      PWM_set(Com_run);       
 976   2                                      
 977   2                                      #ifdef  SC16IS750_DEBUG_PRINT 
                                              printf("\r\nget PWM=%x",(U16)Com_run);
                                              #endif          
 980   2                                      
 981   2                              }
 982   1                            else if(commcode == PCT_StrToCommCode("0123456789ABCDEF"))
 983   1                              {
C51 COMPILER V9.01   COMMANDSHELL                                                          12/17/2018 16:46:12 PAGE 17  

 984   2                              MoniShowSODStr(strptr);///re-build warning issue add by ryan@20181204
 985   2                              }
 986   1                         #if 0//ryan@20150818
                                      else if (commcode == PCT_StrToCommCode("1"))
                                      {               
                                              if(SC16_Com[2]==0x31)
                                              {
                                              Temp_check();
                                              #ifdef  SC16IS750_DEBUG_PRINT 
                                              printf("\r\nget temp=%x",(U16)ADT75_GetTemp());
                                              #endif
                                              }
                                              else if(SC16_Com[2]==0x33)
                                              {
                                              Press_check();
                                              #ifdef  SC16IS750_DEBUG_PRINT 
                                              printf("\r\nget Press_check=%x",(U16)ADC_FPBS());
                                              #endif
                                              }
                                              else if(SC16_Com[2]==0x50)
                                                      {
                                                      Version_check();
                                                      #ifdef  SC16IS750_DEBUG_PRINT 
                                                      printf("\r\nget Version=%x%x%x",(U16)Ver0,(U16)Ver1,(U16)Ver2);
                                                      #endif
                                                      }
                                      
                                              
                                      }
                                      #endif
1014   1                              else
1015   1                                      {
1016   2                                      }
1017   1      
1018   1              //ResetCommSell(); 
1019   1                              
1020   1              // ---------------------------------------------
1021   1              return true;
1022   1      }
1023          
1024          
1025          // ===========================================================================
1026          // END of File 
1027          // ===========================================================================
1028          
1029          
1030          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1312    ----
   CONSTANT SIZE    =    114    ----
   XDATA SIZE       =     29      23
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----      13
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
