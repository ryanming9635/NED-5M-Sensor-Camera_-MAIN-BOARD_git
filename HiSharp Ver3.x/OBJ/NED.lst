C51 COMPILER V9.50a   NED                                                                  02/18/2019 18:00:34 PAGE 1   


C51 COMPILER V9.50a, COMPILATION OF MODULE NED
OBJECT MODULE PLACED IN .\OBJ\NED.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE NED.c LARGE OPTIMIZE(9,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\OBJ\NED.lst
                    -) TABS(2) OBJECT(.\OBJ\NED.obj)

line level    source

   1          #include "types.h"
   2          #include "NED.h"                  //add by ryan.
   3          #include "Main.h"
   4          #include "printf.h"
   5          //#include "Timer.h"
   6          #include "UART.h"
   7          #include "BusCtrl.h"
   8          //#include "TW2835_Init.h"
   9          #include "CommandShell.h"
  10          //#include "OSDAction.h"
  11          
  12          #define I2C_SCL   P2_5
  13          #define I2C_SDA   P2_6
  14          
  15          #define SC16IS750_CRYSTCAL_FREQ 1843200  ///1.8432MHz
  16          
  17          
  18          #define I2C_time 100
  19          #define SC16_data_buf (6*3)
  20          #define BaudRate_sel 38400
  21          //#define BaudRate_sel 9600
  22          
  23          #define dvr_com_flag 1
  24          #define camera_com_flag 2
  25          
  26           //U8 Com_buf[8]={0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff};  
  27           U8 Com_pos=0;
  28           U8 Com_addr=0;
  29           U8 Com_start=0;
  30            U8 Com_end=0;
  31            U8 Com_run=0;
  32          //U8 Monitor_mode=Monitor_offset;
  33          //U8 Monitor_current=Monitor_offset;
  34          U8 Monitor_mode=Monitor_offset+3;
  35          U8 Monitor_state=Monitor_offset;
  36          U8 Monitor_current=1;  //CR
  37          U8 Front_f=0;
  38          U8 Back_f=0;
  39          U8 Shrink_f=0;
  40          U8 Shrink_only_f=0;
  41          U8 Crop_f=0;//ryan@21050413
  42          //U8 Main_p=Camera_p;
  43          //U8 Small_p=Rear_p;
  44          extern U8 work_flag;
  45           U8 Com_flag=0;    
  46           U8 Com_temp=0;
  47           U8 INT_flag=0;
  48           U8 DRP_ID[9]={DVR_address,RF_ID_address,PIC32_address,RF_ID_address\
  49              ,PIC32_address,DVR_address,PIC32_address,DVR_address,RF_ID_address};
  50          
  51           U8 SC16_Com[9];   //0-15, 0-5=DVR, 6-11=RF, 12-16=PIC32
  52           U8 SC16_ComAddr=0;
  53           U8 GPIO_current=0;
  54           U8 DVR_startup_flag=0;
C51 COMPILER V9.50a   NED                                                                  02/18/2019 18:00:34 PAGE 2   

  55           U8 Cam_startup_flag=0;
  56           U8 DVR_Com[5]={0x02,0x37,0x32,0x03,0x04};
  57           U8 DVR_Com_p=0;
  58           U8 Cam_Com[5]={0x02,0x37,0x33,0x03,0x05};
  59           U8 Cam_Com_p=0;
  60          //camera temp data
  61          U8 Camera_ver0=0x30;
  62          U8 Camera_ver1=0x30;
  63          U8 Camera_ver2=0x30;
  64          U8 Camera_temp0=0x30;
  65          U8 Camera_temp1=0x30;
  66          U8 Camera_press0=0x30;
  67          U8 Camera_press1=0x30;
  68          U8 Camera_press2=0x30;
  69          U8 Camera_press3=0x30;
  70          
  71          U8 Camera_IRDA[28]={0x30,0x30,0x30,0x30,0x30,0x30,0x30,\
  72                    0x30,0x30,0x30,0x30,0x30,0x30,0x30,
  73                    0x30,0x30,0x30,0x30,0x30,0x30,0x30,
  74                    0x30,0x30,0x30,0x30,0x30,0x30,0x30};
  75          //U8 Camera_IRDA1[4]={0x30,0x30,0x30,0x30};
  76          //U8 Camera_IRDA2[4]={0x30,0x30,0x30,0x30};
  77          //U8 Camera_IRDA3[4]={0x30,0x30,0x30,0x30};
  78          //U8 Camera_IRDA4[4]={0x30,0x30,0x30,0x30};
  79          //U8 Camera_IRDA5[4]={0x30,0x30,0x30,0x30};
  80          //U8 Camera_IRDA6[4]={0x30,0x30,0x30,0x30};
  81          
  82          
  83          U8 Camera_Ang[4]={0x30,0x30,0x30,0x30};
  84          U8 Camera_RAng[4]={0x30,0x30,0x30,0x30};
  85          
  86          
  87          //dvr temp data
  88          U8 DVR_ver[3]={0x30,0x30,0x30};
  89          U8 DVR_temp[2]={0x30,0x30};
  90          U8 DVR_Y[4]={0x30,0x30,0x30,0x30};
  91          U8 DVR_MD[4]={0x30,0x30,0x30,0x30};
  92          U8 DVR_MH[4]={0x30,0x30,0x30,0x30};
  93          
  94          
  95           //get data from sc16--------------------
  96           U16 SC16_busy_flag=0;
  97          // U8 SC16_com_state=0;
  98           U8 SC16_com_buff[9]={0,0,0,0,0,0,0,0,0};
  99           U8 data_flag=0;
 100          //----------------------------------------
 101          U8 Cam_boot_flag=0;
 102          //U8 Cam_boot_count_flag=0;
 103          
 104          U8 get_data_addr=0;
 105          U8 get_data_val=0;
 106           //U16 BaudRate[3]={12,6,3};  //9600/19200/38400
 107           //U8 BaudRate_sel=9600;  //Default 9600
 108           //U32 BaudRate_sel=9600;  //Default 9600
 109          //U32 BaudRate_sel=19200;  //Default 9600
 110          //U32 BaudRate_sel=38400;  //Default 9600
 111          #ifdef Move_Camera
 112          U8 Camera_flag=0;
 113          
 114          #endif
 115            
 116           U8 OUTPUT=0;
C51 COMPILER V9.50a   NED                                                                  02/18/2019 18:00:34 PAGE 3   

 117           U8 peek_flag=0,peek_buf=0;
 118          extern data user_timer[TIMER_NUM];
 119          
 120          //extern user_timer[3];
 121           
 122          //-------------I2C 
 123           void I2Cdelay(void)
 124           {
 125   1         #if 1//ryan@20151106
 126   1      
 127   1      
 128   1        //for(i=0; i<(1); i++)
 129   1        //  {
 130   1        //  }
 131   1         
 132   1         #else
                   U16 i; 
                 for(i=0; i<(20-12); i++){
              //          for(i=0; i<(20+120); i++){  //ryan..
                 }
                 #endif
 138   1       }
 139          #if 0
               void I2Cdelay2(void)
               {
                 U16 i;
                 for(i=0; i<(20); i++){
              //          for(i=0; i<(20+120); i++){  //ryan..
                 }
               }
              
              void I2C_100Khz(void)
              {
              
              while(USERTMVAL1>=2);
              USERTMVAL1=2;
              }
              #endif
 155          void I2CStart(void)
 156          {
 157   1      #if 1
 158   1            I2C_SDA = 1;  I2Cdelay(); 
 159   1        I2C_SCL = 1;  I2Cdelay();
 160   1        I2C_SDA = 0;  I2Cdelay();
 161   1        I2C_SCL = 0;
 162   1      #else
              //I2C_100Khz();
                  I2C_SCL = 1;
              // DELAY_FOR(10);///  I2Cdelay();
                  I2C_SDA = 1;
                  DELAY_FOR(I2C_time);///  I2Cdelay();
                  I2C_SDA = 0;
              
              DELAY_FOR(I2C_time);///  I2Cdelay();
              I2C_SCL = 0;
              
                  //DELAY_FOR(I2C_time);///  I2Cdelay();
                 // I2Cdelay();
              
              #endif
 177   1      }
 178          #if 0
C51 COMPILER V9.50a   NED                                                                  02/18/2019 18:00:34 PAGE 4   

              void I2CStart2(void)
              {
              
                    I2C_SDA = 1;  I2Cdelay2(); 
                I2C_SCL = 1;  I2Cdelay2();
                I2C_SDA = 0;  I2Cdelay2();
                I2C_SCL = 0;
              }
              #endif
 188          void I2CStop(void)
 189          {
 190   1         #if 1
 191   1        I2C_SDA = 0;  I2Cdelay();
 192   1        I2C_SCL = 1;  I2Cdelay();
 193   1        I2C_SDA = 1;
 194   1          #else
                    //DELAY_FOR(I2C_time);///I2Cdelay();  
                 I2C_SCL = 1;
                     //I2C_100Khz();
                       DELAY_FOR(I2C_time);///I2Cdelay();  
                 I2C_SDA = 0;
                    //      I2C_100Khz();
                    DELAY_FOR(I2C_time);/// I2Cdelay();
              
                  I2C_SDA = 1; 
                      // I2C_100Khz();
                    DELAY_FOR(I2C_time);///  I2Cdelay();
              
                  #endif
 208   1      }
 209          #if 0
              void I2CStop2(void)
              {
                 
                I2C_SDA = 0;  I2Cdelay2();
                I2C_SCL = 1;  I2Cdelay2();
                I2C_SDA = 1;
              }
              #endif
 218          void I2CWriteData(BYTE value)
 219          {
 220   1         #if 1
 221   1        I2C_SCL=0;  I2C_SDA=(value & 0x80)? 1:0;  I2Cdelay(); I2C_SCL=1;  I2Cdelay();
 222   1        I2C_SCL=0;  I2C_SDA=(value & 0x40)? 1:0;  I2Cdelay(); I2C_SCL=1;  I2Cdelay();
 223   1        I2C_SCL=0;  I2C_SDA=(value & 0x20)? 1:0;  I2Cdelay();I2C_SCL=1; I2Cdelay();
 224   1        I2C_SCL=0;  I2C_SDA=(value & 0x10)? 1:0;  I2Cdelay(); I2C_SCL=1;  I2Cdelay();
 225   1      
 226   1        I2C_SCL=0;  I2C_SDA=(value & 0x08)? 1:0;  I2Cdelay(); I2C_SCL=1;  I2Cdelay();
 227   1        I2C_SCL=0;  I2C_SDA=(value & 0x04)? 1:0;  I2Cdelay(); I2C_SCL=1;  I2Cdelay();
 228   1        I2C_SCL=0;  I2C_SDA=(value & 0x02)? 1:0;  I2Cdelay(); I2C_SCL=1;  I2Cdelay();
 229   1        I2C_SCL=0;  I2C_SDA=(value & 0x01)? 1:0;  I2Cdelay(); I2C_SCL=1;  I2Cdelay();
 230   1      
 231   1      
 232   1        I2C_SCL = 0;  // HHY 3.00
 233   1        I2C_SCL = 0;  // HHY 3.00
 234   1        I2C_SCL = 0;  //I2Cdelay();
 235   1            I2C_SDA = 1;  //I2Cdelay();
 236   1            
 237   1        I2C_SCL = 1;  // HHY 3.00
 238   1        I2C_SCL = 1;  // HHY 3.00
 239   1        I2C_SCL = 1;
 240   1          I2Cdelay();
C51 COMPILER V9.50a   NED                                                                  02/18/2019 18:00:34 PAGE 5   

 241   1        I2C_SCL = 0;
 242   1              I2Cdelay();
 243   1          #else
                BYTE i, tmpbyte = value;
                    //  tmpbyte=0x55;
              //I2Cdelay();
                for(i = 0; i < 8; i++)
                {
                  if((0x80 & tmpbyte))
                    I2C_SDA=1;///GPIO_SetBits(GPIOB, I2C2_SDA);
                  else
                    I2C_SDA=0;///GPIO_ResetBits(GPIOB, I2C2_SDA);
                    //I2C_100Khz();
                          
                  //I2Cdelay();
                        DELAY_FOR(I2C_time);///  I2Cdelay();
                           I2C_SCL=1;
                           //I2C_100Khz();
                              DELAY_FOR(I2C_time);///  I2Cdelay();
                           I2C_SCL=0;
                              DELAY_FOR(I2C_time);///  I2Cdelay();
                           //I2C_100Khz();
                           //DELAY_FOR(5);///I2Cdelay();
                  //I2CDLY_5uSec(1);
                  ///GPIO_SetBits(GPIOB, I2C2_SCL);
                  ///I2CDLY_5uSec(1);
                  ///GPIO_ResetBits(GPIOB, I2C2_SCL);
                  tmpbyte = tmpbyte << 1;
                }
                       //DELAY_FOR(10);///I2Cdelay();
                    //I2Cdelay();
                //I2C_SDA = 1;      //ACK
                // I2C_SCL=1;
                // DELAY_FOR(10);///I2Cdelay();
                   //I2Cdelay();//ryan..
                //I2C_SCL = 1;  // HHY 3.00
                //I2Cdelay(); //ryan..
                //I2C_SCL = 0;
                //I2Cdelay(); //ryan..
                //    I2C_SDA = 1;  //  I2Cdelay();//ryan.
              //     I2Cdelay(); //ryan..
                  
                   #endif
 284   1      }
 285          
 286          #if 0
              void I2CWriteData2(BYTE value)
              {
                
                I2C_SCL=0;  I2C_SDA=(value & 0x80)? 1:0;  I2Cdelay2(); I2C_SCL=1; I2Cdelay2();
                I2C_SCL=0;  I2C_SDA=(value & 0x40)? 1:0;  I2Cdelay2(); I2C_SCL=1; I2Cdelay2();
                I2C_SCL=0;  I2C_SDA=(value & 0x20)? 1:0;  I2Cdelay2();I2C_SCL=1;  I2Cdelay2();
                I2C_SCL=0;  I2C_SDA=(value & 0x10)? 1:0;  I2Cdelay(); I2C_SCL=1;  I2Cdelay2();
              
                I2C_SCL=0;  I2C_SDA=(value & 0x08)? 1:0;  I2Cdelay2(); I2C_SCL=1; I2Cdelay2();
                I2C_SCL=0;  I2C_SDA=(value & 0x04)? 1:0;  I2Cdelay2(); I2C_SCL=1; I2Cdelay2();
                I2C_SCL=0;  I2C_SDA=(value & 0x02)? 1:0;  I2Cdelay2(); I2C_SCL=1; I2Cdelay2();
                I2C_SCL=0;  I2C_SDA=(value & 0x01)? 1:0;  I2Cdelay2(); I2C_SCL=1; I2Cdelay2();
              
              
                I2C_SCL = 0;  // HHY 3.00
                I2C_SCL = 0;  // HHY 3.00
C51 COMPILER V9.50a   NED                                                                  02/18/2019 18:00:34 PAGE 6   

                I2C_SCL = 0;  //I2Cdelay();
                    I2C_SDA = 1;  //I2Cdelay();
                    
                I2C_SCL = 1;  // HHY 3.00
                I2C_SCL = 1;  // HHY 3.00
                I2C_SCL = 1;
                  I2Cdelay2();
                I2C_SCL = 0;
                      I2Cdelay2();
              }
              #endif
 314          
 315          
 316          U8 I2CReadData(void)
 317          {
 318   1      #if 1
 319   1        U16 i;
 320   1        U8 value=0;
 321   1      
 322   1        I2C_SDA = 1;  I2Cdelay();
 323   1        I2C_SCL = 0;
 324   1        
 325   1        for(i=0; i<8; i++) {
 326   2                  I2Cdelay();
 327   2          I2C_SCL = 1;
 328   2          value <<= 1;
 329   2          if(I2C_SDA) value |= 1;
 330   2              I2Cdelay();
 331   2          I2C_SCL = 0;
 332   2              I2Cdelay();
 333   2        }
 334   1       
 335   1             I2Cdelay();
 336   1        //I2C_SCL = 1;  // HHY 3.00
 337   1        //I2C_SCL = 1;  // HHY 3.00
 338   1        //I2C_SCL = 1; 
 339   1         I2Cdelay();
 340   1            //  I2C_SCL = 0;
 341   1              I2Cdelay();
 342   1        return value;
 343   1      #else
                BYTE i, bitt, ReadValue = 0,vall[8]={0,0,0,0,0,0,0,0};
                    U16 val2=0;
                  
                //GPIO_InitTypeDef GPIO_InitStruct;
              
                     //I2Cdelay();
                //I2C_SDA = 1;  I2Cdelay();
                //I2C_SCL = 0; I2Cdelay();
                  
                for(i = 0; i < 8; i++)
                {
              
                  if( I2C_SDA==1) bitt = 0x01;
                  else                     bitt = 0x00;
              
                  // vall[i]=bitt;
              
                    //I2C_100Khz();
                   DELAY_FOR(I2C_time);///  I2Cdelay();
                        //DELAY_FOR(5);/// I2Cdelay();
                          I2C_SCL = 1;
C51 COMPILER V9.50a   NED                                                                  02/18/2019 18:00:34 PAGE 7   

                 DELAY_FOR(I2C_time);///  I2Cdelay();
                      //DELAY_FOR(5);/// I2Cdelay();
                          I2C_SCL = 0;
                 DELAY_FOR(I2C_time);///  I2Cdelay();
                         //DELAY_FOR(5);///   I2Cdelay();
                          //I2Cdelay();          
                  //I2CDLY_5uSec(1);
                  //GPIO_SetBits(GPIOB, I2C2_SCL);
                  //I2CDLY_5uSec(1);    
                  //GPIO_ResetBits(GPIOB, I2C2_SCL);    
                  //I2CDLY_5uSec(1);
                  ReadValue = (ReadValue<<1)|bitt;
                }
              //val2=ReadValue;
              
              //Printf("Val=%X %X %X %X %X %X %X %X \r\n",vall[7],vall[6],vall[5],vall[4],vall[3],vall[2],vall[1],vall[0
             -]);
              //Printf("Val= %x\r\n",val2);
              
              
                    //  I2C_SDA = 1;      //ACK
                // I2C_SCL=1;
                      // DELAY_FOR(10);///   I2Cdelay();
                 //I2Cdelay();  
                //GPIO_InitStruct.GPIO_Mode = GPIO_Mode_Out_PP;
                //GPIO_InitStruct.GPIO_Pin = I2C2_SDA | I2C2_SCL;
                //GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz;
                //GPIO_Init(GPIOB, &GPIO_InitStruct);
              //  I2C_SDA = 0;      //ACK
               //    I2Cdelay();//ryan..
              //  I2C_SCL = 1;  // HHY 3.00
              //  I2Cdelay(); //ryan..
               //      I2C_SCL = 0;
                //I2Cdelay(); //ryan..
                   // I2C_SDA = 1;  //  I2Cdelay();//ryan.
                    // I2Cdelay(); //ryan..
                return ReadValue;
              #endif
 402   1      }
 403          #if 0
              U8 I2CReadData2(void)
              {
              
                U16 i;
                U8 value=0;
              
                I2C_SDA = 1;  I2Cdelay2();
                I2C_SCL = 0;
                
                for(i=0; i<8; i++) {
                          I2Cdelay2();
                  I2C_SCL = 1;
                  value <<= 1;
                  if(I2C_SDA) value |= 1;
                      I2Cdelay2();
                  I2C_SCL = 0;
                      I2Cdelay2();
                }
               
                     I2Cdelay2();
                //I2C_SCL = 1;  // HHY 3.00
                //I2C_SCL = 1;  // HHY 3.00
C51 COMPILER V9.50a   NED                                                                  02/18/2019 18:00:34 PAGE 8   

                //I2C_SCL = 1; 
                 I2Cdelay2();
                    //  I2C_SCL = 0;
                      I2Cdelay2();
                return value;
              }
              #endif
 433          U8 I2CReadDataWithACK(void)
 434          {
 435   1        #if 1
 436   1        U16 i;
 437   1        U8 value=0;
 438   1      
 439   1        I2C_SDA = 1;  I2Cdelay();
 440   1        I2C_SCL = 0;
 441   1      
 442   1        for(i=0; i<8; i++) {
 443   2           I2Cdelay();
 444   2          I2C_SCL = 1;
 445   2          value <<= 1;
 446   2          if(I2C_SDA) value |= 1;
 447   2           I2Cdelay();
 448   2          I2C_SCL = 0;
 449   2           I2Cdelay();
 450   2        }
 451   1        
 452   1        I2C_SDA = 0;//  I2Cdelay();   //ack
 453   1        //I2C_SCL = 1;  I2Cdelay();
 454   1        //I2C_SCL = 0;
 455   1      
 456   1             I2Cdelay();    //ACk
 457   1         I2C_SCL = 1; // HHY 3.00
 458   1         I2C_SCL = 1; // HHY 3.00
 459   1         I2C_SCL = 1; 
 460   1         I2Cdelay();
 461   1              I2C_SCL = 0;
 462   1              I2Cdelay();
 463   1      
 464   1        return value;
 465   1        
 466   1         #else
                  
                    BYTE i, bitt, ReadValue = 0;
                //GPIO_InitTypeDef GPIO_InitStruct;
              
                for(i = 0; i < 8; i++)
                {
              
                  if( I2C_SDA==1) bitt = 0x01;
                  else                     bitt = 0x00;
                      
                          I2Cdelay();
                          I2C_SCL = 1;
                          I2Cdelay();
                          I2C_SCL = 0;
                          I2Cdelay();          
                  //I2CDLY_5uSec(1);
                  //GPIO_SetBits(GPIOB, I2C2_SCL);
                  //I2CDLY_5uSec(1);    
                  //GPIO_ResetBits(GPIOB, I2C2_SCL);    
                  //I2CDLY_5uSec(1);
                  ReadValue = (ReadValue<<1)|bitt;
C51 COMPILER V9.50a   NED                                                                  02/18/2019 18:00:34 PAGE 9   

                }
                  
                I2C_SDA = 0;  I2Cdelay();   //ack
                I2C_SCL = 1;  I2Cdelay();
                I2C_SCL = 0;
                //GPIO_InitStruct.GPIO_Mode = GPIO_Mode_Out_PP;
                //GPIO_InitStruct.GPIO_Pin = I2C2_SDA | I2C2_SCL;
                //GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz;
                //GPIO_Init(GPIOB, &GPIO_InitStruct);
                return ReadValue;
                  
                  #endif
 500   1      }
 501          #if 0
              U8 I2CReadDataWithACK2(void)
              {
              //#if 1
                U16 i;
                U8 value=0;
              
                I2C_SDA = 1;  I2Cdelay2();
                I2C_SCL = 0;
              
                for(i=0; i<8; i++) {
                   I2Cdelay2();
                  I2C_SCL = 1;
                  value <<= 1;
                  if(I2C_SDA) value |= 1;
                   I2Cdelay2();
                  I2C_SCL = 0;
                   I2Cdelay2();
                }
                
                I2C_SDA = 0;//  I2Cdelay();   //ack
                //I2C_SCL = 1;  I2Cdelay();
                //I2C_SCL = 0;
              
                     I2Cdelay2();    //ACk
                 I2C_SCL = 1; // HHY 3.00
                 I2C_SCL = 1; // HHY 3.00
                 I2C_SCL = 1; 
                 I2Cdelay2();
                      I2C_SCL = 0;
                      I2Cdelay2();
              
                return value;
              }
              #endif
 536          void WriteI2C(U8 addr, U8 index, U8 val)
 537          {
 538   1      
 539   1      #if 1
 540   1        I2CStart();
 541   1        I2CWriteData(addr);
 542   1        I2CWriteData(index<<3);
 543   1        I2CWriteData(val);
 544   1        I2CStop();
 545   1      
 546   1      #else
                I2CStart();
                I2CWriteData(addr);
                     I2C_ACK2();
C51 COMPILER V9.50a   NED                                                                  02/18/2019 18:00:34 PAGE 10  

                I2CWriteData((index<<3));
                     I2C_ACK2();
                I2CWriteData(val);
                     I2C_ACK2();
                     I2CStop();
              #endif
 556   1      }
 557          
 558          U8 ReadI2C(U8 addr, U8 index)
 559          {
 560   1      U8 val;//,x,y,z,val2[16];
 561   1      
 562   1             #if 1
 563   1        I2CStart();
 564   1        I2CWriteData(addr);
 565   1        I2CWriteData(index<<3);
 566   1        I2CStart();
 567   1        I2CWriteData(addr | 0x01);
 568   1        val = I2CReadData();
 569   1                //val = I2CReadDataWithACK();
 570   1       
 571   1        I2CStop();
 572   1            #else
                      I2CStart();
                    I2CWriteData(addr);
                   I2C_ACK2(); 
                  I2CWriteData((index<<3));
                   I2C_ACK2();  
                 
                  I2CStart();
                        //   P2M0|=0x40;
                 //DELAY_FOR(20);/// I2Cdelay();
               //USERTMVAL1=2; 
               
                   I2CWriteData(addr|0x01);
                
                 I2C_ACK2(); 
              
              //for(x=0;x<=14;x++)
              //{
                    val = I2CReadData();
                         //  P2M0&=0xBF;
                 //DELAY_FOR(20);/// I2Cdelay();
              //val2[x]=val;
                         // I2C_ACK2();  
                       //val = I2CReadDataWithACK();
                       //I2C_ACK2(); 
              //}
              
                    val = I2CReadData();
                //  val2[15]=val;
               I2CStop();
              
              #if 0
              Printf("-> \r\n",(U16) x,(U16) val2[x]);  //ryan    
              for(x=0;x<=15;x++)
              {
              
              Printf("Addr=%x  Data=%x \r\n",(U16) x,(U16) val2[x]);  //ryan 
              
              }
              Printf("                    <-\r\n",(U16) x,(U16) val2[x]);  //ry   
C51 COMPILER V9.50a   NED                                                                  02/18/2019 18:00:34 PAGE 11  

              #endif
              
                      #endif
 615   1          //Printf("Data=%x \r\n",(U16)val);  //ryan
 616   1        return val;
 617   1      }
 618          //---------------------------------------
 619          #if 0
              void WriteI2C2(U8 addr, U8 index, U8 val)
              {
                I2CStart();
                I2CWriteData(addr);
                I2CWriteData(index);
                I2CWriteData(val);
                I2CStop();
              
              }
              //---------------------------------------
              U8 ReadI2C2(U8 addr, U8 index)
              {
                    U8 val;
                  
                I2CStart();
                I2CWriteData(addr);
                I2CWriteData(index);
                I2CStart();
                I2CWriteData(addr | 0x01);
                val = I2CReadData();
                        //val = I2CReadDataWithACK();
                I2CStop();  
              return 1;  
              }
              
              //----------------------------------------
               void I2C_ACK(void)
              {
                   
                         // I2Cdelay();   //ack
               
                        I2Cdelay();   //ack
                I2C_SCL = 1;
                        I2Cdelay();
                I2C_SCL = 0;
                        I2Cdelay();
                   I2C_SDA = 1;
              }
              
               void I2C_ACK2(void)
              {
                   //while(I2C_SDA==1);
                  //  DELAY_FOR(10);///   I2Cdelay();   //ack
                 // I2C_SDA = 0;
                    //  I2Cdelay();   //ack
                     // DELAY_FOR(5);///     I2Cdelay   
                 DELAY_FOR(I2C_time);///  I2Cdelay();     
                I2C_SCL = 1;
                 DELAY_FOR(I2C_time);///  I2Cdelay();
                   //DELAY_FOR(5);///     I2Cdelay();
                I2C_SCL = 0;
                 DELAY_FOR(I2C_time);///  I2Cdelay();
              // DELAY_FOR(5);///    I2Cdelay();
               //I2C_SDA = 1;
C51 COMPILER V9.50a   NED                                                                  02/18/2019 18:00:34 PAGE 12  

                 //  DELAY_FOR(10);///     I2Cdelay();
                     
              }
               #endif
 678          //----------------------------------------
 679          
 680          U16 ReadI2CWORD(BYTE addr, BYTE index)
 681          {
 682   1        U16 val=0;
 683   1      
 684   1        I2CStart();
 685   1        I2CWriteData(addr);
 686   1            //I2C_ACK();
 687   1        I2CWriteData(index);
 688   1            //I2C_ACK();
 689   1          
 690   1        I2CStart();
 691   1        I2CWriteData(addr | 0x01);
 692   1        
 693   1        val = I2CReadDataWithACK();
 694   1        val = val<<8;
 695   1        val |= I2CReadData();
 696   1        I2CStop();
 697   1      
 698   1        return val;
 699   1      }
 700          //---------------------------------------
 701          #if 0
              void WriteI2CWORD(U8 addr, U8 index, U16 Data)
              {
                    U8 tempL,tempH;
              
                tempH=((Data>>8)&0x00ff);
                tempL=(Data&0x00ff);
                I2CStart();
                I2CWriteData(addr);
                I2CWriteData(index);
                I2CWriteData(tempH);
                I2CWriteData(tempL);
                I2CStop();
              }
              #endif
 716          //----------------------------------------
 717          
 718          void Bound_Set(U8 val)
 719          {
 720   1      
 721   1      
 722   1      //U8 loop;
 723   1      U8 Mask[3]={0x11,0x19,0x21};
 724   1      
 725   1      #ifdef black_boundary
              switch(val)
              {
              case 1: TW28_WriteByte(1,0x11,0x02); 
                  TW28_WriteByte(1,0x0f,0x00);
                  break;
              case 2: TW28_WriteByte(1,0x19,0x02);
                  TW28_WriteByte(1,0x0f,0x00);
                  break;
              case 4: TW28_WriteByte(1,0x21,0x02);
                  TW28_WriteByte(1,0x0f,0x00);
C51 COMPILER V9.50a   NED                                                                  02/18/2019 18:00:34 PAGE 13  

                  break;
              default:
                  
                  //TW28_WriteByte(1,0x0f,0x03);
                  TW28_WriteByte(1,0x11,0x00);
                  TW28_WriteByte(1,0x19,0x00);
                  TW28_WriteByte(1,0x21,0x00);
                      break;  
              }
              #else
 746   1      switch(val)
 747   1      {
 748   2      case 1: TW28_WriteByte(1,0x11,0x02); 
 749   2          TW28_WriteByte(1,0x0f,0x33);
 750   2          break;
 751   2      case 2: TW28_WriteByte(1,0x19,0x02);
 752   2          TW28_WriteByte(1,0x0f,0x33);
 753   2          break;
 754   2      case 4: TW28_WriteByte(1,0x21,0x02);
 755   2          TW28_WriteByte(1,0x0f,0x33);
 756   2          break;
 757   2      default:
 758   2          
 759   2          //TW28_WriteByte(1,0x0f,0x03);
 760   2          TW28_WriteByte(1,0x11,0x00);
 761   2          TW28_WriteByte(1,0x19,0x00);
 762   2          TW28_WriteByte(1,0x21,0x00);
 763   2              break;  
 764   2      }
 765   1      
 766   1      #endif
 767   1      /*
 768   1      for(loop=0;loop<=2;loop++)
 769   1      {
 770   1        if((val&0x01)==1)
 771   1          {
 772   1          TW28_WriteByte(1,Mask[loop],0x02);  
 773   1          return;
 774   1          }
 775   1        //else
 776   1          //TW28_WriteByte(1,Mask[loop],0x00);  
 777   1        
 778   1        val>>=1;
 779   1      }
 780   1      */
 781   1      
 782   1      
 783   1      }
 784          
 785          //---------------------------------------
 786          #if 0
              void Set_channel(U8 addr)
              {
              TW28_WriteByte(1,0x10,0x00); //C
              TW28_WriteByte(1,0x18,0x00);  //R
              TW28_WriteByte(1,0x20,0x00);  //D
              
              
                switch(addr)
                {
              case 0x10: TW28_WriteByte(1,0x10,0x80); break;  //C
              case 0x20: TW28_WriteByte(1,0x20,0x82); break;  //R
C51 COMPILER V9.50a   NED                                                                  02/18/2019 18:00:34 PAGE 14  

              case 0x40: TW28_WriteByte(1,0x18,0x81); break;  //D
              case 0x12: Bound_Set(0x01); break;  //CR
              case 0x21: Bound_Set(0x01); break;  //RC
              case 0x14: Bound_Set(0x01); break;  //DC
              case 0x41: Bound_Set(0x02); break;  //CD
              case 0x24: Bound_Set(0x01); break;  //DR
              case 0x42: Bound_Set(0x01); break;  //RD
              default:
                   break;
              
                }
               
              }
              #endif
 812          
 813          
 814          //----------------------------------------
 815          
 816          U16 ADC_read(U8 sel)
 817          {
 818   1          
 819   1      ADCTL=0x80|0x08|sel;  //start adc sampling
 820   1      
 821   1      while(ADCTL&0x08);// printf("ADC is busying\r\n");  //wating for adc
 822   1      
 823   1      return (U16)(((ADCVL&0x03) |(ADCV<<2))&0x03ff);
 824   1      
 825   1      }
 826          
 827          //20160226
 828          //-----------------------------------------
 829          void Set_Video(U8 addr, U8 val)
 830          {
 831   1      switch (addr)
 832   1      {
 833   2      case 0: TW28_WriteByte(0,0x09,val); //VIN0 CONT,TW2871
 834   2          break;
 835   2      case 1: TW28_WriteByte(0,0x0a,val);//VIN0 BRT,TW2871
 836   2          break;
 837   2      case 2:  TW28_WriteByte(0,0x19,val);//VIN1 CONT,Recorder
 838   2          break;
 839   2      case 3:  TW28_WriteByte(0,0x1a,val);//VIN1 BRT,Recorder
 840   2          break;
 841   2      case 4: TW28_WriteByte(0,0x29,val); //VIN2 CONT,Back cam
 842   2          break;
 843   2      case 5:  TW28_WriteByte(0,0x2a,val);//VIN2 BRT,Back cam
 844   2          break;
 845   2      default:
 846   2        break;
 847   2      
 848   2      }
 849   1      
 850   1      
 851   1      }
 852          
 853          
 854          //-----------------------------------------
 855          #if 0
              void Send_Camera_Ver(void)
              {
              U8 loop;
              
C51 COMPILER V9.50a   NED                                                                  02/18/2019 18:00:34 PAGE 15  

              SC16_Com[0]=STX;
              SC16_Com[1]=0x32;
              SC16_Com[2]=0x4f;
              SC16_Com[3]=Camera_ver2;
              SC16_Com[4]=Camera_ver1;
              SC16_Com[5]=Camera_ver0;
              SC16_Com[6]=0x20;
              SC16_Com[7]=ETX;
              SC16_Com[8]=BCC_Cal(SC16_Com, 8);
              
                for(loop=0;loop<=8;loop++)
                {
                RS_tx(SC16_Com[loop]);
                }
              }
              #endif
 876          void Get_Camera_Ver(void)
 877          {
 878   1      WriteByte(DRP_ID[2], 0x02);
 879   1      WriteByte(DRP_ID[2], 0x31);
 880   1      WriteByte(DRP_ID[2], 0x4f);
 881   1      WriteByte(DRP_ID[2], 0x03);
 882   1      WriteByte(DRP_ID[2], 0x7f);
 883   1      }
 884          
 885          //-----------------------------------------
 886          void Send_Camera_Temp(void)
 887          {
 888   1      
 889   1      U8 loop;
 890   1      
 891   1      SC16_Com[0]=STX;
 892   1      SC16_Com[1]=0x32;
 893   1      SC16_Com[2]=0x31;
 894   1      SC16_Com[3]=Camera_temp1;
 895   1      SC16_Com[4]=Camera_temp0;
 896   1      SC16_Com[5]=0x20;
 897   1      SC16_Com[6]=0x20;
 898   1      SC16_Com[7]=ETX;
 899   1      SC16_Com[8]=BCC_Cal(SC16_Com, 8);
 900   1      
 901   1        for(loop=0;loop<=8;loop++)
 902   1        {
 903   2        RS_tx(SC16_Com[loop]);
 904   2        }
 905   1      
 906   1      
 907   1      }
 908          
 909          //----------------------------------------
 910          
 911          void Send_Camera_Press(void)
 912          {
 913   1      U8 loop;
 914   1      
 915   1      SC16_Com[0]=STX;
 916   1      SC16_Com[1]=0x32;
 917   1      SC16_Com[2]=0x33;
 918   1      #if 0
              SC16_Com[3]=Camera_press1;
              SC16_Com[4]=Camera_press0;
              SC16_Com[5]=0x20;
C51 COMPILER V9.50a   NED                                                                  02/18/2019 18:00:34 PAGE 16  

              SC16_Com[6]=0x20;
              #else
 924   1      SC16_Com[3]=Camera_press3;
 925   1      SC16_Com[4]=Camera_press2;
 926   1      SC16_Com[5]=Camera_press1;
 927   1      SC16_Com[6]=Camera_press0;
 928   1      #endif
 929   1      SC16_Com[7]=ETX;
 930   1      SC16_Com[8]=BCC_Cal(SC16_Com, 8);
 931   1      
 932   1        for(loop=0;loop<=8;loop++)
 933   1        {
 934   2        RS_tx(SC16_Com[loop]);
 935   2        }
 936   1      
 937   1      
 938   1      
 939   1      }
 940          
 941          //----------------------------------------
 942          void Get_Camera_Ang(void)
 943          {
 944   1      WriteByte(DRP_ID[2], 0x02);
 945   1      WriteByte(DRP_ID[2], 0x31);
 946   1      WriteByte(DRP_ID[2], 0x34);
 947   1      WriteByte(DRP_ID[2], 0x03);
 948   1      WriteByte(DRP_ID[2], 0x04);
 949   1      
 950   1      }
 951          
 952          void Sent_Camera_Ang(void)
 953          {
 954   1      
 955   1      U8 loop;
 956   1      
 957   1      SC16_Com[0]=STX;
 958   1      SC16_Com[1]=0x32;
 959   1      SC16_Com[2]=0x34;
 960   1      SC16_Com[3]=Camera_Ang[3];
 961   1      SC16_Com[4]=Camera_Ang[2];
 962   1      SC16_Com[5]=Camera_Ang[1];
 963   1      SC16_Com[6]=Camera_Ang[0];
 964   1      SC16_Com[7]=ETX;
 965   1      SC16_Com[8]=BCC_Cal(SC16_Com, 8);
 966   1      
 967   1        for(loop=0;loop<=8;loop++)
 968   1        {
 969   2        RS_tx(SC16_Com[loop]);
 970   2        }
 971   1      
 972   1      }
 973          //----------------------------------------
 974          void Get_Camera_RAng(void)
 975          {
 976   1      WriteByte(DRP_ID[2], 0x02);
 977   1      WriteByte(DRP_ID[2], 0x31);
 978   1      WriteByte(DRP_ID[2], 0x35);
 979   1      WriteByte(DRP_ID[2], 0x03);
 980   1      WriteByte(DRP_ID[2], 0x05);
 981   1      }
 982          
 983          void Sent_Camera_RAng(void)
C51 COMPILER V9.50a   NED                                                                  02/18/2019 18:00:34 PAGE 17  

 984          {
 985   1      
 986   1      U8 loop;
 987   1      
 988   1      SC16_Com[0]=STX;
 989   1      SC16_Com[1]=0x32;
 990   1      SC16_Com[2]=0x35;
 991   1      SC16_Com[3]=Camera_RAng[3];
 992   1      SC16_Com[4]=Camera_RAng[2];
 993   1      SC16_Com[5]=Camera_RAng[1];
 994   1      SC16_Com[6]=Camera_RAng[0];
 995   1      SC16_Com[7]=ETX;
 996   1      SC16_Com[8]=BCC_Cal(SC16_Com, 8);
 997   1      
 998   1        for(loop=0;loop<=8;loop++)
 999   1        {
1000   2        RS_tx(SC16_Com[loop]);
1001   2        }
1002   1      
1003   1      }
1004          //----------------------------------------
1005          #if 0
              void Get_Camera_IRD(U8 sel)
              {
              //U8 bcc[4]={0x02,0x31,0,0x03},bcc_val;
              U8 bcc_val=0;
              
              bcc_val^=STX;
              bcc_val^=0x31;
              bcc_val^=sel;
              bcc_val^=ETX;
                
              //bcc_val=BCC_Cal(&bcc[0],4);
                
              WriteByte(DRP_ID[2],STX);
              WriteByte(DRP_ID[2],0x31);
              WriteByte(DRP_ID[2], sel);
              WriteByte(DRP_ID[2], ETX);
              WriteByte(DRP_ID[2], bcc_val );
              
              }
              #endif
1026          void Sent_Camera_IRD(U8 sel)
1027          {
1028   1        
1029   1      U8 loop;
1030   1      U8 temp=0;
1031   1      
1032   1      RS_tx(NAK);
1033   1      return;//ryan@20150908
1034   1      
1035   1      temp=(sel-0x41);
1036   1      temp=temp*4;
1037   1      SC16_Com[0]=STX;
1038   1      SC16_Com[1]=0x32;
1039   1      SC16_Com[2]=sel;
1040   1      SC16_Com[3]=Camera_IRDA[temp+3];
1041   1      SC16_Com[4]=Camera_IRDA[temp+2];
1042   1      SC16_Com[5]=Camera_IRDA[temp+1];
1043   1      SC16_Com[6]=Camera_IRDA[temp+0];
1044   1      SC16_Com[7]=ETX;
1045   1      SC16_Com[8]=BCC_Cal(SC16_Com, 8);
C51 COMPILER V9.50a   NED                                                                  02/18/2019 18:00:34 PAGE 18  

1046   1      
1047   1        for(loop=0;loop<=8;loop++)
1048   1        {
1049   2        RS_tx(SC16_Com[loop]);
1050   2        }
1051   1      
1052   1      }
1053          
1054          //----------------------------------------
1055          
1056          void Get_DVR_temp(void)
1057          {
1058   1      WriteByte(DRP_ID[0], STX);
1059   1      WriteByte(DRP_ID[0], 0x33);
1060   1      WriteByte(DRP_ID[0], 0x31);
1061   1      WriteByte(DRP_ID[0], ETX);
1062   1      WriteByte(DRP_ID[0], 0x03);
1063   1      }
1064          
1065          
1066          void Sent_DVR_temp(void)
1067          {
1068   1      U8 loop;
1069   1      
1070   1      SC16_Com[0]=STX;
1071   1      SC16_Com[1]=0x34;
1072   1      SC16_Com[2]=0x31;
1073   1      SC16_Com[3]=DVR_temp[1];
1074   1      SC16_Com[4]=DVR_temp[0];
1075   1      SC16_Com[5]=0x20;
1076   1      SC16_Com[6]=0x20;
1077   1      SC16_Com[7]=ETX;
1078   1      SC16_Com[8]=BCC_Cal(SC16_Com, 8);
1079   1      
1080   1        for(loop=0;loop<=8;loop++)
1081   1        {
1082   2        RS_tx(SC16_Com[loop]);
1083   2        }
1084   1      
1085   1      
1086   1      }
1087          
1088          #if 0
              void Get_DVR_ver(void)
              {
              WriteByte(DRP_ID[0], STX);
              WriteByte(DRP_ID[0], 0x33);
              WriteByte(DRP_ID[0], 0x4F);
              WriteByte(DRP_ID[0], ETX);
              WriteByte(DRP_ID[0], 0x7D);
              }
              void Sent_DVR_ver(void)
                {
              U8 loop;
              
              SC16_Com[0]=STX;
              SC16_Com[1]=0x34;
              SC16_Com[2]=0x4f;
              SC16_Com[3]=DVR_ver[2];
              SC16_Com[4]=DVR_ver[1];
              SC16_Com[5]=DVR_ver[0];
              SC16_Com[6]=0x20;
C51 COMPILER V9.50a   NED                                                                  02/18/2019 18:00:34 PAGE 19  

              SC16_Com[7]=ETX;
              SC16_Com[8]=BCC_Cal(SC16_Com, 8);
              
                for(loop=0;loop<=8;loop++)
                {
                RS_tx(SC16_Com[loop]);
                }
              
                }
              
              void Get_DVR_Year(void)
              {
              WriteByte(DRP_ID[0], STX);
              WriteByte(DRP_ID[0], 0x33);
              WriteByte(DRP_ID[0], 0x35);
              WriteByte(DRP_ID[0], ETX);
              WriteByte(DRP_ID[0], 0x07);
              }
              
              void Sent_DVR_Year(void)
              {
              U8 loop;
              
              SC16_Com[0]=STX;
              SC16_Com[1]=0x34;
              SC16_Com[2]=0x35;
              SC16_Com[3]=DVR_Y[3];
              SC16_Com[4]=DVR_Y[2];
              SC16_Com[5]=DVR_Y[1];
              SC16_Com[6]=DVR_Y[0];
              SC16_Com[7]=ETX;
              SC16_Com[8]=BCC_Cal(SC16_Com, 8);
              
                for(loop=0;loop<=8;loop++)
                {
                RS_tx(SC16_Com[loop]);
                }
              
              
              }
              
              void Get_DVR_MD(void)
                {
              WriteByte(DRP_ID[0], STX);
              WriteByte(DRP_ID[0], 0x33);
              WriteByte(DRP_ID[0], 0x36);
              WriteByte(DRP_ID[0], ETX);
              WriteByte(DRP_ID[0], 0x04);
              }
              void Sent_DVR_MDr(void)
                {}
              void Get_DVR_HS(void)
                {
              WriteByte(DRP_ID[0], STX);
              WriteByte(DRP_ID[0], 0x33);
              WriteByte(DRP_ID[0], 0x37);
              WriteByte(DRP_ID[0], ETX);
              WriteByte(DRP_ID[0], 0x05);
              }
              void Sent_DVR_HS(void){}
              #endif
1169          //-----------------------------------------
C51 COMPILER V9.50a   NED                                                                  02/18/2019 18:00:34 PAGE 20  

1170          
1171          void Set_Camera_speed(U8 val)
1172          {
1173   1        if(val)
1174   1          {
1175   2      WriteByte(DRP_ID[2], STX);
1176   2      WriteByte(DRP_ID[2], 0xFF);
1177   2      WriteByte(DRP_ID[2], 0x90);
1178   2      WriteByte(DRP_ID[2], ETX);
1179   2      WriteByte(DRP_ID[2], 0x6E);
1180   2          }
1181   1        else
1182   1          {
1183   2      WriteByte(DRP_ID[2], STX);
1184   2      WriteByte(DRP_ID[2], 0xFF);
1185   2      WriteByte(DRP_ID[2], 0x91);
1186   2      WriteByte(DRP_ID[2], ETX);
1187   2      WriteByte(DRP_ID[2], 0x6F);
1188   2          }
1189   1      
1190   1                #ifdef  camera_speed
                        printf("\r\n Set_Camera_speed=%x",(U16) val);
                        #endif  
1193   1      
1194   1      }
1195          
1196          
1197          //-----------------------------------------
1198          void GPIO_check(void)
1199          {
1200   1      U8 GPIO_state,IO_flag=0x10,count=0;
1201   1      
1202   1      GPIO_state=(DVR_GetIO()&0x3f);
1203   1      
1204   1      if(GPIO_current==GPIO_state)
1205   1        return;
1206   1      else  
1207   1      {
1208   2        IO_flag=GPIO_state;
1209   2        while((IO_flag&0x01)!=0)
1210   2        {
1211   3        IO_flag>>=1;
1212   3        count++;
1213   3        }
1214   2      }
1215   1        switch(count)
1216   1          {
1217   2      
1218   2          case 0:
1219   2              PCON = PCON&0x7f;       //  smod=0
1220   2                TH1 = SET_BAUDRATE(9600,0); // 22.118M HZ   //remask by ryan.
1221   2                break;
1222   2          case 1: PCON = PCON&0x7f;       //  smod=0
1223   2              TH1 = SET_BAUDRATE(19200,0);  // 22.118M HZ   //remask by ryan.
1224   2              break;
1225   2          case 2:
1226   2              PCON =PCON| 0x80;       //  smod=1
1227   2              TH1 = SET_BAUDRATE(38400,1);  // 22.118M HZ   //remask by ryan.
1228   2              break;
1229   2          case 3:
1230   2              PCON =PCON| 0x80;       //smod=1
1231   2              TH1 = SET_BAUDRATE(76800,1);  // 22.118M HZ   //remask by ryan.
C51 COMPILER V9.50a   NED                                                                  02/18/2019 18:00:34 PAGE 21  

1232   2              break;
1233   2          default:  PCON = PCON&0x7f;       //  smod=0
1234   2                TH1 = SET_BAUDRATE(9600,0); // 22.118M HZ   //remask by ryan.
1235   2                break;
1236   2          } 
1237   1      
1238   1      
1239   1            GPIO_current=GPIO_state;
1240   1      
1241   1            #ifdef  SC16IS750_DEBUG_PRINT 
                      printf("\r\n GPIO=%x",(U16)GPIO_state);
                    #endif   
1244   1            
1245   1      }
1246          
1247          //-----------------------------------------
1248          void Power_onoff(U8 sel)
1249          {
1250   1      
1251   1      Power_EN1=sel;
1252   1      Power_EN2=sel;
1253   1      Power_EN3=sel;
1254   1       Wait_ms(100);
1255   1      
1256   1      //P2_4=1;
1257   1      //P2_7=1;
1258   1      //printf("power on");
1259   1      }
1260          //-----------------------------------------
1261          
1262          U8 SC16_init(void)
1263          {
1264   1      
1265   1      U8 Dev_ID;
1266   1      
1267   1          SC16_RST=0;
1268   1              Wait_ms(20);
1269   1                  SC16_RST=1;
1270   1                Wait_ms(20);
1271   1      
1272   1        #if 1
1273   1          for(Dev_ID=0;Dev_ID<=2;Dev_ID++)
1274   1          {    
1275   2               ResetDevice(DRP_ID[Dev_ID]);
1276   2          SetBaudrate(DRP_ID[Dev_ID],BaudRate_sel);
1277   2              SetLine(DRP_ID[Dev_ID],8,0,1);
1278   2              WriteI2C(DRP_ID[Dev_ID],FCR , 0x01);   //FIFO mode
1279   2          }
1280   1      #endif
1281   1      
1282   1      #ifdef dvr_parity
                SetLine(DVR_address,8,2,1);  //DVR parity even
              #endif
1285   1      
1286   1        GPIOSetPortMode(DRP_ID[0],0);
1287   1        GPIOSetPortState(DRP_ID[0],0xff)  ;
1288   1      return 1;
1289   1      }
1290          //-----------------------------------------
1291          extern data user_timer[TIMER_NUM];//ryan@20151216
1292          
1293          U8 SC16_SendData(U8 val)
C51 COMPILER V9.50a   NED                                                                  02/18/2019 18:00:34 PAGE 22  

1294          {
1295   1      U8 error=0;
1296   1      //U8 Dev_ID=0,Data,Error=FALSE;
1297   1      
1298   1      #ifdef power_startup_check
              
                if((Com_flag==dvr_com_flag)&&(DVR_startup_flag==1))
                WriteByte(DRP_ID[0], val);  
                
                if((Com_flag==camera_com_flag)&&(Cam_startup_flag==1))
                WriteByte(DRP_ID[2], val);          
                
              #else
1307   1      
1308   1        #ifdef recoder_disable_AWB 
1309   1            if((SC16_Com[1]==0x31)&&(SC16_Com[2]==0x53)&&((SC16_Com[3]==0x31)||(SC16_Com[3]==0x32)))
1310   1            {
1311   2            WriteByte(DRP_ID[2], val);///PIC
1312   2            }
1313   1            else
1314   1            {
1315   2            WriteByte(DRP_ID[0], val);///DVR
1316   2            WriteByte(DRP_ID[2], val);///PIC
1317   2            }
1318   1      
1319   1        #else
                    WriteByte(DRP_ID[0], val);///DVR
                    WriteByte(DRP_ID[2], val);///PIC
                #endif
1323   1      
1324   1      
1325   1      #endif
1326   1      
1327   1      //ryan@20150814     WriteByte(DRP_ID[1], val);
1328   1      
1329   1      //WDTCR|=0x10;
1330   1      return 1;
1331   1      
1332   1      }
1333          //-----------------------------------------
1334          
1335          U8 SC16_SendDataSelect(U8 addr)
1336          {
1337   1      
1338   1      U8 loop=0,Error=0,count=0,data_temp=0;
1339   1      //U8 count2=0,start=0,end=0,loop_flag;
1340   1      U8 buff_flag=1,loop_temp=0;
1341   1      U8 error_flag=1;
1342   1      U8 etx_flag=0;///camera 
1343   1      //data_flag=0;
1344   1      
1345   1      //WDTCR|=0x10;
1346   1      #if 0
              
              while( (ReadI2C(DRP_ID[addr], LSR)&BIT0))
              {
              data_temp=ReadByte(DRP_ID[addr]);
              //SC16_Com[count]=data_temp;
              //count++;
              Error=TRUE;
              
               RS_tx(data_temp); 
C51 COMPILER V9.50a   NED                                                                  02/18/2019 18:00:34 PAGE 23  

              WriteByte(DRP_ID[addr+1],data_temp); 
              WriteByte(DRP_ID[addr+2],data_temp); 
              WDTCR|=0x10;
              }
              
              
              //if( (ReadI2C(DRP_ID[addr], LSR)&BIT1))
              
              //}
              #endif
1366   1      
1367   1      #if 1
1368   1      /*
1369   1        if( (ReadI2C(DRP_ID[addr], LSR)&BIT1))
1370   1        {
1371   1        WriteI2C(DRP_ID[addr],FCR,0x03);   //RXFIFO_reset 
1372   1        DELAY_FOR(50);
1373   1        WriteI2C(DRP_ID[addr],FCR,0x01);   //RXFIFO_reset 
1374   1        }
1375   1        else
1376   1          {
1377   1          */
1378   1            if( ReadI2C(DRP_ID[addr], LSR)&BIT0)
1379   1            {   
1380   2              count=ReadI2C(DRP_ID[addr], RXLVL);
1381   2              //data_flag=count;
1382   2              
1383   2                 if(count==0) return 0;
1384   2      
1385   2                #ifdef  SC16IS750_DEBUG_PRINT 
                        printf("\r\n SC16_ID=%x Data=",(U16) DRP_ID[addr]);
                        #endif  
1388   2      
1389   2                #ifdef  SC16IS750_DEBUG_PRINT 
                        printf("\r\n count=%x Data=",(U16) count);
                        #endif  
1392   2      
1393   2              #ifdef get_data_buff
1394   2      
1395   2              data_temp=ReadByte(DRP_ID[addr]);
1396   2      
1397   2              if((data_temp==NAK)||(data_temp==ACK))
1398   2              {       
1399   3                if((addr==6)&&(data_temp==NAK));
1400   3                else
1401   3                RS_tx(data_temp); 
1402   3                
1403   3                #if 0//ryan@20151106^C
                        WriteByte(DRP_ID[addr+1],data_temp); 
                        WriteByte(DRP_ID[addr+2],data_temp); 
                        #endif
1407   3      
1408   3                //if(data_temp==NAK) 
1409   3                  //printf("(N=%x)",(U16)addr); 
1410   3                
1411   3                #ifdef  SC16IS750_DEBUG_PRINT 
                        printf("sc16_data=%x ",(U16)data_temp);         
                        #endif          
1414   3              }
1415   2              else if(data_temp==CAM_MOV) return 1;//ryan@20150417
1416   2      //        else if((data_temp==STX)&&(count>=9))
1417   2              else if((data_temp==STX)&&(count>=5))
C51 COMPILER V9.50a   NED                                                                  02/18/2019 18:00:34 PAGE 24  

1418   2              {
1419   3      
1420   3              SC16_com_buff[0]=data_temp;
1421   3      
1422   3                loop=1;
1423   3                while((error_flag==1)&&(loop<=7))
1424   3                {
1425   4                  
1426   4                  
1427   4                SC16_com_buff[loop]=ReadByte(DRP_ID[addr]);
1428   4      
1429   4      
1430   4                  #if 1///ryan@20150605
1431   4                    if(SC16_com_buff[loop]==ETX&&((SC16_com_buff[1]>=0x52))&&(etx_flag==0)&&(loop<=3)) 
1432   4                    { 
1433   5                    etx_flag=1;
1434   5                    //loop++;
1435   5                    //SC16_com_buff[loop]=ReadByte(DRP_ID[addr]);
1436   5                    //error_flag=0;//end loop   //ryan@20150420
1437   5                    //printf("get first EXT");
1438   5                    }
1439   4                    else if(SC16_com_buff[loop]==ETX)
1440   4                      {
1441   5                      loop++;
1442   5                      SC16_com_buff[loop]=ReadByte(DRP_ID[addr]);
1443   5                      error_flag=0;///endi loop //ryan@20150420
1444   5                      //printf("get data");
1445   5                      }
1446   4                  #else
                          if(SC16_com_buff[loop]==ETX) 
                          { 
                          loop++;
                          SC16_com_buff[loop]=ReadByte(DRP_ID[addr]);
                          //buff_flag=0;
                          error_flag=0;//ryan@20150420
                          }
                          #endif
1455   4                  
1456   4                
1457   4                  
1458   4                loop++;
1459   4              
1460   4                }
1461   3      
1462   3                  //ryan
1463   3                  if((SC16_com_buff[1]==0xff)&&(SC16_com_buff[2]==0x92))
1464   3                  {
1465   4                  //Cam_boot_count_flag++;            
1466   4                  
1467   4                    Cam_boot_flag=1;
1468   4                    //printf("\r\nGot Camera ready");
1469   4                
1470   4                  //WriteByte(DRP_ID[2],0x02); //view com.
1471   4                  //WriteByte(DRP_ID[2],0x37); 
1472   4                  //WriteByte(DRP_ID[2],0x52); 
1473   4                  //WriteByte(DRP_ID[2],0x03); 
1474   4                  //WriteByte(DRP_ID[2],0x64); 
1475   4                  }
1476   3                  
1477   3                  loop_temp=loop-1;
1478   3      
1479   3                  if((loop_temp<=4)&&(error_flag==0))
C51 COMPILER V9.50a   NED                                                                  02/18/2019 18:00:34 PAGE 25  

1480   3                  {
1481   4                  
1482   4                  //printf("\r\nRecived a command from device1..");
1483   4                    for(loop=0;loop<=4;loop++)
1484   4                    {
1485   5                    //data_temp=ReadByte(DRP_ID[addr]);     
1486   5                    //SC16_Com[count]=ReadByte(DRP_ID[addr]);
1487   5                    RS_tx(SC16_com_buff[loop]); 
1488   5                    #if 0//ryan@20151106^C
                            WriteByte(DRP_ID[addr+1],SC16_com_buff[loop]); 
                            WriteByte(DRP_ID[addr+2],SC16_com_buff[loop]);        
                            #endif
1492   5                    }   
1493   4                      //}
1494   4                  return 1;//if buff are error...
1495   4                  }
1496   3                  else if((loop_temp<=6)&&(error_flag==0))///ryan@20150602
1497   3                    {
1498   4      
1499   4                    //printf("\r\nRecived a command from device2..");
1500   4                    
1501   4                    for(loop=0;loop<=6;loop++)
1502   4                    {
1503   5                    //data_temp=ReadByte(DRP_ID[addr]);     
1504   5                    //SC16_Com[count]=ReadByte(DRP_ID[addr]);
1505   5                    RS_tx(SC16_com_buff[loop]); 
1506   5                    #if 0//ryan@20151106^C
                            WriteByte(DRP_ID[addr+1],SC16_com_buff[loop]); 
                            WriteByte(DRP_ID[addr+2],SC16_com_buff[loop]);        
                            #endif
1510   5                    } 
1511   4                      return 1;//if buff are error...
1512   4                    }
1513   3                  
1514   3                //else if((SC16_ComCheck(&SC16_com_buff[0])==1)&&(loop>=8)&&(error_flag==0))
1515   3                  #if 1//ryan@20150602
1516   3                  else if((SC16_ComCheck(&SC16_com_buff[0])==1)&&(error_flag==0))
1517   3                  {
1518   4                  return 1;
1519   4                  }
1520   3                  #endif
1521   3                  else if(error_flag==0)
1522   3                  {
1523   4                  //bcc check
1524   4                  buff_flag=SC16_com_buff[0];
1525   4                    
1526   4                for(loop=1;loop<=7;loop++)
1527   4                    buff_flag^=SC16_com_buff[loop];
1528   4                
1529   4                  if(buff_flag==SC16_com_buff[8])
1530   4                  {
1531   5                //  printf("\r\nRecived a command from device3..");
1532   5                  
1533   5                    for(loop=0;loop<=loop_temp;loop++)
1534   5                    {
1535   6                    //data_temp=ReadByte(DRP_ID[addr]);     
1536   6                    //SC16_Com[count]=ReadByte(DRP_ID[addr]);
1537   6                    RS_tx(SC16_com_buff[loop]); 
1538   6                    #if 0//ryan220151106
                            WriteByte(DRP_ID[addr+1],SC16_com_buff[loop]); 
                            WriteByte(DRP_ID[addr+2],SC16_com_buff[loop]); 
                            #endif
C51 COMPILER V9.50a   NED                                                                  02/18/2019 18:00:34 PAGE 26  

1542   6                    #ifdef  SC16IS750_DEBUG_PRINT 
                            printf("%x ",(U16)SC16_com_buff[loop]);         
                            #endif    
1545   6                    user_timer[3]=200;
1546   6                    }
1547   5                  }
1548   4                  //else            
1549   4                  //printf("ECOM,");
1550   4                  
1551   4                  return 1;
1552   4                  }
1553   3                  else
1554   3                    return 1;
1555   3              }
1556   2              else
1557   2                {
1558   3              //if data isn't NAK or ACK of value that it should be send 1 byte to devices..
1559   3                  #if 0
                          RS_tx(data_temp); 
                          WriteByte(DRP_ID[addr+1],data_temp); 
                          WriteByte(DRP_ID[addr+2],data_temp); 
              
                      //for(loop=1;loop<=(count-1);loop++)
                          for(loop=1;loop<=4;loop++)
                          {
                          data_temp=ReadByte(DRP_ID[addr]);     
                          //SC16_Com[count]=ReadByte(DRP_ID[addr]);
                          RS_tx(data_temp); 
                          WriteByte(DRP_ID[addr+1],data_temp); 
                          WriteByte(DRP_ID[addr+2],data_temp); 
                      
                          #ifdef  SC16IS750_DEBUG_PRINT 
                          printf("%x ",(U16)SC16_com_buff[loop]);         
                          #endif        
                          }   
              
                          //EnUserTimer(USERTMID3,40);
                          user_timer[3]=200;
                          //printf("\r\n count=%x",(U16) count);
              
                          #endif
1583   3                }
1584   2      
1585   2              
1586   2              #else 
                      //printf("\r\nRecived a command from device4..");
                      for(loop=0;loop<=(count-1);loop++)
                      {
                      data_temp=ReadByte(DRP_ID[addr]);
                      
                      //SC16_Com[count]=ReadByte(DRP_ID[addr]);
                      RS_tx(data_temp); 
                      #if 0//ryan@20151106
                      WriteByte(DRP_ID[addr+1],data_temp); 
                      WriteByte(DRP_ID[addr+2],data_temp); 
                      #endif
                        #ifdef  SC16IS750_DEBUG_PRINT 
                        printf("%x ",(U16)SC16_Com[loop]);          
                        #endif  
                    
                      }
                      #endif
C51 COMPILER V9.50a   NED                                                                  02/18/2019 18:00:34 PAGE 27  

1604   2              
1605   2            //count++;
1606   2            //Error=TRUE;
1607   2                  
1608   2            }
1609   1      
1610   1        //}
1611   1      
1612   1      //for(loop=0;loop<=(count-1);loop++) RS_tx(SC16_Com[loop]); 
1613   1      //for(loop=0;loop<=(count-1);loop++) WriteByte(DRP_ID[addr+1],SC16_Com[loop]); 
1614   1      //for(loop=0;loop<=(count-1);loop++) WriteByte(DRP_ID[addr+2],SC16_Com[loop]); 
1615   1              
1616   1      #else
              
              /*
                if( (ReadI2C(DRP_ID[addr], LSR)&BIT1))
                {
                WriteI2C(DRP_ID[addr],FCR,0x03);   //RXFIFO_reset 
                DELAY_FOR(50);
                WriteI2C(DRP_ID[addr],FCR,0x01);   //RXFIFO_reset 
                }
                else
                  {
                  */
                    while( (ReadI2C(DRP_ID[addr], LSR)&BIT0)&&(count<=17))
                    {
                    //data_temp=ReadByte(DRP_ID[addr]);
                    SC16_Com[count]=ReadByte(DRP_ID[addr]);
                    count++;
                    Error=TRUE;
                    }
              
                //  }
              
              for(loop=0;loop<=(count-1);loop++) RS_tx(SC16_Com[loop]); 
              for(loop=0;loop<=(count-1);loop++) WriteByte(DRP_ID[addr+1],SC16_Com[loop]); 
              for(loop=0;loop<=(count-1);loop++) WriteByte(DRP_ID[addr+2],SC16_Com[loop]); 
              #endif
1642   1      
1643   1      
1644   1      return 0;
1645   1      
1646   1      }
1647          //----------------------------------------
1648          /*
1649          void Command_Check(U8 val)//ryan@20150417
1650          {
1651          
1652          
1653          }
1654          */
1655          //----------------------------------------
1656          void Repeat_PWM_Com(void)
1657          {
1658   1              WriteByte(PIC32_address,SC16_Com[0]); 
1659   1              WriteByte(PIC32_address,SC16_Com[1]); 
1660   1              WriteByte(PIC32_address,SC16_Com[2]); 
1661   1              WriteByte(PIC32_address,SC16_Com[3]); 
1662   1              WriteByte(PIC32_address,SC16_Com[4]); 
1663   1      
1664   1              //printf("SET_LED");
1665   1      }
C51 COMPILER V9.50a   NED                                                                  02/18/2019 18:00:34 PAGE 28  

1666          
1667          
1668          //-----------------------------------------
1669          U8 SC16_DataCheck(void)
1670          {
1671   1      
1672   1      U8 Dev_ID=0,Error=FALSE,count=0;
1673   1      
1674   1          #if 0
                        if( (ReadI2C(DRP_ID[0], LSR)&BIT0))
                          {
                             Data=ReadByte(DRP_ID[0]);
                        SC16_Com[SC16_ComAddr]=Data;
                        #ifdef  SC16IS750_DEBUG_PRINT 
                        printf("\r\nSC16_Com[%x]=%x",(U16)SC16_ComAddr,(U16)Data);
                        #endif   
              
                        SC16_ComAddr++; 
                        Error=TRUE;
                          }
                  //#elif 0
                    for(Dev_ID=0;Dev_ID<=8;Dev_ID+=3)
                    {
                        if( (ReadI2C(DRP_ID[Dev_ID], LSR)&BIT0))
                          {             
                            Data=ReadByte(DRP_ID[Dev_ID]);
                        WriteByte(DRP_ID[Dev_ID+1], Data);
                        WriteByte(DRP_ID[Dev_ID+2], Data);
                        RS_tx(Data);
                        //if(DRP_ID[Dev_ID]==DVR_address)
                          //   SC16_Com[SC16_ComAddr]=Data;           
                          
                        #ifdef  SC16IS750_DEBUG_PRINT 
                        printf("\r\nSC16_Com[%x]=%x",(U16)(SC16_ComAddr),(U16)Data);
                        #endif   
                        //SC16_ComAddr++;
                        Error=TRUE;       
                          }
                      
                      //Dev_ID+=2;
                      }
                    
                     #else
1709   1      
1710   1                // if( ReadI2C(DRP_ID[0], LSR)&BIT0)  SC16_SendDataSelect(0);
1711   1                // if( ReadI2C(DRP_ID[3], LSR)&BIT0)  SC16_SendDataSelect(3);
1712   1               //  if( ReadI2C(DRP_ID[6], LSR)&BIT0)  SC16_SendDataSelect(6);
1713   1      
1714   1                    #ifdef power_startup_check
                        
                            if(DVR_startup_flag==TRUE)
                              SC16_SendDataSelect(0);
                            else
                            check_startup(0);   
                  
                            if(Cam_startup_flag==TRUE)
                              SC16_SendDataSelect(6);
                            else
                            check_startup(6);   
                        
                            //  #else     
                          
C51 COMPILER V9.50a   NED                                                                  02/18/2019 18:00:34 PAGE 29  

                          #endif  
1729   1      
1730   1              if(work_flag==0)  
1731   1                {
1732   2                  SC16_SendDataSelect(0);
1733   2                   //printf("\r\nSC16_SendDataSelect(0);");
1734   2                   work_flag=1;
1735   2                }
1736   1              else if(work_flag==1)
1737   1                {
1738   2                    SC16_SendDataSelect(6);   
1739   2                  // printf("\r\nSC16_SendDataSelect(6);");
1740   2                work_flag=0;
1741   2                }
1742   1              //else if(work_flag==3)
1743   1              //  {
1744   1                // SC16_SendDataSelect(3);
1745   1                // work_flag=0;
1746   1                //}
1747   1      
1748   1            #endif
1749   1      return Error; 
1750   1      }
1751          //----------------------------------------
1752          
1753          void SC16_data_reset(U16 sel)
1754          {
1755   1      /*
1756   1      #define camera_press    BIT1
1757   1      #define _camera_ang   BIT2
1758   1      #define _camera_rang  BIT3
1759   1      #define _camera_IRD0    BIT4
1760   1      #define _camera_IRD1    BIT5
1761   1      #define _camera_IRD2    BIT6
1762   1      #define _camera_IRD3    BIT7
1763   1      #define _camera_IRD4    BIT8
1764   1      #define _camera_IRD5    BIT9
1765   1      #define _camera_IRD6    BIT10
1766   1      #define _dvr_temp       BIT11
1767   1      */
1768   1      if(SC16_busy_flag&sel) return;
1769   1      
1770   1        switch(sel)
1771   1        {
1772   2          case camera_temp:  Temp_check() ;break;     //0
1773   2          case camera_press:  Press_check() ;break; 
1774   2          case _camera_ang:  Get_Camera_Ang();break;
1775   2          case _camera_rang: Get_Camera_RAng();break; 
1776   2      #if 0//ryan@20151201
              case _camera_IRD0: break;//Get_Camera_IRD(0x41);break;  
                  case _camera_IRD1: break;//Get_Camera_IRD(0x42);break;  
                  case _camera_IRD2: break;//Get_Camera_IRD(0x43);break;  
                  case _camera_IRD3: break;//Get_Camera_IRD(0x44);break;  
                  case _camera_IRD4: break;//Get_Camera_IRD(0x45);break;    ///8
                  case _camera_IRD5: break;//Get_Camera_IRD(0x46);break;    ///9
                  case _camera_IRD6: break;//Get_Camera_IRD(0x47);break;    //10
              #endif
1785   2          case _dvr_temp: Get_DVR_temp();break;       //11
1786   2        case camera_version: Get_Camera_Ver();break;        //11  
1787   2          //case camera_version:    
1788   2          //if(SC16_busy_flag&sel) return;
1789   2          //        SC16_busy_flag|=sel;
C51 COMPILER V9.50a   NED                                                                  02/18/2019 18:00:34 PAGE 30  

1790   2          //      Get_Camera_Ver(); break;
1791   2      
1792   2        default: break;
1793   2        }
1794   1      
1795   1      //SC16_busy_flag=1;
1796   1      }
1797          //---------------------------------------
1798          U8 Camera_move_loop=1;
1799          extern U8 SC16_com_state;//ryan@20151216
1800          void Camera_move(void)
1801          {
1802   1      //static U8 work_flag;
1803   1      U8 mask[4]={0x01,0x02,0x10,0x20};
1804   1      U8 cam[4]={0x31,0x34,0x41,0x42};
1805   1      U8 BCC[4]={0x07,0x02,0x77,0x74};
1806   1      //U8 loop;
1807   1      #if 1//ryan@20151130
1808   1      
1809   1            if(Camera_move_loop==1)
1810   1            {
1811   2              if((Camera_flag&0x01)==0x01)
1812   2              {
1813   3              WriteByte(DRP_ID[2],0x02); 
1814   3              WriteByte(DRP_ID[2],0x37); 
1815   3              WriteByte(DRP_ID[2],0x31); 
1816   3              WriteByte(DRP_ID[2],0x03); 
1817   3              WriteByte(DRP_ID[2],0x07); 
1818   3              SC16_com_state=2;//rang. polling first//ryan@20151214
1819   3              } 
1820   2      
1821   2              if((Camera_flag&0x02)==0x02)
1822   2              {
1823   3              WriteByte(DRP_ID[2],0x02); 
1824   3              WriteByte(DRP_ID[2],0x37); 
1825   3              WriteByte(DRP_ID[2],0x34); 
1826   3              WriteByte(DRP_ID[2],0x03); 
1827   3              WriteByte(DRP_ID[2],0x02); 
1828   3              SC16_com_state=2;//rang. polling first//ryan@20151214
1829   3              } 
1830   2              Camera_move_loop=0;
1831   2            }
1832   1            else
1833   1            {
1834   2              if((Camera_flag&0x10)==0x10)
1835   2              {
1836   3              WriteByte(DRP_ID[2],0x02); 
1837   3              WriteByte(DRP_ID[2],0x37); 
1838   3              WriteByte(DRP_ID[2],0x41); 
1839   3              WriteByte(DRP_ID[2],0x03); 
1840   3              WriteByte(DRP_ID[2],0x77); 
1841   3                SC16_com_state=3;//rang. polling first//ryan@20151214
1842   3              } 
1843   2      
1844   2              if((Camera_flag&0x20)==0x20)
1845   2              {
1846   3              WriteByte(DRP_ID[2],0x02); 
1847   3              WriteByte(DRP_ID[2],0x37); 
1848   3              WriteByte(DRP_ID[2],0x42); 
1849   3              WriteByte(DRP_ID[2],0x03); 
1850   3              WriteByte(DRP_ID[2],0x74); 
1851   3                SC16_com_state=3;//rang. polling first//ryan@20151214
C51 COMPILER V9.50a   NED                                                                  02/18/2019 18:00:34 PAGE 31  

1852   3              } 
1853   2      
1854   2              Camera_move_loop=1;
1855   2            }
1856   1      #else
                  for(loop=0;loop<4;loop++)
                  {
                      if((Camera_flag&mask[loop])>=1)
                      {
                      WriteByte(DRP_ID[2],0x02); 
                      WriteByte(DRP_ID[2],0x37); 
                      WriteByte(DRP_ID[2],cam[loop]); 
                      WriteByte(DRP_ID[2],0x03); 
                      WriteByte(DRP_ID[2],BCC[loop]); 
                      } 
                  }
              #endif
1869   1          
1870   1      }
1871          
1872          //----------------------------------------
1873          #if 0
              void check_startup(U8 addr)
              {
              
              U8 loop=0,Error=FALSE,count=0,data_temp=0;
              
              
                    if( ReadI2C(DRP_ID[addr], LSR)&BIT0)
                    {   
                      count=ReadI2C(DRP_ID[addr], RXLVL);
                      
                         if((count==0)||(count<=5)) return;
                         
                        //#ifdef  SC16IS750_DEBUG_PRINT 
                        //printf("\r\n SC16_ID=%x Data=",(U16) DRP_ID[addr]);
                        //#endif  
                        //#ifdef  SC16IS750_DEBUG_PRINT 
                        //printf("\r\n count=%x Data=",(U16) count);
                        //#endif  
              
                      for(loop=0;loop<=(count-1);loop++)
                      {
                      data_temp=ReadByte(DRP_ID[addr]);
              
                        if(addr==0)
                        {
                           if(DVR_Com[loop]!=data_temp) return;
                           Error++;
                            if(Error>=5) DVR_startup_flag=1;
                            #ifdef  SC16IS750_DEBUG_PRINT 
                            printf("\r\nDVR_startup=OK");         
                            #endif 
                        }
                        else if(addr==6)
                        {
                           if(Cam_Com[loop]!=data_temp) return;
                           Error++;
                                if(Error>=5) Cam_startup_flag=1;
                            #ifdef  SC16IS750_DEBUG_PRINT 
                            printf("\r\nCamera_startup=OK");          
                            #endif              
C51 COMPILER V9.50a   NED                                                                  02/18/2019 18:00:34 PAGE 32  

                        }
              
                    
                      }
                          
                    }
              
              
              }
              #endif
1924          //-----------------------------------------
1925          //reset sc16 data
1926          //-----------------------------------------
1927          U8 SC16_ComCheck(U8 *addr)
1928          {
1929   1      
1930   1      //if(*addr!=0x02) return 0;
1931   1      U8 pos=0,temp=0;
1932   1      addr++;
1933   1       switch(*addr)
1934   1        {
1935   2          case 0x32: 
1936   2            addr++;
1937   2            if(*addr==0x34)
1938   2            {
1939   3            addr++;
1940   3            Camera_Ang[3]=*addr;
1941   3            addr++;           
1942   3            Camera_Ang[2]=*addr;
1943   3            addr++;                       
1944   3            Camera_Ang[1]=*addr;
1945   3            addr++;                       
1946   3            Camera_Ang[0]=*addr;      
1947   3            SC16_busy_flag&=~(_camera_ang);
1948   3                 return 1;
1949   3            }         
1950   2            else if(*addr==0x35)
1951   2              {
1952   3              addr++;
1953   3              Camera_RAng[3]=*addr;
1954   3              addr++;           
1955   3              Camera_RAng[2]=*addr;
1956   3              addr++;                       
1957   3              Camera_RAng[1]=*addr;
1958   3              addr++;                       
1959   3              Camera_RAng[0]=*addr;     
1960   3              SC16_busy_flag&=~(_camera_rang);
1961   3               return 1;
1962   3              }
1963   2            #if 0//ryan@20151106
                    else if((*addr>=0x41)&&(*addr<=0x47))
                      {
                      pos=*addr;
                      pos-=0x41;        
                      temp=pos*4;
                      addr++;
                      Camera_IRDA[temp+3]=*addr;
                      addr++;           
                      Camera_IRDA[temp+2]=*addr;
                      addr++;                       
                      Camera_IRDA[temp+1]=*addr;
                      addr++;                       
C51 COMPILER V9.50a   NED                                                                  02/18/2019 18:00:34 PAGE 33  

                      Camera_IRDA[temp+0]=*addr;      
                      SC16_busy_flag&=~(_camera_IRD0<<pos);
                       return 1;
                      }
                    #endif
1981   2              else  if(*addr==0x4f)
1982   2                  {
1983   3                  addr++;
1984   3                  Camera_ver0=*addr;
1985   3                  addr++;           
1986   3                  Camera_ver1=*addr;
1987   3                  addr++;                       
1988   3                  Camera_ver2=*addr;
1989   3                  SC16_busy_flag&=~(camera_version);
1990   3                    return 1;
1991   3                  } 
1992   2              
1993   2            
1994   2            break;
1995   2          case 0x34: 
1996   2                  addr++;
1997   2                  if(*addr==0x31)
1998   2                  {
1999   3                  addr++;
2000   3                  DVR_temp[1]=*addr;
2001   3                  addr++;           
2002   3                  DVR_temp[0]=*addr;
2003   3                  SC16_busy_flag&=~(_dvr_temp);
2004   3                  return 1;
2005   3                  }
2006   2                  break;
2007   2          
2008   2          //case camera_temp:  Temp_check() ;break;
2009   2          //case camera_press:  Press_check() ;break;     
2010   2          /*
2011   2          case 0x32: 
2012   2                  addr++;
2013   2                  if(*addr==0x4f)
2014   2                  {
2015   2                  addr++;
2016   2                  Camera_ver0=*addr;
2017   2                  addr++;           
2018   2                  Camera_ver1=*addr;
2019   2                  addr++;                       
2020   2                  Camera_ver2=*addr;
2021   2                  SC16_busy_flag&=~(camera_version);
2022   2                    return 1;
2023   2                  }               
2024   2                  break;
2025   2              */
2026   2          default:  //printf("\r\n not megawin com"); 
2027   2                  return 0;
2028   2                      break;
2029   2        }
2030   1        
2031   1      return 0;
2032   1        
2033   1        //if(SC16_ComAddr>=(num-1))
2034   1        //{   
2035   1        //  if((SC16_Com[0]==STX)&&(SC16_BCC_Check(&SC16_Com[0],(num-1))))
2036   1        //  {
2037   1        //    switch(SC16_Com[1])
C51 COMPILER V9.50a   NED                                                                  02/18/2019 18:00:34 PAGE 34  

2038   1        //      {
2039   1        //        case Monitor_Com:
2040   1        //                Monitor_set(SC16_Com[2]); 
2041   1        //                         break;
2042   1        //        case PWM_Com:
2043   1        //                PWM_set(SC16_Com[2]);
2044   1        //                         break;                    
2045   1        //        default:               break;
2046   1        //  
2047   1        //      }
2048   1        //    return TRUE;
2049   1        //  } 
2050   1            //}
2051   1      
2052   1                //#ifdef get_data_buff 
2053   1                //printf("\r\n Got data from the sc16");          
2054   1                //#endif 
2055   1         
2056   1           
2057   1      }
2058          
2059          //----------------------------------------
2060          
2061          U8 BCC_Cal(U8 *addr,U8 count)
2062          {
2063   1        U8 f_val=0;
2064   1        U8 s_val=0;
2065   1        U8 loop=0;
2066   1        count--;
2067   1      
2068   1      for(loop=0;loop<=count;loop++)
2069   1      {
2070   2        // f_val=*addr;  
2071   2         
2072   2         f_val^=*addr;  
2073   2        addr++;    
2074   2      }
2075   1      return f_val;
2076   1      
2077   1      /*
2078   1         f_val=*addr;  //XOR 0-3  //0
2079   1         addr++;            ///1
2080   1         //com[0]=*addr;   
2081   1         f_val^=*addr;    
2082   1         addr++;          ///2
2083   1         //com[1]=*addr;
2084   1         f_val^=*addr;    
2085   1         addr++;    ///3
2086   1         f_val^=*addr;
2087   1         //addr++;
2088   1      
2089   1      if(count==8)
2090   1        {
2091   1       addr++;    ///4
2092   1         f_val^=*addr;
2093   1       addr++;    ///5
2094   1         f_val^=*addr;
2095   1       addr++;    ///6
2096   1         f_val^=*addr;
2097   1       addr++;    ///7
2098   1         f_val^=*addr;
2099   1        
C51 COMPILER V9.50a   NED                                                                  02/18/2019 18:00:34 PAGE 35  

2100   1        }
2101   1      
2102   1         addr++;
2103   1      
2104   1      //if(f_val==*addr)
2105   1        return f_val;
2106   1      */
2107   1      }
2108          //----------------------------------------
2109          #if 0
              void Get_Data(U8 addr,U8 val)
              {
              
              switch(addr)
              {
              case 1: Send_Camera_Temp();  get_data_addr=0;break; ///1
              case 2: Send_Camera_Press();get_data_addr=0;  break;  ///2
              case 3: Sent_Camera_Ang(); get_data_addr=0;break; //camera angle.///3
              case 4:   Sent_Camera_RAng(); get_data_addr=0;break; //camera Rangle.///4
              case 5: Sent_Camera_IRD(val);get_data_addr=0;get_data_val=0;break;  //camera IRD.///5 
              case 6: Sent_DVR_temp();get_data_addr=0;break;  //DVR_tempe.///6
              case 7: Version_check();  get_data_addr=0;break;    ///megawin cpu version  ///7
              case 8: Camera_Version_check();  get_data_addr=0;break;   ///megawin cpu version  ///7
              }
              get_data_addr=0;
              get_data_val=0;
              }
              #endif
2128          //----------------------------------------
2129          extern U16 timerout4;
2130          extern U16 timerout3;
2131          extern U8  CB_flag;
2132          //#define get_delay 15-10
2133          #define get_delay 50
2134          U8 SC16_BCC_Check(U8 *addr )
2135          {
2136   1        U8 loop;
2137   1        U8 f_val=0;
2138   1        U8 s_val=0;
2139   1         U8  com[3]; 
2140   1      
2141   1      #ifdef BCC_noSTXEXT           
                 addr++;       //XOR 1-2
                 f_val=*addr;
                 com[0]=*addr;
                 addr++;
                 f_val^=*addr;
                 com[1]=*addr;
                 addr++;
              
              #else
2151   1         f_val=*addr;  //XOR 0-3  //0
2152   1         addr++;            ///1
2153   1         com[0]=*addr;   
2154   1         f_val^=*addr;    
2155   1         addr++;          ///2
2156   1         com[1]=*addr;
2157   1         f_val^=*addr;    
2158   1         addr++;    ///3
2159   1         com[2]=*addr;  
2160   1         f_val^=*addr;
2161   1         //addr++;
C51 COMPILER V9.50a   NED                                                                  02/18/2019 18:00:34 PAGE 36  

2162   1      
2163   1      if(Com_pos==6)//ryan@20150602
2164   1      {
2165   2       addr++;    ///4
2166   2         f_val^=*addr;
2167   2       addr++;    ///5
2168   2         f_val^=*addr;
2169   2      }else if(Com_pos==8)
2170   1        {
2171   2       addr++;    ///4
2172   2         f_val^=*addr;
2173   2       addr++;    ///5
2174   2         f_val^=*addr;
2175   2       addr++;    ///6
2176   2         f_val^=*addr;
2177   2       addr++;    ///7
2178   2         f_val^=*addr;
2179   2        
2180   2        }
2181   1         #endif
2182   1         addr++;
2183   1      
2184   1          
2185   1      
2186   1                        
2187   1          if(f_val==*addr)  
2188   1          {
2189   2             if((com[0]==0x37)&&((com[1]>=0x4a&&com[1]<=0x4f)||(com[1]==0x54)||(com[1]==0x55)))
2190   2            {
2191   3               RS_tx(STX);
2192   3               RS_tx(com[0]);
2193   3               RS_tx(com[1]);                
2194   3               RS_tx(ETX);
2195   3               RS_tx(f_val);  
2196   3      
2197   3              #if 1//ryan@20150706 feeback pip of data to camera
2198   3          
2199   3              if(Cam_boot_flag==1)  
2200   3              {
2201   4              WriteByte(PIC32_address,STX); 
2202   4              WriteByte(PIC32_address,com[0]); 
2203   4              WriteByte(PIC32_address,com[1]); 
2204   4              WriteByte(PIC32_address,ETX); 
2205   4              WriteByte(PIC32_address,f_val); 
2206   4              }
2207   3              
2208   3               #endif
2209   3            }   
2210   2             else if(com[0]==0x38&&com[1]>=0x3d&&com[1]<=0x60)
2211   2              {
2212   3               RS_tx(ACK);
2213   3              } 
2214   2             #if 1//ryan@20150814
2215   2                else if((com[0]==0x31)&&(com[1]==0x31)) 
2216   2                  {
2217   3                  Send_Camera_Temp();
2218   3                  //timerout3+=timerout4;
2219   3                  //CB_flag=1;  ///timerout3=get_delay;
2220   3                  //get_data_addr=1;/// Send_Camera_Temp();   ///1  
2221   3                  }
2222   2                else if(com[0]==0x31&&(com[1]==0x33)) 
2223   2                    {
C51 COMPILER V9.50a   NED                                                                  02/18/2019 18:00:34 PAGE 37  

2224   3                    Send_Camera_Press();
2225   3                    //timerout3+=timerout4;
2226   3                    //CB_flag=1;//timerout3=get_delay;
2227   3                    //get_data_addr=2; ///Send_Camera_Press();    ///2  
2228   3                  }
2229   2                else if(com[0]==0x31&&(com[1]==0x34))
2230   2                    {
2231   3                    Sent_Camera_Ang();
2232   3                    //timerout3+=timerout4;
2233   3                    //CB_flag=1;//timerout3=get_delay;
2234   3                    //get_data_addr=3;///  Sent_Camera_Ang(); //camera angle.///3 
2235   3                    }
2236   2                else if(com[0]==0x31&&(com[1]==0x35))
2237   2                    {
2238   3                    Sent_Camera_RAng();
2239   3                    //timerout3+=timerout4;
2240   3                    //CB_flag=1;//timerout3=get_delay;
2241   3                    //get_data_addr=4;  /// Sent_Camera_RAng();  //camera Rangle.///4
2242   3                    }
2243   2                #if 1//not check IRD
2244   2                else if(com[0]==0x31&&com[1]>=0x41&&com[1]<=0x47) 
2245   2                  {
2246   3                  Sent_Camera_IRD(0);
2247   3                  //timerout3+=timerout4;
2248   3                  //CB_flag=1;//timerout3=get_delay;
2249   3                  //get_data_addr=5;  ///Sent_Camera_IRD(com[1]);  //camera IRD.///5  
2250   3                  //get_data_val=com[1];
2251   3                  }
2252   2                #endif
2253   2                else if(com[0]==0x33&&(com[1]==0x31))
2254   2                    {
2255   3                    Sent_DVR_temp();
2256   3                    //timerout3+=timerout4;
2257   3                    //CB_flag=1;//timerout3=get_delay;
2258   3                    //get_data_addr=6;/// Sent_DVR_temp();  //DVR_tempe.///6
2259   3                  }
2260   2                else if(com[0]==0x31&&com[1]==0x50) 
2261   2                    {
2262   3                    Version_check();
2263   3                    //timerout3+=timerout4;
2264   3                    //CB_flag=1;//timerout3=get_delay;
2265   3                    //get_data_addr=7;//// Version_check();     ///megawin cpu version  ///7  
2266   3                    }
2267   2                else if(com[0]==0x31&&com[1]==0x4f) //Send_Camera_Ver();
2268   2                  {
2269   3                  Camera_Version_check();
2270   3                  //timerout3+=timerout4; 
2271   3                  //CB_flag=1;//timerout3=get_delay;
2272   3                  //get_data_addr=8;//// Version_check();     ///PIC cpu s/w version  ///8
2273   3                  }
2274   2             #else
                        else if((com[0]==0x31)&&(com[1]==0x31)) Send_Camera_Temp();   ///1          
                        else if(com[0]==0x31&&(com[1]==0x33))  Send_Camera_Press();   ///2
                        #if 1//ryan@20150804
                        else if(com[0]==0x31&&(com[1]==0x34))  Sent_Camera_Ang(); //camera angle.///3
                        else if(com[0]==0x31&&(com[1]==0x35))  Sent_Camera_RAng();  //camera Rangle.///4
                        else if(com[0]==0x31&&com[1]>=0x41&&com[1]<=0x47) Sent_Camera_IRD(com[1]);  //camera IRD.///5 
                        else if(com[0]==0x33&&(com[1]==0x31))  Sent_DVR_temp();  //DVR_tempe.///6
                        #endif
                        else if(com[0]==0x31&&com[1]==0x50)  Version_check();     ///megawin cpu version  ///7      
                        //else if(com[0]==0x31&&com[1]==0x4f) Send_Camera_Ver();
                      #endif
C51 COMPILER V9.50a   NED                                                                  02/18/2019 18:00:34 PAGE 38  

2286   2                      else 
2287   2                      {               
2288   3      
2289   3          
2290   3                        
2291   3                        #if 1//ryan@20150602
2292   3                        ///check all of command
2293   3                        if(Check_other_Com())
2294   3                        {
2295   4                        
2296   4                        for(loop=0;loop<=Com_pos;loop++)      
2297   4                        SC16_SendData(SC16_Com[loop]); 
2298   4      
2299   4                        user_timer[5]=4;//ryan@20151130
2300   4                        user_timer[3]=(20);//reset polling time..
2301   4                        
2302   4                        //printf("\r\n Sent COM to Camera");//ryan@20150908
2303   4                        #ifdef power_startup_check
                                if((Com_flag==dvr_com_flag)&&(DVR_startup_flag==0))
                                RS_tx(NAK);
              
                                if((Com_flag==camera_com_flag)&&(Cam_startup_flag==0))
                                RS_tx(NAK);
                                #endif
2310   4                        
2311   4                        }
2312   3                        else
2313   3                          {
2314   4                          RS_tx(NAK);
2315   4                          #ifdef  SC16IS750_DEBUG_PRINT 
                                  printf("\r\nCommand_Check fail");
                                    #endif        
2318   4          
2319   4                          }
2320   3                        #endif
2321   3                        
2322   3                      return FALSE;
2323   3                      }
2324   2                    
2325   2            #ifdef  SC16IS750_DEBUG_PRINT 
                    printf("\r\nSC16_BCC_Check pass");
                      #endif
2328   2            return TRUE;
2329   2                  
2330   2          }
2331   1          else
2332   1          {
2333   2            RS_tx(NAK);
2334   2            #ifdef  SC16IS750_DEBUG_PRINT 
                    printf("\r\nSC16_BCC_Check fail");
                      #endif        
2337   2                return FALSE;
2338   2          }
2339   1      
2340   1          
2341   1          
2342   1      }
2343          
2344          //-----------------------------------------
2345          
2346          U8 Check_other_Com(void)
2347          {
C51 COMPILER V9.50a   NED                                                                  02/18/2019 18:00:34 PAGE 39  

2348   1      
2349   1      if((SC16_Com[1]==0xff)){ //ryan@20150415
2350   2        Com_flag=camera_com_flag;  
2351   2        return TRUE;
2352   2      }
2353   1      
2354   1      //02,37,53,03,65, Camera Stop cammand..
2355   1      
2356   1      if((SC16_Com[1]==0x37)&&((SC16_Com[2]==0x31)||(SC16_Com[2]==0x34)||(SC16_Com[2]==0x53))){
2357   2      
2358   2          if(SC16_Com[2]==0x31) //ryan@20150416
2359   2            {
2360   3            Camera_flag=((Camera_flag&0x30)|0x01);//set/clear  up move
2361   3            RS_tx(ACK);
2362   3            }
2363   2          else if(SC16_Com[2]==0x34)
2364   2            {
2365   3            Camera_flag=((Camera_flag&0x30)|0x02);//set/clear down move
2366   3            RS_tx(ACK);     
2367   3            }
2368   2          else
2369   2            Camera_flag=0x00; //clear all move
2370   2      
2371   2          
2372   2        Com_flag=camera_com_flag;  
2373   2        return TRUE;
2374   2      }
2375   1      
2376   1      if((SC16_Com[1]==0x37)&&(SC16_Com[2]>=0x41)&&(SC16_Com[2]<=0x47)) {
2377   2      
2378   2          if(SC16_Com[2]==0x41)//ryan@20150416
2379   2            {
2380   3            Camera_flag=((Camera_flag&0x03)|0x10);//set/clear CCW move
2381   3            RS_tx(ACK);
2382   3            }
2383   2          else if(SC16_Com[2]==0x42)
2384   2            {
2385   3            Camera_flag=((Camera_flag&0x03)|0x20);//set/clear CW move
2386   3            RS_tx(ACK);
2387   3            }
2388   2      
2389   2            
2390   2        Com_flag=camera_com_flag;  
2391   2        return TRUE;
2392   2      }
2393   1      
2394   1      if((SC16_Com[1]==0x31)&&(SC16_Com[2]>=0x57&&SC16_Com[2]<=0x5c))
2395   1            {
2396   2            RS_tx(ACK);
2397   2            Set_Video((SC16_Com[2]-0x57),SC16_Com[3]);//for TW2835 video set
2398   2            return TRUE;
2399   2            }
2400   1      
2401   1      
2402   1      
2403   1      return TRUE;//ryan@21050602
2404   1      
2405   1      if((SC16_Com[1]==0x37)&&(SC16_Com[2]>=0x50)&&(SC16_Com[2]<=0x52)) {
2406   2        Com_flag=dvr_com_flag;  
2407   2        return TRUE;
2408   2      }
2409   1      
C51 COMPILER V9.50a   NED                                                                  02/18/2019 18:00:34 PAGE 40  

2410   1      if((SC16_Com[1]==0x38)&&(SC16_Com[2]>=0x31)&&(SC16_Com[2]<=0x3c)) {
2411   2        Com_flag=camera_com_flag;  
2412   2        return TRUE;
2413   2      }
2414   1      
2415   1      if((SC16_Com[1]==0x31)&&((SC16_Com[2]==0x34)||(SC16_Com[2]==0x35))){
2416   2        Com_flag=camera_com_flag;  
2417   2        return TRUE;
2418   2      }
2419   1      
2420   1      if((SC16_Com[1]==0x31)&&(SC16_Com[2]>=0x41)&&(SC16_Com[2]<=0x47))  {
2421   2        Com_flag=camera_com_flag;   
2422   2        return TRUE;
2423   2      }
2424   1      if((SC16_Com[1]==0x31)&&(SC16_Com[2]>=0x4f)&&(SC16_Com[2]<=0x53)) {
2425   2        Com_flag=camera_com_flag;     
2426   2        return TRUE;
2427   2      }
2428   1      
2429   1      
2430   1      if((SC16_Com[1]==0x33)&&((SC16_Com[2]==0x31)||(SC16_Com[2]==0x4f))) {
2431   2        Com_flag=dvr_com_flag;      
2432   2        return TRUE;
2433   2      }
2434   1      
2435   1      if((SC16_Com[1]==0x33)&&(SC16_Com[2]>=0x35)&&(SC16_Com[2]<=0x37)) {
2436   2        Com_flag=dvr_com_flag;      
2437   2        return TRUE;
2438   2      }
2439   1      
2440   1      #if 1//ryan@20151210
2441   1      if((SC16_Com[1]==0x33)&&(SC16_Com[2]>=0x51)&&(SC16_Com[2]<=0x5b)){
2442   2        Com_flag=dvr_com_flag;      
2443   2        return TRUE;
2444   2      }
2445   1      
2446   1      if((SC16_Com[1]==0x33)&&((SC16_Com[2]>=0x5c)||(SC16_Com[2]==0x61))){
2447   2        Com_flag=camera_com_flag;     
2448   2        return TRUE;
2449   2      }
2450   1      
2451   1      #else
              if((SC16_Com[1]==0x33)&&(SC16_Com[2]>=0x51)&&(SC16_Com[2]<=0x53)){
                Com_flag=dvr_com_flag;      
                return TRUE;
              }
              
              if((SC16_Com[1]==0x33)&&((SC16_Com[2]==0x5c)||(SC16_Com[2]==0x5d))){
                Com_flag=camera_com_flag;     
                return TRUE;
              }
              #endif
2462   1      //if((SC16_Com[1]==0x32)&&((SC16_Com[2]==0x31)||(SC16_Com[2]==0x4f))) {
2463   1      //  Com_flag=dvr_com_flag;      
2464   1      //  return TRUE;
2465   1      //}
2466   1      //if((SC16_Com[1]==0x32)&&(SC16_Com[2]>=0x33)&&(SC16_Com[2]<=0x35)) return TRUE;
2467   1      //if((SC16_Com[1]==0x32)&&(SC16_Com[2]>=0x41)&&(SC16_Com[2]<=0x47)) return TRUE;
2468   1      
2469   1      
2470   1      if((SC16_Com[1]==0x37)&&(SC16_Com[2]>=0x50)&&(SC16_Com[2]<=0x52)){
2471   2        Com_flag=dvr_com_flag;      
C51 COMPILER V9.50a   NED                                                                  02/18/2019 18:00:34 PAGE 41  

2472   2        return TRUE;
2473   2      }
2474   1      
2475   1      
2476   1      return FALSE;
2477   1      
2478   1      }
2479          
2480          //----------------------------------------
2481          #if 0
              U8 parity(U8 ino)
              {
                U8 noofones = 0;
              //  unsigned long mask = 0x00000001ul; /* start at first bit */
              
                U8 mask = 0x01; /* start at first bit */
              
                while(mask != 0) /* until all bits tested */
                {
                  if(mask & ino) /* if bit is 1, increment noofones */
                  {
                    noofones++;
                  }
                  mask = mask << 1; /* go to next bit */
                }
              
                /* if noofones is odd, least significant bit will be 1 */
                return (noofones & 1); 
              
              
              }
              #endif
2504          //-----------------------------------------
2505          //U8 Com_check(U8 com,U8 start, U8 count)
2506          //{
2507            
2508          
2509          //}
2510          
2511          //-----------------------------------------
2512          #if 0
              U8 ADT75_init(void)
              {
              
              U8 Ctemp=0;
              U16 Dtemp=0;
              
              //ADT75_SetCon(0x55);
              //Dtemp=ADT75_GetTemp();
              //Ctemp=ADT75_GetCon();
              ADT75_SetThyst(0x4420);
              ADT75_SetTOs(0x5220);
              ADT75_SetCon(0x02);
              
              
              #ifdef  ADT75_Debug
              Printf("GetThyst=%X",(U16)ADT75_GetThyst());
              Printf(" GetTOs=%X  ",(U16)ADT75_GetTOs());
              Printf(" GetCon=%X  ",(U16)ADT75_GetCon());
                  Printf("GetTemp=%X degree\r\n",(U16)((ADT75_GetTemp()>>4)/16));
               //   Printf("ADT75_GetCon=%X\r\n", ADT75_GetCon());
              #endif   
C51 COMPILER V9.50a   NED                                                                  02/18/2019 18:00:34 PAGE 42  

              
              
              return 1;
              
              }
              #endif
2540          //-----------------------------------------
2541          
2542          void ResetDevice(U8 addr)
2543          {
2544   1       register   U8 temp;
2545   1          temp = ReadI2C(addr, IOContro);
2546   1          temp |= 0x08;
2547   1           WriteI2C(addr, IOContro, temp);
2548   1            
2549   1      //    WriteRegister(SC16IS750_REG_IOCONTROL, temp_iocontrol);   
2550   1      //    temp_iocontrol = ReadRegister(SC16IS750_REG_IOCONTROL);
2551   1      //    temp_iocontrol |= 0x08;
2552   1      //    WriteRegister(SC16IS750_REG_IOCONTROL, temp_iocontrol); 
2553   1          
2554   1        //  return; 
2555   1      }
2556          //-----------------------------------------
2557          U16 SetBaudrate(U8 addr, U32 baudrate) //return error of baudrate parts per thousand
2558          {
2559   1      
2560   1      //register   U16 divisor;
2561   1       U32 divisor;
2562   1      
2563   1       U8 prescaler;
2564   1       U8 temp_lcr;//,temp_mcr;
2565   1         
2566   1         // uint32_t actual_baudrate;
2567   1         //  int16_t error;
2568   1          //uint16_t divisor;
2569   1         // uint8_t prescaler;
2570   1         // uint32_t actual_baudrate;
2571   1        //  int16_t error;
2572   1         // uint8_t temp_lcr;
2573   1      
2574   1          if ( (ReadI2C(addr,MCR)&0x80) == 0) { //if prescaler==1
2575   2              prescaler = 1;
2576   2          } else {
2577   2              prescaler = 4;
2578   2          }
2579   1      
2580   1        //baudrate=9600;
2581   1      
2582   1         divisor = (SC16IS750_CRYSTCAL_FREQ/prescaler)/(baudrate*16);
2583   1      
2584   1      
2585   1      
2586   1      #ifdef SC16IS750_DEBUG_PRINT
              Printf("\r\n");
              Printf("SetBaudrate_Dev_addr=%x\r\n",(U16) addr);
              Printf("SetBaudrate_MCR=%x\r\n",(U16) ReadI2C(addr,MCR));
              Printf("SetBaudrate_prescaler=%x\r\n",(U16) prescaler);
              Printf("SetBaudrate_divisor=%x\r\n",(U16) divisor);
              #endif 
2593   1          
2594   1        WriteI2C(addr, LCR, 0x00); /// WriteRegister(SC16IS750_REG_LCR,temp_lcr); 
2595   1      
C51 COMPILER V9.50a   NED                                                                  02/18/2019 18:00:34 PAGE 43  

2596   1          temp_lcr = ReadI2C(addr,LCR); ///ReadRegister(SC16IS750_REG_LCR);
2597   1            
2598   1          temp_lcr |= 0x80;
2599   1        
2600   1          WriteI2C(addr, LCR, temp_lcr); /// WriteRegister(SC16IS750_REG_LCR,temp_lcr); 
2601   1          //write to DLL
2602   1           WriteI2C(addr, DLL, (U8)divisor); ///WriteRegister(SC16IS750_REG_DLL,(uint8_t)divisor);
2603   1          //write to DLH
2604   1            WriteI2C(addr, DLH, (U8)(divisor>>8)); /// WriteRegister(SC16IS750_REG_DLH,(uint8_t)(divisor>>8));
2605   1      
2606   1      #ifdef SC16IS750_DEBUG_PRINT
              Printf("SetBaudrate_DLL=%x\r\n",(U16) ReadI2C(addr,DLL));
              Printf("SetBaudrate_DLH=%x\r\n",(U16) ReadI2C(addr,DLH));
              #endif 
2610   1      
2611   1          temp_lcr &= 0x7F;
2612   1         WriteI2C(addr, LCR, temp_lcr); ///WriteRegister(SC16IS750_REG_LCR,temp_lcr); 
2613   1      
2614   1      return 1;
2615   1         /* 
2616   1          actual_baudrate = (SC16IS750_CRYSTCAL_FREQ/prescaler)/(16*divisor);
2617   1          error = ((float)actual_baudrate-baudrate)*1000/baudrate;
2618   1      #ifdef  SC16IS750_DEBUG_PRINT   
2619   1          Serial.print("Desired baudrate: ");
2620   1          Serial.println(baudrate,DEC);
2621   1          Serial.print("Calculated divisor: ");
2622   1          Serial.println(divisor,DEC);
2623   1          Serial.print("Actual baudrate: ");
2624   1          Serial.println(actual_baudrate,DEC);    
2625   1          Serial.print("Baudrate error: ");
2626   1          Serial.println(error,DEC);    
2627   1      #endif     
2628   1          
2629   1          return error;
2630   1       */
2631   1      }
2632          //-----------------------------------------
2633          void SetLine(U8 addr, U8 data_length, U8  parity_select, U8  stop_length )
2634          {
2635   1          U8 temp_lcr;
2636   1          temp_lcr = ReadI2C(addr,LCR); ///ReadRegister(SC16IS750_REG_LCR);
2637   1          temp_lcr &= 0xC0; //Clear the lower six bit of LCR (LCR[0] to LCR[5]
2638   1      //#ifdef  SC16IS750_DEBUG_PRINT 
2639   1      //    Serial.print("LCR Register:0x");
2640   1      //    Serial.println(temp_lcr,DEC);
2641   1      //#endif   
2642   1          switch (data_length) {            //data length settings
2643   2              case 5:
2644   2                  break;
2645   2              case 6:
2646   2                  temp_lcr |= 0x01;
2647   2                  break;
2648   2              case 7:
2649   2                  temp_lcr |= 0x02;
2650   2                  break;
2651   2              case 8:
2652   2                  temp_lcr |= 0x03;
2653   2                  break;
2654   2              default:
2655   2                  temp_lcr |= 0x03;
2656   2                  break;
2657   2          }
C51 COMPILER V9.50a   NED                                                                  02/18/2019 18:00:34 PAGE 44  

2658   1      
2659   1          if ( stop_length == 2 ) {
2660   2              temp_lcr |= 0x04;
2661   2          }
2662   1          
2663   1          switch (parity_select) {            //parity selection length settings
2664   2              case 0:                         //no parity
2665   2                   break;
2666   2              case 1:                         //odd parity
2667   2                  temp_lcr |= 0x08;
2668   2                  break;
2669   2              case 2:                         //even parity
2670   2                  temp_lcr |= 0x18;
2671   2                  break;
2672   2              case 3:                         //force '1' parity
2673   2                  temp_lcr |= 0x03;
2674   2                  break;
2675   2              case 4:                         //force '0' parity
2676   2                  break;
2677   2              default:
2678   2                  break;
2679   2          } 
2680   1          
2681   1          WriteI2C(addr, LCR, temp_lcr);/// WriteRegister(SC16IS750_REG_LCR,temp_lcr);
2682   1      }
2683          //-----------------------------------------
2684          /*
2685          void GPIOSetPinMode(U8 addr,U8 pin_number, U8 i_o)
2686          {
2687              U8 temp_iodir;
2688              
2689              temp_iodir = ReadI2C(addr,IODir); ///ReadRegister(SC16IS750_REG_IODIR);
2690              if ( i_o == OUTPUT ) {
2691                temp_iodir |= (0x01 << pin_number);
2692              } else {
2693                temp_iodir &= (U8)~(0x01 << pin_number);
2694              } 
2695              
2696              WriteI2C(addr, IODir, temp_iodir);///WriteRegister(SC16IS750_REG_IODIR, temp_iodir);
2697              //return;
2698          }
2699          
2700          void GPIOSetPinState(U8 addr,U8 pin_number, U8 pin_state)
2701          {
2702              U8 temp_iostate;
2703              
2704              temp_iostate =  ReadI2C(addr,IOState);///ReadRegister(SC16IS750_REG_IOSTATE);
2705              if ( pin_state == 1 ) {
2706                temp_iostate |= (0x01 << pin_number);
2707              } else {
2708                temp_iostate &= (U8)~(0x01 << pin_number);
2709              } 
2710              
2711              WriteI2C(addr, IODir, IOState);///WriteRegister(SC16IS750_REG_IOSTATE, temp_iostate);
2712            //  return;
2713          }
2714          
2715          U8 GPIOGetPinState(U8 addr,U8 pin_number)
2716          {
2717               uint8_t temp_iostate;
2718              
2719              temp_iostate = ReadI2C(addr,IOState);///ReadRegister(SC16IS750_REG_IOSTATE);
C51 COMPILER V9.50a   NED                                                                  02/18/2019 18:00:34 PAGE 45  

2720              if ( temp_iostate & (0x01 << pin_number)== 0 ) {
2721                return 0;
2722              } 
2723              return 1;
2724             // return;
2725          }
2726          
2727          */
2728          //-----------------------------------------
2729          void GPIOSetPortMode(U8 addr,U8 port_io)
2730          {
2731   1      
2732   1       WriteI2C(addr, IODir, port_io); ///WriteRegister(SC16IS750_REG_IODIR, port_io);
2733   1        //  return;
2734   1      
2735   1      }
2736          //-----------------------------------------
2737          void GPIOSetPortState(U8 addr,U8 port_state)
2738          {
2739   1       WriteI2C(addr, IOState, port_state); /// WriteRegister(SC16IS750_REG_IOSTATE, port_state);
2740   1      }
2741          //-----------------------------------------
2742          U8 GPIOGetPortState(U8 addr)
2743          {
2744   1      //#ifdef  SC16IS750_DEBUG_PRINT 
2745   1       //   printf("\r\n**Addr=%X PortState=%X\r\n",(U16)addr,(U16) ReadI2C(addr,IOState));
2746   1          //Serial.println(ReadRegister(SC16IS750_REG_RXLVL), DEC);
2747   1      //#endif    
2748   1          return  ReadI2C(addr,IOState);////ReadRegister(SC16IS750_REG_IOSTATE);
2749   1      
2750   1      }
2751          //-----------------------------------------
2752          #if 0
              U8 FIFOAvailableData(U8 addr)
              {
              #ifdef  SC16IS750_DEBUG_PRINT 
                  printf("\r\n**Available data=%X",(U16)ReadI2C(addr,RXLVL));
                  //Serial.println(ReadRegister(SC16IS750_REG_RXLVL), DEC);
              #endif      
                 return ReadI2C(addr,RXLVL);///ReadRegister(SC16IS750_REG_RXLVL);
              }
              //-----------------------------------------
              U8 FIFOAvailableSpace(U8 addr)
              {
              
              #ifdef  SC16IS750_DEBUG_PRINT 
                  printf("\r\n**Available Space=%X",ReadI2C(addr,TXLVL));
                  //Serial.println(ReadRegister(SC16IS750_REG_RXLVL), DEC);
              #endif   
                 return ReadI2C(addr,TXLVL);///ReadRegister(SC16IS750_REG_TXLVL);
              
              }
              
              //-----------------------------------------
              
              void EnableTransmit(U8 addr,U8 OnOff)
              {
                  U8 temp_efcr;
                  temp_efcr = ReadI2C(addr,EFCR);///ReadRegister(SC16IS750_REG_EFCR);
                  if ( OnOff == 0) {
                      temp_efcr |= 0x04;       
                  } else {   
C51 COMPILER V9.50a   NED                                                                  02/18/2019 18:00:34 PAGE 46  

                      temp_efcr &= 0xFB;
                  }   
                  WriteI2C(addr, EFCR, temp_efcr); ///WriteRegister(SC16IS750_REG_EFCR,temp_efcr);
                  
                  //return;
              }
              #endif
2789          //-----------------------------------------
2790          #if 0
              void flush(U8 addr)  //Transmit Holding Register Empty indicator.
              {
                U8 tmp_lsr;
                
                do {
                           #ifdef  SC16IS750_DEBUG_PRINT 
                           printf("\r\n**THR is busy..=%X",addr);
                          //Serial.println(ReadRegister(SC16IS750_REG_RXLVL), DEC);
                          #endif
                  tmp_lsr = ReadI2C(addr,LSR);///ReadRegister(SC16IS750_REG_LSR);
                  
                } while ((tmp_lsr&0x20) ==0);
              
              
              }
              #endif
2807          //---------------------------------------------------------
2808          #if 0
              U8 ping(U8 addr)
              {
              
                WriteI2C(addr, SPR, 0x55);///WriteRegister(SC16IS750_REG_SPR,0x55);
                ///if (ReadRegister(SC16IS750_REG_SPR) !=0x55) {
              if (ReadI2C(addr,SPR) !=0x55) {
                           #ifdef  SC16IS750_DEBUG_PRINT 
                           printf("*ping is fail(0x55)=%X\r\n",(U16)addr);
                           #endif
                  return 0;
                }
              
                WriteI2C(addr, SPR, 0xAA);///WriteRegister(SC16IS750_REG_SPR,0xAA);
                //if (ReadRegister(SC16IS750_REG_SPR) !=0xAA) {
                    if (ReadI2C(addr,SPR)!=0xAA) {
                          #ifdef  SC16IS750_DEBUG_PRINT 
                          printf("*ping is fail(0xAA)=%X\r\n",(U16)addr);
                           #endif
                  return 0;
                }
              
                          #ifdef  SC16IS750_DEBUG_PRINT 
                           printf("*ping is pass, Address=%X\r\n",(U16)addr);
                           #endif
                          
                return 1;
              
              }
              #endif
2838          //-----------------------------------------
2839          
2840          //-----------------------------------------
2841          
2842          void WriteByte(U8 addr, U8 val)
2843          {
C51 COMPILER V9.50a   NED                                                                  02/18/2019 18:00:34 PAGE 47  

2844   1      
2845   1       /*  
2846   1        U8 tmp_lsr;
2847   1        while ( FIFOAvailableSpace() == 0 ){
2848   1      #ifdef  SC16IS750_DEBUG_PRINT 
2849   1          Serial.println("No available space");
2850   1      #endif    
2851   1        
2852   1        };
2853   1      
2854   1      #ifdef  SC16IS750_DEBUG_PRINT 
2855   1          Serial.println("++++++++++++Data sent");
2856   1      #endif          
2857   1          WriteRegister(SC16IS750_REG_THR,val);
2858   1      */
2859   1      
2860   1      //  do { 
2861   1      //    tmp_lsr = ReadI2C(addr,LSR);///ReadRegister(SC16IS750_REG_LSR);
2862   1      //  } while ((tmp_lsr&0x20) ==0);
2863   1      
2864   1        
2865   1        WriteI2C(addr, THR, val);///WriteRegister(SC16IS750_REG_THR,val);
2866   1        
2867   1      
2868   1          
2869   1      }
2870          
2871          U8 ReadByte(U8 addr)
2872          {
2873   1      //  volatile U8 val;
2874   1        U8 val;
2875   1        #if 1
2876   1        val = ReadI2C(addr,RHR);///ReadRegister(SC16IS750_REG_RHR);    
2877   1          return val;
2878   1        #else
                if (FIFOAvailableData(addr) == 0)
                {
              
              #ifdef  SC16IS750_DEBUG_PRINT 
              printf("\r\n**No data available");
              #endif          
                  //return -1;
                  return '\0';
                } 
                else 
                {
                  
                  #ifdef  SC16IS750_DEBUG_PRINT 
                  printf("\r\n** available ID=%x ,Data=%x",(U16)addr, (U16) ReadI2C(addr,RXLVL));
                  #endif   
              
                  val = ReadI2C(addr,RHR);///ReadRegister(SC16IS750_REG_RHR);    
                  return val;
              
                }
              
                #endif
2901   1        
2902   1      
2903   1      }
2904          #if 0
              void TW2835_get(U8 page)
C51 COMPILER V9.50a   NED                                                                  02/18/2019 18:00:34 PAGE 48  

              {
              U8 x,loop=0,step=0;
              U16 val=0;
              
              
              step=0;
              val=0;
              
              /*
              for(x=0;x<=2;x++)
              {
              val=(TW28_ReadByte(page,0x8c+step)+(((TW28_ReadByte(page,0x8f+step)&BIT2&BIT3)<<6)));
              printf("\r\n Vin=%x,HDELAY_PB=%x",(U16) x ,(U16)val);
              step+=0x10;
              val=0;
              }
              
              */
              /*
              step=0;
              val=0;
              for(x=0;x<=2;x++)
              {
              val=(TW28_ReadByte(page,0x02+step)+(((TW28_ReadByte(page,0x06+step)&BIT0&BIT1)<<8)));
              printf("\r\n Vin=%x,HDELAY_XY=%x",(U16) x ,(U16)val);
              step+=0x10;
              val=0;
              }
              */
              
              
              step=0;
              val=0;
              for(x=0;x<=2;x++)
              {
              //TW28_WriteByte(page,0x24,0);
              val=(TW28_ReadByte(page,0x04+step)+(((TW28_ReadByte(page,0x06+step)&BIT4)<<4)));
              printf("\r\n Vin=%x,VDELAY_XY=%x",(U16) x ,(U16)val);
              step+=0x10;
              val=0;
              }
              TW28_WriteByte(1,0x74,10);
              printf("\r\n OSD start=%x",(U16)TW28_ReadByte(1,0x74));
              
              
              /*
              step=0;
              val=0;
              for(x=0;x<=2;x++)
              {
              val=(TW28_ReadByte(page,0x03+step)+(((TW28_ReadByte(page,0x06+step)&BIT2&BIT3)<<6)));
              printf("\r\n Vin=%x,HAvtive_XY=%x",(U16) x ,(U16)val);
              step+=0x10;
              val=0;
              }
              
              step=0;
              val=0;
              for(x=0;x<=2;x++)
              {
              val=(TW28_ReadByte(page,0x05+step)+(((TW28_ReadByte(page,0x06+step)&BIT5)<<3)));
              printf("\r\n Vin=%x,VAvtive_XY=%x",(U16) x ,(U16)val);
C51 COMPILER V9.50a   NED                                                                  02/18/2019 18:00:34 PAGE 49  

              step+=0x10;
              val=0;
              }
              */
              
              }
              #endif
2975          
2976          //-----------------------------------------
2977          #if 0
              U16 peek(void)
              {
                /*
                if ( peek_flag == 0 ) { 
                  peek_buf =ReadByte();
                  if (  peek_buf >= 0 ) { 
                    peek_flag = 1;
                  }
                } 
                */
                return 1 ;//peek_buf;
                  
              }
              #endif
2992          //-----------------------------------------
2993          #if 0
              void Set_INT(void)
              {
              //INT_flag=0;
              
              EX0=1;
              IT0=1;
              IE0=0;  //flag
                  
              EX1=1;
              IT1=1;
              IE1=0;  //flag
              
              EX2=1;
              IT2=1;    //'1' falling edge trigger/ '0' low level trigger
              IE2=0;    //flag
              }
              #endif
3011          //----------------------------------------
3012          
3013          void MCTRL_set(void)
3014          {
3015   1      
3016   1      //... P[7:4]:INT[5:2], P2_3:HALE, P2_2:HRDB, P2_1:HWRB, P2_0:HSPB
3017   1      P2_0=0;///HSPB=0;
3018   1      P2_1=1;///HWRB=1;
3019   1      P2_2=1;///HRDB=1;
3020   1      P2_3=0;///HALE=0;
3021   1      }
3022          //-----------------------------------------
3023          /*
3024          //-----------------------------------------
3025          
3026          void Int0_interrupt(void) interrupt 0 using 1
3027          {
3028          
3029          IE0=0;
C51 COMPILER V9.50a   NED                                                                  02/18/2019 18:00:34 PAGE 50  

3030          EA=0;
3031          
3032          
3033          EA=1;
3034          
3035          
3036          }
3037          
3038          void Int1_interrupt(void) interrupt 2 using 1
3039          {
3040          IE1=0;
3041          EA=0;
3042          
3043          
3044          EA=1;
3045          
3046          
3047          }
3048          
3049          void Int2_interrupt(void) interrupt 6 using 1
3050          {
3051          
3052          IE2=0;
3053          EA=0;
3054          
3055          
3056          EA=1;
3057          
3058          
3059          }
3060          */
3061          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   3812    ----
   CONSTANT SIZE    =     15    ----
   XDATA SIZE       =    132      68
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
