C51 COMPILER V9.01   NED                                                                   12/25/2018 16:49:28 PAGE 1   


C51 COMPILER V9.01, COMPILATION OF MODULE NED
OBJECT MODULE PLACED IN .\OBJ\NED.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE NED.c LARGE OPTIMIZE(9,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\OBJ\NED.lst
                    -) OBJECT(.\OBJ\NED.obj)

line level    source

   1          #include "types.h"
   2          #include "NED.h"                  //add by ryan.
   3          #include "Main.h"
   4          #include "printf.h"
   5          //#include "Timer.h"
   6          #include "UART.h"
   7          #include "BusCtrl.h"
   8          //#include "TW2835_Init.h"
   9          #include "CommandShell.h"
  10          //#include "OSDAction.h"
  11          
  12          #define I2C_SCL         P2_5
  13          #define I2C_SDA         P2_6
  14          
  15          #define SC16IS750_CRYSTCAL_FREQ 1843200  ///1.8432MHz
  16          
  17          
  18          #define I2C_time 100
  19          #define SC16_data_buf (6*3)
  20          #define BaudRate_sel 38400
  21          //#define BaudRate_sel 9600
  22          
  23          #define dvr_com_flag 1
  24          #define camera_com_flag 2
  25          
  26           //U8 Com_buf[8]={0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff};  
  27           U8 Com_pos=0;
  28           U8 Com_addr=0;
  29           U8 Com_start=0;
  30            U8 Com_end=0;
  31            U8 Com_run=0;
  32          //U8 Monitor_mode=Monitor_offset;
  33          //U8 Monitor_current=Monitor_offset;
  34          U8 Monitor_mode=Monitor_offset+3;
  35          U8 Monitor_state=Monitor_offset;
  36          U8 Monitor_current=1;  //CR
  37          U8 Back_f=0;
  38          U8 Shrink_f=0;
  39          
  40          U8 Crop_f=0;//ryan@21050413
  41          //U8 Main_p=Camera_p;
  42          //U8 Small_p=Rear_p;
  43          extern U8 work_flag;
  44           U8 Com_flag=0;    
  45           U8 Com_temp=0;
  46           U8 INT_flag=0;
  47           U8 DRP_ID[9]={DVR_address,RF_ID_address,PIC32_address,RF_ID_address\
  48                          ,PIC32_address,DVR_address,PIC32_address,DVR_address,RF_ID_address};
  49          
  50           U8 SC16_Com[9];   //0-15, 0-5=DVR, 6-11=RF, 12-16=PIC32
  51           U8 SC16_ComAddr=0;
  52           U8 GPIO_current=0;
  53           U8 DVR_startup_flag=0;
  54           U8 Cam_startup_flag=0;
C51 COMPILER V9.01   NED                                                                   12/25/2018 16:49:28 PAGE 2   

  55           U8 DVR_Com[5]={0x02,0x37,0x32,0x03,0x04};
  56           U8 DVR_Com_p=0;
  57           U8 Cam_Com[5]={0x02,0x37,0x33,0x03,0x05};
  58           U8 Cam_Com_p=0;
  59          //camera temp data
  60          U8 Camera_ver0=0x30;
  61          U8 Camera_ver1=0x30;
  62          U8 Camera_ver2=0x30;
  63          U8 Camera_temp0=0x30;
  64          U8 Camera_temp1=0x30;
  65          U8 Camera_press0=0x30;
  66          U8 Camera_press1=0x30;
  67          U8 Camera_press2=0x30;
  68          U8 Camera_press3=0x30;
  69          
  70          U8 Camera_IRDA[28]={0x30,0x30,0x30,0x30,0x30,0x30,0x30,\
  71                                                  0x30,0x30,0x30,0x30,0x30,0x30,0x30,
  72                                                  0x30,0x30,0x30,0x30,0x30,0x30,0x30,
  73                                                  0x30,0x30,0x30,0x30,0x30,0x30,0x30};
  74          //U8 Camera_IRDA1[4]={0x30,0x30,0x30,0x30};
  75          //U8 Camera_IRDA2[4]={0x30,0x30,0x30,0x30};
  76          //U8 Camera_IRDA3[4]={0x30,0x30,0x30,0x30};
  77          //U8 Camera_IRDA4[4]={0x30,0x30,0x30,0x30};
  78          //U8 Camera_IRDA5[4]={0x30,0x30,0x30,0x30};
  79          //U8 Camera_IRDA6[4]={0x30,0x30,0x30,0x30};
  80          
  81          
  82          U8 Camera_Ang[4]={0x30,0x30,0x30,0x30};
  83          U8 Camera_RAng[4]={0x30,0x30,0x30,0x30};
  84          
  85          
  86          //dvr temp data
  87          U8 DVR_ver[3]={0x30,0x30,0x30};
  88          U8 DVR_temp[2]={0x30,0x30};
  89          U8 DVR_Y[4]={0x30,0x30,0x30,0x30};
  90          U8 DVR_MD[4]={0x30,0x30,0x30,0x30};
  91          U8 DVR_MH[4]={0x30,0x30,0x30,0x30};
  92          
  93          
  94           //get data from sc16--------------------
  95           U16 SC16_busy_flag=0;
  96          // U8 SC16_com_state=0;
  97           U8 SC16_com_buff[9]={0,0,0,0,0,0,0,0,0};
  98           U8 data_flag=0;
  99          //----------------------------------------
 100          U8 Cam_boot_flag=0;
 101          //U8 Cam_boot_count_flag=0;
 102          
 103          U8 get_data_addr=0;
 104          U8 get_data_val=0;
 105           //U16 BaudRate[3]={12,6,3};  //9600/19200/38400
 106           //U8 BaudRate_sel=9600;  //Default 9600
 107           //U32 BaudRate_sel=9600;  //Default 9600
 108          //U32 BaudRate_sel=19200;  //Default 9600
 109          //U32 BaudRate_sel=38400;  //Default 9600
 110          #ifdef Move_Camera
 111          U8 Camera_flag=0;
 112          
 113          #endif
 114            
 115           U8 OUTPUT=0;
 116           U8 peek_flag=0,peek_buf=0;
C51 COMPILER V9.01   NED                                                                   12/25/2018 16:49:28 PAGE 3   

 117          extern data user_timer[TIMER_NUM];
 118          
 119          //extern user_timer[3];
 120           
 121          //-------------I2C 
 122           void I2Cdelay(void)
 123           {
 124   1               #if 1//ryan@20151106
 125   1      
 126   1      
 127   1              //for(i=0; i<(1); i++)
 128   1              //      {
 129   1              //      }
 130   1               
 131   1               #else
                               U16 i; 
                       for(i=0; i<(20-12); i++){
              //          for(i=0; i<(20+120); i++){  //ryan..
                       }
                       #endif
 137   1       }
 138          #if 0
               void I2Cdelay2(void)
               {
                       U16 i;
                       for(i=0; i<(20); i++){
              //          for(i=0; i<(20+120); i++){  //ryan..
                       }
               }
              
              void I2C_100Khz(void)
              {
              
              while(USERTMVAL1>=2);
              USERTMVAL1=2;
              }
              #endif
 154          void I2CStart(void)
 155          {
 156   1      #if 1
 157   1            I2C_SDA = 1;      I2Cdelay(); 
 158   1              I2C_SCL = 1;    I2Cdelay();
 159   1              I2C_SDA = 0;    I2Cdelay();
 160   1              I2C_SCL = 0;
 161   1      #else
              //I2C_100Khz();
                  I2C_SCL = 1;
              // DELAY_FOR(10);///  I2Cdelay();
                  I2C_SDA = 1;
                  DELAY_FOR(I2C_time);///  I2Cdelay();
                  I2C_SDA = 0;
              
              DELAY_FOR(I2C_time);///  I2Cdelay();
              I2C_SCL = 0;
              
                  //DELAY_FOR(I2C_time);///  I2Cdelay();
                 // I2Cdelay();
              
              #endif
 176   1      }
 177          #if 0
              void I2CStart2(void)
C51 COMPILER V9.01   NED                                                                   12/25/2018 16:49:28 PAGE 4   

              {
              
                    I2C_SDA = 1;      I2Cdelay2(); 
                      I2C_SCL = 1;    I2Cdelay2();
                      I2C_SDA = 0;    I2Cdelay2();
                      I2C_SCL = 0;
              }
              #endif
 187          void I2CStop(void)
 188          {
 189   1         #if 1
 190   1              I2C_SDA = 0;    I2Cdelay();
 191   1              I2C_SCL = 1;    I2Cdelay();
 192   1              I2C_SDA = 1;
 193   1          #else
                    //DELAY_FOR(I2C_time);///I2Cdelay();  
                 I2C_SCL = 1;
                     //I2C_100Khz();
                       DELAY_FOR(I2C_time);///I2Cdelay();  
                 I2C_SDA = 0;
                    //      I2C_100Khz();
                    DELAY_FOR(I2C_time);/// I2Cdelay();
              
                  I2C_SDA = 1; 
                      // I2C_100Khz();
                      DELAY_FOR(I2C_time);///  I2Cdelay();
              
                  #endif
 207   1      }
 208          #if 0
              void I2CStop2(void)
              {
                 
                      I2C_SDA = 0;    I2Cdelay2();
                      I2C_SCL = 1;    I2Cdelay2();
                      I2C_SDA = 1;
              }
              #endif
 217          void I2CWriteData(BYTE value)
 218          {
 219   1         #if 1
 220   1              I2C_SCL=0;      I2C_SDA=(value & 0x80)? 1:0;    I2Cdelay(); I2C_SCL=1;  I2Cdelay();
 221   1              I2C_SCL=0;      I2C_SDA=(value & 0x40)? 1:0;    I2Cdelay(); I2C_SCL=1;  I2Cdelay();
 222   1              I2C_SCL=0;      I2C_SDA=(value & 0x20)? 1:0;    I2Cdelay();I2C_SCL=1;   I2Cdelay();
 223   1              I2C_SCL=0;      I2C_SDA=(value & 0x10)? 1:0;    I2Cdelay(); I2C_SCL=1;  I2Cdelay();
 224   1      
 225   1              I2C_SCL=0;      I2C_SDA=(value & 0x08)? 1:0;    I2Cdelay(); I2C_SCL=1;  I2Cdelay();
 226   1              I2C_SCL=0;      I2C_SDA=(value & 0x04)? 1:0;    I2Cdelay(); I2C_SCL=1;  I2Cdelay();
 227   1              I2C_SCL=0;      I2C_SDA=(value & 0x02)? 1:0;    I2Cdelay(); I2C_SCL=1;  I2Cdelay();
 228   1              I2C_SCL=0;      I2C_SDA=(value & 0x01)? 1:0;    I2Cdelay(); I2C_SCL=1;  I2Cdelay();
 229   1      
 230   1      
 231   1              I2C_SCL = 0;    // HHY 3.00
 232   1              I2C_SCL = 0;    // HHY 3.00
 233   1              I2C_SCL = 0;    //I2Cdelay();
 234   1            I2C_SDA = 1;      //I2Cdelay();
 235   1            
 236   1              I2C_SCL = 1;    // HHY 3.00
 237   1              I2C_SCL = 1;    // HHY 3.00
 238   1              I2C_SCL = 1;
 239   1                      I2Cdelay();
 240   1              I2C_SCL = 0;
C51 COMPILER V9.01   NED                                                                   12/25/2018 16:49:28 PAGE 5   

 241   1                    I2Cdelay();
 242   1          #else
                      BYTE i, tmpbyte = value;
                    //  tmpbyte=0x55;
              //I2Cdelay();
                      for(i = 0; i < 8; i++)
                      {
                              if((0x80 & tmpbyte))
                                      I2C_SDA=1;///GPIO_SetBits(GPIOB, I2C2_SDA);
                              else
                                      I2C_SDA=0;///GPIO_ResetBits(GPIOB, I2C2_SDA);
                                      //I2C_100Khz();
                          
                              //I2Cdelay();
                              DELAY_FOR(I2C_time);///  I2Cdelay();
                           I2C_SCL=1;
                           //I2C_100Khz();
                              DELAY_FOR(I2C_time);///  I2Cdelay();
                           I2C_SCL=0;
                              DELAY_FOR(I2C_time);///  I2Cdelay();
                           //I2C_100Khz();
                           //DELAY_FOR(5);///I2Cdelay();
                              //I2CDLY_5uSec(1);
                              ///GPIO_SetBits(GPIOB, I2C2_SCL);
                              ///I2CDLY_5uSec(1);
                              ///GPIO_ResetBits(GPIOB, I2C2_SCL);
                              tmpbyte = tmpbyte << 1;
                      }
                       //DELAY_FOR(10);///I2Cdelay();
                    //I2Cdelay();
                      //I2C_SDA = 1;      //ACK
                      // I2C_SCL=1;
                      // DELAY_FOR(10);///I2Cdelay();
                   //I2Cdelay();//ryan..
                      //I2C_SCL = 1;  // HHY 3.00
                      //I2Cdelay(); //ryan..
                      //I2C_SCL = 0;
                      //I2Cdelay(); //ryan..
                //    I2C_SDA = 1;    //      I2Cdelay();//ryan.
              //     I2Cdelay(); //ryan..
                  
                   #endif
 283   1      }
 284          
 285          #if 0
              void I2CWriteData2(BYTE value)
              {
                
                      I2C_SCL=0;      I2C_SDA=(value & 0x80)? 1:0;    I2Cdelay2(); I2C_SCL=1; I2Cdelay2();
                      I2C_SCL=0;      I2C_SDA=(value & 0x40)? 1:0;    I2Cdelay2(); I2C_SCL=1; I2Cdelay2();
                      I2C_SCL=0;      I2C_SDA=(value & 0x20)? 1:0;    I2Cdelay2();I2C_SCL=1;  I2Cdelay2();
                      I2C_SCL=0;      I2C_SDA=(value & 0x10)? 1:0;    I2Cdelay(); I2C_SCL=1;  I2Cdelay2();
              
                      I2C_SCL=0;      I2C_SDA=(value & 0x08)? 1:0;    I2Cdelay2(); I2C_SCL=1; I2Cdelay2();
                      I2C_SCL=0;      I2C_SDA=(value & 0x04)? 1:0;    I2Cdelay2(); I2C_SCL=1; I2Cdelay2();
                      I2C_SCL=0;      I2C_SDA=(value & 0x02)? 1:0;    I2Cdelay2(); I2C_SCL=1; I2Cdelay2();
                      I2C_SCL=0;      I2C_SDA=(value & 0x01)? 1:0;    I2Cdelay2(); I2C_SCL=1; I2Cdelay2();
              
              
                      I2C_SCL = 0;    // HHY 3.00
                      I2C_SCL = 0;    // HHY 3.00
                      I2C_SCL = 0;    //I2Cdelay();
C51 COMPILER V9.01   NED                                                                   12/25/2018 16:49:28 PAGE 6   

                    I2C_SDA = 1;      //I2Cdelay();
                    
                      I2C_SCL = 1;    // HHY 3.00
                      I2C_SCL = 1;    // HHY 3.00
                      I2C_SCL = 1;
                              I2Cdelay2();
                      I2C_SCL = 0;
                            I2Cdelay2();
              }
              #endif
 313          
 314          
 315          U8 I2CReadData(void)
 316          {
 317   1      #if 1
 318   1              U16 i;
 319   1              U8 value=0;
 320   1      
 321   1              I2C_SDA = 1;    I2Cdelay();
 322   1              I2C_SCL = 0;
 323   1              
 324   1              for(i=0; i<8; i++) {
 325   2                  I2Cdelay();
 326   2                      I2C_SCL = 1;
 327   2                      value <<= 1;
 328   2                      if(I2C_SDA) value |= 1;
 329   2              I2Cdelay();
 330   2                      I2C_SCL = 0;
 331   2                          I2Cdelay();
 332   2              }
 333   1       
 334   1             I2Cdelay();
 335   1              //I2C_SCL = 1;  // HHY 3.00
 336   1              //I2C_SCL = 1;  // HHY 3.00
 337   1              //I2C_SCL = 1; 
 338   1               I2Cdelay();
 339   1            //  I2C_SCL = 0;
 340   1              I2Cdelay();
 341   1              return value;
 342   1      #else
                      BYTE i, bitt, ReadValue = 0,vall[8]={0,0,0,0,0,0,0,0};
                    U16 val2=0;
                        
                      //GPIO_InitTypeDef GPIO_InitStruct;
              
                     //I2Cdelay();
                      //I2C_SDA = 1;  I2Cdelay();
                      //I2C_SCL = 0; I2Cdelay();
                  
                      for(i = 0; i < 8; i++)
                      {
              
                              if( I2C_SDA==1) bitt = 0x01;
                              else                       bitt = 0x00;
              
                  // vall[i]=bitt;
              
                              //I2C_100Khz();
                       DELAY_FOR(I2C_time);///  I2Cdelay();
                        //DELAY_FOR(5);/// I2Cdelay();
                          I2C_SCL = 1;
                       DELAY_FOR(I2C_time);///  I2Cdelay();
C51 COMPILER V9.01   NED                                                                   12/25/2018 16:49:28 PAGE 7   

                      //DELAY_FOR(5);/// I2Cdelay();
                          I2C_SCL = 0;
                       DELAY_FOR(I2C_time);///  I2Cdelay();
                         //DELAY_FOR(5);///   I2Cdelay();
                          //I2Cdelay();          
                              //I2CDLY_5uSec(1);
                              //GPIO_SetBits(GPIOB, I2C2_SCL);
                              //I2CDLY_5uSec(1);              
                              //GPIO_ResetBits(GPIOB, I2C2_SCL);              
                              //I2CDLY_5uSec(1);
                              ReadValue = (ReadValue<<1)|bitt;
                      }
              //val2=ReadValue;
              
              //Printf("Val=%X %X %X %X %X %X %X %X \r\n",vall[7],vall[6],vall[5],vall[4],vall[3],vall[2],vall[1],vall[0
             -]);
              //Printf("Val= %x\r\n",val2);
              
              
                    //  I2C_SDA = 1;      //ACK
                      // I2C_SCL=1;
                      // DELAY_FOR(10);///   I2Cdelay();
                       //I2Cdelay();  
                      //GPIO_InitStruct.GPIO_Mode = GPIO_Mode_Out_PP;
                      //GPIO_InitStruct.GPIO_Pin = I2C2_SDA | I2C2_SCL;
                      //GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz;
                      //GPIO_Init(GPIOB, &GPIO_InitStruct);
              //      I2C_SDA = 0;        //ACK
               //    I2Cdelay();//ryan..
              //      I2C_SCL = 1;    // HHY 3.00
              //      I2Cdelay(); //ryan..
               //      I2C_SCL = 0;
                      //I2Cdelay(); //ryan..
                   // I2C_SDA = 1;    //      I2Cdelay();//ryan.
                    // I2Cdelay(); //ryan..
                      return ReadValue;
              #endif
 401   1      }
 402          #if 0
              U8 I2CReadData2(void)
              {
              
                      U16 i;
                      U8 value=0;
              
                      I2C_SDA = 1;    I2Cdelay2();
                      I2C_SCL = 0;
                      
                      for(i=0; i<8; i++) {
                          I2Cdelay2();
                              I2C_SCL = 1;
                              value <<= 1;
                              if(I2C_SDA) value |= 1;
                      I2Cdelay2();
                              I2C_SCL = 0;
                                  I2Cdelay2();
                      }
               
                     I2Cdelay2();
                      //I2C_SCL = 1;  // HHY 3.00
                      //I2C_SCL = 1;  // HHY 3.00
                      //I2C_SCL = 1; 
C51 COMPILER V9.01   NED                                                                   12/25/2018 16:49:28 PAGE 8   

                       I2Cdelay2();
                    //  I2C_SCL = 0;
                      I2Cdelay2();
                      return value;
              }
              #endif
 432          U8 I2CReadDataWithACK(void)
 433          {
 434   1        #if 1
 435   1              U16 i;
 436   1              U8 value=0;
 437   1      
 438   1              I2C_SDA = 1;    I2Cdelay();
 439   1              I2C_SCL = 0;
 440   1      
 441   1              for(i=0; i<8; i++) {
 442   2                       I2Cdelay();
 443   2                      I2C_SCL = 1;
 444   2                      value <<= 1;
 445   2                      if(I2C_SDA) value |= 1;
 446   2                       I2Cdelay();
 447   2                      I2C_SCL = 0;
 448   2                       I2Cdelay();
 449   2              }
 450   1              
 451   1              I2C_SDA = 0;//  I2Cdelay();             //ack
 452   1              //I2C_SCL = 1;  I2Cdelay();
 453   1              //I2C_SCL = 0;
 454   1      
 455   1             I2Cdelay();    //ACk
 456   1               I2C_SCL = 1;   // HHY 3.00
 457   1               I2C_SCL = 1;   // HHY 3.00
 458   1               I2C_SCL = 1; 
 459   1               I2Cdelay();
 460   1              I2C_SCL = 0;
 461   1              I2Cdelay();
 462   1      
 463   1              return value;
 464   1              
 465   1         #else
                  
                      BYTE i, bitt, ReadValue = 0;
                      //GPIO_InitTypeDef GPIO_InitStruct;
              
                      for(i = 0; i < 8; i++)
                      {
              
                              if( I2C_SDA==1) bitt = 0x01;
                              else                       bitt = 0x00;
                      
                          I2Cdelay();
                          I2C_SCL = 1;
                          I2Cdelay();
                          I2C_SCL = 0;
                          I2Cdelay();          
                              //I2CDLY_5uSec(1);
                              //GPIO_SetBits(GPIOB, I2C2_SCL);
                              //I2CDLY_5uSec(1);              
                              //GPIO_ResetBits(GPIOB, I2C2_SCL);              
                              //I2CDLY_5uSec(1);
                              ReadValue = (ReadValue<<1)|bitt;
                      }
C51 COMPILER V9.01   NED                                                                   12/25/2018 16:49:28 PAGE 9   

                  
                      I2C_SDA = 0;    I2Cdelay();             //ack
                      I2C_SCL = 1;    I2Cdelay();
                      I2C_SCL = 0;
                      //GPIO_InitStruct.GPIO_Mode = GPIO_Mode_Out_PP;
                      //GPIO_InitStruct.GPIO_Pin = I2C2_SDA | I2C2_SCL;
                      //GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz;
                      //GPIO_Init(GPIOB, &GPIO_InitStruct);
                      return ReadValue;
                  
                  #endif
 499   1      }
 500          #if 0
              U8 I2CReadDataWithACK2(void)
              {
              //#if 1
                      U16 i;
                      U8 value=0;
              
                      I2C_SDA = 1;    I2Cdelay2();
                      I2C_SCL = 0;
              
                      for(i=0; i<8; i++) {
                               I2Cdelay2();
                              I2C_SCL = 1;
                              value <<= 1;
                              if(I2C_SDA) value |= 1;
                               I2Cdelay2();
                              I2C_SCL = 0;
                               I2Cdelay2();
                      }
                      
                      I2C_SDA = 0;//  I2Cdelay();             //ack
                      //I2C_SCL = 1;  I2Cdelay();
                      //I2C_SCL = 0;
              
                     I2Cdelay2();    //ACk
                       I2C_SCL = 1;   // HHY 3.00
                       I2C_SCL = 1;   // HHY 3.00
                       I2C_SCL = 1; 
                       I2Cdelay2();
                      I2C_SCL = 0;
                      I2Cdelay2();
              
                      return value;
              }
              #endif
 535          void WriteI2C(U8 addr, U8 index, U8 val)
 536          {
 537   1      
 538   1      #if 1
 539   1              I2CStart();
 540   1              I2CWriteData(addr);
 541   1              I2CWriteData(index<<3);
 542   1              I2CWriteData(val);
 543   1              I2CStop();
 544   1      
 545   1      #else
                      I2CStart();
                      I2CWriteData(addr);
                     I2C_ACK2();
                      I2CWriteData((index<<3));
C51 COMPILER V9.01   NED                                                                   12/25/2018 16:49:28 PAGE 10  

                     I2C_ACK2();
                      I2CWriteData(val);
                     I2C_ACK2();
                     I2CStop();
              #endif
 555   1      }
 556          
 557          U8 ReadI2C(U8 addr, U8 index)
 558          {
 559   1      U8 val;//,x,y,z,val2[16];
 560   1      
 561   1             #if 1
 562   1              I2CStart();
 563   1              I2CWriteData(addr);
 564   1              I2CWriteData(index<<3);
 565   1              I2CStart();
 566   1              I2CWriteData(addr | 0x01);
 567   1              val = I2CReadData();
 568   1                //val = I2CReadDataWithACK();
 569   1       
 570   1              I2CStop();
 571   1            #else
                      I2CStart();
                      I2CWriteData(addr);
                   I2C_ACK2(); 
                  I2CWriteData((index<<3));
                   I2C_ACK2();  
                       
                  I2CStart();
                        //   P2M0|=0x40;
                 //DELAY_FOR(20);/// I2Cdelay();
               //USERTMVAL1=2; 
               
                   I2CWriteData(addr|0x01);
                
                 I2C_ACK2(); 
              
              //for(x=0;x<=14;x++)
              //{
                    val = I2CReadData();
                         //  P2M0&=0xBF;
                 //DELAY_FOR(20);/// I2Cdelay();
              //val2[x]=val;
                         // I2C_ACK2();  
                       //val = I2CReadDataWithACK();
                       //I2C_ACK2(); 
              //}
              
                    val = I2CReadData();
                      //  val2[15]=val;
               I2CStop();
              
              #if 0
              Printf("-> \r\n",(U16) x,(U16) val2[x]);  //ryan          
              for(x=0;x<=15;x++)
              {
              
              Printf("Addr=%x  Data=%x \r\n",(U16) x,(U16) val2[x]);  //ryan 
              
              }
              Printf("                    <-\r\n",(U16) x,(U16) val2[x]);  //ry               
              #endif
C51 COMPILER V9.01   NED                                                                   12/25/2018 16:49:28 PAGE 11  

              
                      #endif
 614   1                      //Printf("Data=%x \r\n",(U16)val);  //ryan
 615   1              return val;
 616   1      }
 617          //---------------------------------------
 618          #if 0
              void WriteI2C2(U8 addr, U8 index, U8 val)
              {
                      I2CStart();
                      I2CWriteData(addr);
                      I2CWriteData(index);
                      I2CWriteData(val);
                      I2CStop();
              
              }
              //---------------------------------------
              U8 ReadI2C2(U8 addr, U8 index)
              {
                    U8 val;
                        
                      I2CStart();
                      I2CWriteData(addr);
                      I2CWriteData(index);
                      I2CStart();
                      I2CWriteData(addr | 0x01);
                      val = I2CReadData();
                        //val = I2CReadDataWithACK();
                      I2CStop();      
              return 1;  
              }
              
              //----------------------------------------
               void I2C_ACK(void)
              {
                   
                         // I2Cdelay();               //ack
               
                        I2Cdelay();           //ack
                      I2C_SCL = 1;
                        I2Cdelay();
                      I2C_SCL = 0;
                        I2Cdelay();
                         I2C_SDA = 1;
              }
              
               void I2C_ACK2(void)
              {
                   //while(I2C_SDA==1);
                  //  DELAY_FOR(10);///   I2Cdelay();         //ack
                 // I2C_SDA = 0;
                    //  I2Cdelay();           //ack
                     // DELAY_FOR(5);///     I2Cdelay   
                       DELAY_FOR(I2C_time);///  I2Cdelay();     
                      I2C_SCL = 1;
                       DELAY_FOR(I2C_time);///  I2Cdelay();
                   //DELAY_FOR(5);///     I2Cdelay();
                      I2C_SCL = 0;
                       DELAY_FOR(I2C_time);///  I2Cdelay();
              // DELAY_FOR(5);///    I2Cdelay();
               //I2C_SDA = 1;
                 //  DELAY_FOR(10);///     I2Cdelay();
C51 COMPILER V9.01   NED                                                                   12/25/2018 16:49:28 PAGE 12  

                     
              }
               #endif
 677          //----------------------------------------
 678          
 679          U16 ReadI2CWORD(BYTE addr, BYTE index)
 680          {
 681   1              U16 val=0;
 682   1      
 683   1              I2CStart();
 684   1              I2CWriteData(addr);
 685   1            //I2C_ACK();
 686   1              I2CWriteData(index);
 687   1            //I2C_ACK();
 688   1          
 689   1              I2CStart();
 690   1              I2CWriteData(addr | 0x01);
 691   1              
 692   1              val = I2CReadDataWithACK();
 693   1              val = val<<8;
 694   1              val |= I2CReadData();
 695   1              I2CStop();
 696   1      
 697   1              return val;
 698   1      }
 699          //---------------------------------------
 700          #if 0
              void WriteI2CWORD(U8 addr, U8 index, U16 Data)
              {
                    U8 tempL,tempH;
              
                      tempH=((Data>>8)&0x00ff);
                      tempL=(Data&0x00ff);
                      I2CStart();
                      I2CWriteData(addr);
                      I2CWriteData(index);
                      I2CWriteData(tempH);
                      I2CWriteData(tempL);
                      I2CStop();
              }
              #endif
 715          //----------------------------------------
 716          
 717          void Bound_Set(U8 val)
 718          {
 719   1      
 720   1      
 721   1      //U8 loop;
 722   1      U8 Mask[3]={0x11,0x19,0x21};
 723   1      
 724   1      #ifdef black_boundary
              switch(val)
              {
              case 1: TW28_WriteByte(1,0x11,0x02); 
                              TW28_WriteByte(1,0x0f,0x00);
                              break;
              case 2: TW28_WriteByte(1,0x19,0x02);
                              TW28_WriteByte(1,0x0f,0x00);
                              break;
              case 4: TW28_WriteByte(1,0x21,0x02);
                              TW28_WriteByte(1,0x0f,0x00);
                              break;
C51 COMPILER V9.01   NED                                                                   12/25/2018 16:49:28 PAGE 13  

              default:
                              
                              //TW28_WriteByte(1,0x0f,0x03);
                              TW28_WriteByte(1,0x11,0x00);
                              TW28_WriteByte(1,0x19,0x00);
                              TW28_WriteByte(1,0x21,0x00);
                            break;    
              }
              #else
 745   1      switch(val)
 746   1      {
 747   2      case 1: TW28_WriteByte(1,0x11,0x02); 
 748   2                      TW28_WriteByte(1,0x0f,0x33);
 749   2                      break;
 750   2      case 2: TW28_WriteByte(1,0x19,0x02);
 751   2                      TW28_WriteByte(1,0x0f,0x33);
 752   2                      break;
 753   2      case 4: TW28_WriteByte(1,0x21,0x02);
 754   2                      TW28_WriteByte(1,0x0f,0x33);
 755   2                      break;
 756   2      default:
 757   2                      
 758   2                      //TW28_WriteByte(1,0x0f,0x03);
 759   2                      TW28_WriteByte(1,0x11,0x00);
 760   2                      TW28_WriteByte(1,0x19,0x00);
 761   2                      TW28_WriteByte(1,0x21,0x00);
 762   2                    break;    
 763   2      }
 764   1      
 765   1      #endif
 766   1      /*
 767   1      for(loop=0;loop<=2;loop++)
 768   1      {
 769   1              if((val&0x01)==1)
 770   1                      {
 771   1                      TW28_WriteByte(1,Mask[loop],0x02);      
 772   1                      return;
 773   1                      }
 774   1              //else
 775   1                      //TW28_WriteByte(1,Mask[loop],0x00);    
 776   1              
 777   1              val>>=1;
 778   1      }
 779   1      */
 780   1      
 781   1      
 782   1      }
 783          
 784          //---------------------------------------
 785          #if 0
              void Set_channel(U8 addr)
              {
              TW28_WriteByte(1,0x10,0x00); //C
              TW28_WriteByte(1,0x18,0x00);  //R
              TW28_WriteByte(1,0x20,0x00);  //D
              
              
                      switch(addr)
                      {
              case 0x10: TW28_WriteByte(1,0x10,0x80); break;  //C
              case 0x20: TW28_WriteByte(1,0x20,0x82); break;  //R
              case 0x40: TW28_WriteByte(1,0x18,0x81); break;  //D
C51 COMPILER V9.01   NED                                                                   12/25/2018 16:49:28 PAGE 14  

              case 0x12: Bound_Set(0x01); break;  //CR
              case 0x21: Bound_Set(0x01); break;  //RC
              case 0x14: Bound_Set(0x01); break;  //DC
              case 0x41: Bound_Set(0x02); break;  //CD
              case 0x24: Bound_Set(0x01); break;  //DR
              case 0x42: Bound_Set(0x01); break;  //RD
              default:
                               break;
              
                      }
               
              }
              #endif
 811          
 812          
 813          //----------------------------------------
 814          
 815          U16 ADC_read(U8 sel)
 816          {
 817   1          
 818   1      ADCTL=0x80|0x08|sel;  //start adc sampling
 819   1      
 820   1      while(ADCTL&0x08);// printf("ADC is busying\r\n");  //wating for adc
 821   1      
 822   1      return (U16)(((ADCVL&0x03) |(ADCV<<2))&0x03ff);
 823   1      
 824   1      }
 825          
 826          //20160226
 827          //-----------------------------------------
 828          void Set_Video(U8 addr, U8 val)
 829          {
 830   1      switch (addr)
 831   1      {
 832   2      case 0: TW28_WriteByte(0,0x09,val); //VIN0 CONT,TW2871
 833   2                      break;
 834   2      case 1: TW28_WriteByte(0,0x0a,val);//VIN0 BRT,TW2871
 835   2                      break;
 836   2      case 2:  TW28_WriteByte(0,0x19,val);//VIN1 CONT,Recorder
 837   2                      break;
 838   2      case 3:  TW28_WriteByte(0,0x1a,val);//VIN1 BRT,Recorder
 839   2                      break;
 840   2      case 4: TW28_WriteByte(0,0x29,val); //VIN2 CONT,Back cam
 841   2                      break;
 842   2      case 5:  TW28_WriteByte(0,0x2a,val);//VIN2 BRT,Back cam
 843   2                      break;
 844   2      default:
 845   2              break;
 846   2      
 847   2      }
 848   1      
 849   1      
 850   1      }
 851          
 852          
 853          //-----------------------------------------
 854          #if 0
              void Send_Camera_Ver(void)
              {
              U8 loop;
              
              SC16_Com[0]=STX;
C51 COMPILER V9.01   NED                                                                   12/25/2018 16:49:28 PAGE 15  

              SC16_Com[1]=0x32;
              SC16_Com[2]=0x4f;
              SC16_Com[3]=Camera_ver2;
              SC16_Com[4]=Camera_ver1;
              SC16_Com[5]=Camera_ver0;
              SC16_Com[6]=0x20;
              SC16_Com[7]=ETX;
              SC16_Com[8]=BCC_Cal(SC16_Com, 8);
              
                      for(loop=0;loop<=8;loop++)
                      {
                      RS_tx(SC16_Com[loop]);
                      }
              }
              #endif
 875          void Get_Camera_Ver(void)
 876          {
 877   1      WriteByte(DRP_ID[2], 0x02);
 878   1      WriteByte(DRP_ID[2], 0x31);
 879   1      WriteByte(DRP_ID[2], 0x4f);
 880   1      WriteByte(DRP_ID[2], 0x03);
 881   1      WriteByte(DRP_ID[2], 0x7f);
 882   1      }
 883          
 884          //-----------------------------------------
 885          void Send_Camera_Temp(void)
 886          {
 887   1      
 888   1      U8 loop;
 889   1      
 890   1      SC16_Com[0]=STX;
 891   1      SC16_Com[1]=0x32;
 892   1      SC16_Com[2]=0x31;
 893   1      SC16_Com[3]=Camera_temp1;
 894   1      SC16_Com[4]=Camera_temp0;
 895   1      SC16_Com[5]=0x20;
 896   1      SC16_Com[6]=0x20;
 897   1      SC16_Com[7]=ETX;
 898   1      SC16_Com[8]=BCC_Cal(SC16_Com, 8);
 899   1      
 900   1              for(loop=0;loop<=8;loop++)
 901   1              {
 902   2              RS_tx(SC16_Com[loop]);
 903   2              }
 904   1      
 905   1      
 906   1      }
 907          
 908          //----------------------------------------
 909          
 910          void Send_Camera_Press(void)
 911          {
 912   1      U8 loop;
 913   1      
 914   1      SC16_Com[0]=STX;
 915   1      SC16_Com[1]=0x32;
 916   1      SC16_Com[2]=0x33;
 917   1      #if 0
              SC16_Com[3]=Camera_press1;
              SC16_Com[4]=Camera_press0;
              SC16_Com[5]=0x20;
              SC16_Com[6]=0x20;
C51 COMPILER V9.01   NED                                                                   12/25/2018 16:49:28 PAGE 16  

              #else
 923   1      SC16_Com[3]=Camera_press3;
 924   1      SC16_Com[4]=Camera_press2;
 925   1      SC16_Com[5]=Camera_press1;
 926   1      SC16_Com[6]=Camera_press0;
 927   1      #endif
 928   1      SC16_Com[7]=ETX;
 929   1      SC16_Com[8]=BCC_Cal(SC16_Com, 8);
 930   1      
 931   1              for(loop=0;loop<=8;loop++)
 932   1              {
 933   2              RS_tx(SC16_Com[loop]);
 934   2              }
 935   1      
 936   1      
 937   1      
 938   1      }
 939          
 940          //----------------------------------------
 941          void Get_Camera_Ang(void)
 942          {
 943   1      WriteByte(DRP_ID[2], 0x02);
 944   1      WriteByte(DRP_ID[2], 0x31);
 945   1      WriteByte(DRP_ID[2], 0x34);
 946   1      WriteByte(DRP_ID[2], 0x03);
 947   1      WriteByte(DRP_ID[2], 0x04);
 948   1      
 949   1      }
 950          
 951          void Sent_Camera_Ang(void)
 952          {
 953   1      
 954   1      U8 loop;
 955   1      
 956   1      SC16_Com[0]=STX;
 957   1      SC16_Com[1]=0x32;
 958   1      SC16_Com[2]=0x34;
 959   1      SC16_Com[3]=Camera_Ang[3];
 960   1      SC16_Com[4]=Camera_Ang[2];
 961   1      SC16_Com[5]=Camera_Ang[1];
 962   1      SC16_Com[6]=Camera_Ang[0];
 963   1      SC16_Com[7]=ETX;
 964   1      SC16_Com[8]=BCC_Cal(SC16_Com, 8);
 965   1      
 966   1              for(loop=0;loop<=8;loop++)
 967   1              {
 968   2              RS_tx(SC16_Com[loop]);
 969   2              }
 970   1      
 971   1      }
 972          //----------------------------------------
 973          void Get_Camera_RAng(void)
 974          {
 975   1      WriteByte(DRP_ID[2], 0x02);
 976   1      WriteByte(DRP_ID[2], 0x31);
 977   1      WriteByte(DRP_ID[2], 0x35);
 978   1      WriteByte(DRP_ID[2], 0x03);
 979   1      WriteByte(DRP_ID[2], 0x05);
 980   1      }
 981          
 982          void Sent_Camera_RAng(void)
 983          {
C51 COMPILER V9.01   NED                                                                   12/25/2018 16:49:28 PAGE 17  

 984   1      
 985   1      U8 loop;
 986   1      
 987   1      SC16_Com[0]=STX;
 988   1      SC16_Com[1]=0x32;
 989   1      SC16_Com[2]=0x35;
 990   1      SC16_Com[3]=Camera_RAng[3];
 991   1      SC16_Com[4]=Camera_RAng[2];
 992   1      SC16_Com[5]=Camera_RAng[1];
 993   1      SC16_Com[6]=Camera_RAng[0];
 994   1      SC16_Com[7]=ETX;
 995   1      SC16_Com[8]=BCC_Cal(SC16_Com, 8);
 996   1      
 997   1              for(loop=0;loop<=8;loop++)
 998   1              {
 999   2              RS_tx(SC16_Com[loop]);
1000   2              }
1001   1      
1002   1      }
1003          //----------------------------------------
1004          #if 0
              void Get_Camera_IRD(U8 sel)
              {
              //U8 bcc[4]={0x02,0x31,0,0x03},bcc_val;
              U8 bcc_val=0;
              
              bcc_val^=STX;
              bcc_val^=0x31;
              bcc_val^=sel;
              bcc_val^=ETX;
                      
              //bcc_val=BCC_Cal(&bcc[0],4);
                      
              WriteByte(DRP_ID[2],STX);
              WriteByte(DRP_ID[2],0x31);
              WriteByte(DRP_ID[2], sel);
              WriteByte(DRP_ID[2], ETX);
              WriteByte(DRP_ID[2], bcc_val );
              
              }
              #endif
1025          void Sent_Camera_IRD(U8 sel)
1026          {
1027   1              
1028   1      U8 loop;
1029   1      U8 temp=0;
1030   1      
1031   1      RS_tx(NAK);
1032   1      return;//ryan@20150908
1033   1      
1034   1      temp=(sel-0x41);
1035   1      temp=temp*4;
1036   1      SC16_Com[0]=STX;
1037   1      SC16_Com[1]=0x32;
1038   1      SC16_Com[2]=sel;
1039   1      SC16_Com[3]=Camera_IRDA[temp+3];
1040   1      SC16_Com[4]=Camera_IRDA[temp+2];
1041   1      SC16_Com[5]=Camera_IRDA[temp+1];
1042   1      SC16_Com[6]=Camera_IRDA[temp+0];
1043   1      SC16_Com[7]=ETX;
1044   1      SC16_Com[8]=BCC_Cal(SC16_Com, 8);
1045   1      
C51 COMPILER V9.01   NED                                                                   12/25/2018 16:49:28 PAGE 18  

1046   1              for(loop=0;loop<=8;loop++)
1047   1              {
1048   2              RS_tx(SC16_Com[loop]);
1049   2              }
1050   1      
1051   1      }
1052          
1053          //----------------------------------------
1054          
1055          void Get_DVR_temp(void)
1056          {
1057   1      WriteByte(DRP_ID[0], STX);
1058   1      WriteByte(DRP_ID[0], 0x33);
1059   1      WriteByte(DRP_ID[0], 0x31);
1060   1      WriteByte(DRP_ID[0], ETX);
1061   1      WriteByte(DRP_ID[0], 0x03);
1062   1      }
1063          
1064          
1065          void Sent_DVR_temp(void)
1066          {
1067   1      U8 loop;
1068   1      
1069   1      SC16_Com[0]=STX;
1070   1      SC16_Com[1]=0x34;
1071   1      SC16_Com[2]=0x31;
1072   1      SC16_Com[3]=DVR_temp[1];
1073   1      SC16_Com[4]=DVR_temp[0];
1074   1      SC16_Com[5]=0x20;
1075   1      SC16_Com[6]=0x20;
1076   1      SC16_Com[7]=ETX;
1077   1      SC16_Com[8]=BCC_Cal(SC16_Com, 8);
1078   1      
1079   1              for(loop=0;loop<=8;loop++)
1080   1              {
1081   2              RS_tx(SC16_Com[loop]);
1082   2              }
1083   1      
1084   1      
1085   1      }
1086          
1087          #if 0
              void Get_DVR_ver(void)
              {
              WriteByte(DRP_ID[0], STX);
              WriteByte(DRP_ID[0], 0x33);
              WriteByte(DRP_ID[0], 0x4F);
              WriteByte(DRP_ID[0], ETX);
              WriteByte(DRP_ID[0], 0x7D);
              }
              void Sent_DVR_ver(void)
                      {
              U8 loop;
              
              SC16_Com[0]=STX;
              SC16_Com[1]=0x34;
              SC16_Com[2]=0x4f;
              SC16_Com[3]=DVR_ver[2];
              SC16_Com[4]=DVR_ver[1];
              SC16_Com[5]=DVR_ver[0];
              SC16_Com[6]=0x20;
              SC16_Com[7]=ETX;
C51 COMPILER V9.01   NED                                                                   12/25/2018 16:49:28 PAGE 19  

              SC16_Com[8]=BCC_Cal(SC16_Com, 8);
              
                      for(loop=0;loop<=8;loop++)
                      {
                      RS_tx(SC16_Com[loop]);
                      }
              
                      }
              
              void Get_DVR_Year(void)
              {
              WriteByte(DRP_ID[0], STX);
              WriteByte(DRP_ID[0], 0x33);
              WriteByte(DRP_ID[0], 0x35);
              WriteByte(DRP_ID[0], ETX);
              WriteByte(DRP_ID[0], 0x07);
              }
              
              void Sent_DVR_Year(void)
              {
              U8 loop;
              
              SC16_Com[0]=STX;
              SC16_Com[1]=0x34;
              SC16_Com[2]=0x35;
              SC16_Com[3]=DVR_Y[3];
              SC16_Com[4]=DVR_Y[2];
              SC16_Com[5]=DVR_Y[1];
              SC16_Com[6]=DVR_Y[0];
              SC16_Com[7]=ETX;
              SC16_Com[8]=BCC_Cal(SC16_Com, 8);
              
                      for(loop=0;loop<=8;loop++)
                      {
                      RS_tx(SC16_Com[loop]);
                      }
              
              
              }
              
              void Get_DVR_MD(void)
                      {
              WriteByte(DRP_ID[0], STX);
              WriteByte(DRP_ID[0], 0x33);
              WriteByte(DRP_ID[0], 0x36);
              WriteByte(DRP_ID[0], ETX);
              WriteByte(DRP_ID[0], 0x04);
              }
              void Sent_DVR_MDr(void)
                      {}
              void Get_DVR_HS(void)
                      {
              WriteByte(DRP_ID[0], STX);
              WriteByte(DRP_ID[0], 0x33);
              WriteByte(DRP_ID[0], 0x37);
              WriteByte(DRP_ID[0], ETX);
              WriteByte(DRP_ID[0], 0x05);
              }
              void Sent_DVR_HS(void){}
              #endif
1168          //-----------------------------------------
1169          
C51 COMPILER V9.01   NED                                                                   12/25/2018 16:49:28 PAGE 20  

1170          void Set_Camera_speed(U8 val)
1171          {
1172   1              if(val)
1173   1                      {
1174   2      WriteByte(DRP_ID[2], STX);
1175   2      WriteByte(DRP_ID[2], 0xFF);
1176   2      WriteByte(DRP_ID[2], 0x90);
1177   2      WriteByte(DRP_ID[2], ETX);
1178   2      WriteByte(DRP_ID[2], 0x6E);
1179   2                      }
1180   1              else
1181   1                      {
1182   2      WriteByte(DRP_ID[2], STX);
1183   2      WriteByte(DRP_ID[2], 0xFF);
1184   2      WriteByte(DRP_ID[2], 0x91);
1185   2      WriteByte(DRP_ID[2], ETX);
1186   2      WriteByte(DRP_ID[2], 0x6F);
1187   2                      }
1188   1      
1189   1                                              #ifdef  camera_speed
                                                      printf("\r\n Set_Camera_speed=%x",(U16) val);
                                                      #endif  
1192   1      
1193   1      }
1194          
1195          
1196          //-----------------------------------------
1197          void GPIO_check(void)
1198          {
1199   1      U8 GPIO_state,IO_flag=0x10,count=0;
1200   1      
1201   1      GPIO_state=(DVR_GetIO()&0x3f);
1202   1      
1203   1      if(GPIO_current==GPIO_state)
1204   1              return;
1205   1      else    
1206   1      {
1207   2              IO_flag=GPIO_state;
1208   2              while((IO_flag&0x01)!=0)
1209   2              {
1210   3              IO_flag>>=1;
1211   3              count++;
1212   3              }
1213   2      }
1214   1              switch(count)
1215   1                      {
1216   2      
1217   2                      case 0:
1218   2                                      PCON = PCON&0x7f;                               //  smod=0
1219   2                                      TH1 = SET_BAUDRATE(9600,0);     // 22.118M HZ     //remask by ryan.
1220   2                                      break;
1221   2                      case 1: PCON = PCON&0x7f;                               //  smod=0
1222   2                                      TH1 = SET_BAUDRATE(19200,0);    // 22.118M HZ     //remask by ryan.
1223   2                                      break;
1224   2                      case 2:
1225   2                                      PCON =PCON| 0x80;                               //  smod=1
1226   2                                      TH1 = SET_BAUDRATE(38400,1);    // 22.118M HZ     //remask by ryan.
1227   2                                      break;
1228   2                      case 3:
1229   2                                      PCON =PCON| 0x80;                               //smod=1
1230   2                                      TH1 = SET_BAUDRATE(76800,1);    // 22.118M HZ     //remask by ryan.
1231   2                                      break;
C51 COMPILER V9.01   NED                                                                   12/25/2018 16:49:28 PAGE 21  

1232   2                      default:  PCON = PCON&0x7f;                             //  smod=0
1233   2                                      TH1 = SET_BAUDRATE(9600,0);     // 22.118M HZ     //remask by ryan.
1234   2                                      break;
1235   2                      }       
1236   1      
1237   1      
1238   1                              GPIO_current=GPIO_state;
1239   1      
1240   1                              #ifdef  SC16IS750_DEBUG_PRINT 
                                      printf("\r\n GPIO=%x",(U16)GPIO_state);
                                      #endif   
1243   1                              
1244   1      }
1245          
1246          //-----------------------------------------
1247          void Power_onoff(U8 sel)
1248          {
1249   1      
1250   1      Power_EN1=sel;
1251   1      Power_EN2=sel;
1252   1      Power_EN3=sel;
1253   1       Wait_ms(100);
1254   1      
1255   1      //P2_4=1;
1256   1      //P2_7=1;
1257   1      //printf("power on");
1258   1      }
1259          //-----------------------------------------
1260          
1261          U8 SC16_init(void)
1262          {
1263   1      
1264   1      U8 Dev_ID;
1265   1      
1266   1          SC16_RST=0;
1267   1              Wait_ms(20);
1268   1                  SC16_RST=1;
1269   1                      Wait_ms(20);
1270   1      
1271   1        #if 1
1272   1          for(Dev_ID=0;Dev_ID<=2;Dev_ID++)
1273   1          {            
1274   2               ResetDevice(DRP_ID[Dev_ID]);
1275   2                SetBaudrate(DRP_ID[Dev_ID],BaudRate_sel);
1276   2              SetLine(DRP_ID[Dev_ID],8,0,1);
1277   2              WriteI2C(DRP_ID[Dev_ID],FCR , 0x01);   //FIFO mode
1278   2          }
1279   1      #endif
1280   1      
1281   1      #ifdef dvr_parity
                SetLine(DVR_address,8,2,1);  //DVR parity even
              #endif
1284   1      
1285   1              GPIOSetPortMode(DRP_ID[0],0);
1286   1              GPIOSetPortState(DRP_ID[0],0xff)        ;
1287   1      return 1;
1288   1      }
1289          //-----------------------------------------
1290          extern data user_timer[TIMER_NUM];//ryan@20151216
1291          
1292          U8 SC16_SendData(U8 val)
1293          {
C51 COMPILER V9.01   NED                                                                   12/25/2018 16:49:28 PAGE 22  

1294   1      U8 error=0;
1295   1      //U8 Dev_ID=0,Data,Error=FALSE;
1296   1      
1297   1      #ifdef power_startup_check
              
                      if((Com_flag==dvr_com_flag)&&(DVR_startup_flag==1))
                      WriteByte(DRP_ID[0], val);      
                      
                      if((Com_flag==camera_com_flag)&&(Cam_startup_flag==1))
                      WriteByte(DRP_ID[2], val);                                      
                      
              #else
1306   1      
1307   1      WriteByte(DRP_ID[0], val);
1308   1      
1309   1      //if((SC16_Com[1]==0x37)&&((SC16_Com[2]==0x31)|| (SC16_Com[2]==0x34)||(SC16_Com[2]==0x53)||
1310   1      //      (SC16_Com[2]==0x41)||(SC16_Com[2]==0x42)));
1311   1      //else
1312   1      WriteByte(DRP_ID[2], val);
1313   1      
1314   1      //#if 1//ryan@20151216
1315   1      //if(Com_flag==camera_com_flag) user_timer[3]=(40+40);//reset polling timer..
1316   1      
1317   1      
1318   1      #endif
1319   1      
1320   1      //ryan@20150814                 WriteByte(DRP_ID[1], val);
1321   1      
1322   1      //WDTCR|=0x10;
1323   1      return 1;
1324   1      
1325   1      }
1326          //-----------------------------------------
1327          
1328          U8 SC16_SendDataSelect(U8 addr)
1329          {
1330   1      
1331   1      U8 loop=0,Error=0,count=0,data_temp=0;
1332   1      //U8 count2=0,start=0,end=0,loop_flag;
1333   1      U8 buff_flag=1,loop_temp=0;
1334   1      U8 error_flag=1;
1335   1      U8 etx_flag=0;///camera 
1336   1      //data_flag=0;
1337   1      
1338   1      //WDTCR|=0x10;
1339   1      #if 0
              
              while( (ReadI2C(DRP_ID[addr], LSR)&BIT0))
              {
              data_temp=ReadByte(DRP_ID[addr]);
              //SC16_Com[count]=data_temp;
              //count++;
              Error=TRUE;
              
               RS_tx(data_temp); 
              WriteByte(DRP_ID[addr+1],data_temp); 
              WriteByte(DRP_ID[addr+2],data_temp); 
              WDTCR|=0x10;
              }
              
              
              //if( (ReadI2C(DRP_ID[addr], LSR)&BIT1))
C51 COMPILER V9.01   NED                                                                   12/25/2018 16:49:28 PAGE 23  

              
              //}
              #endif
1359   1      
1360   1      #if 1
1361   1      /*
1362   1              if( (ReadI2C(DRP_ID[addr], LSR)&BIT1))
1363   1              {
1364   1              WriteI2C(DRP_ID[addr],FCR,0x03);   //RXFIFO_reset 
1365   1              DELAY_FOR(50);
1366   1              WriteI2C(DRP_ID[addr],FCR,0x01);   //RXFIFO_reset 
1367   1              }
1368   1              else
1369   1                      {
1370   1                      */
1371   1                              if( ReadI2C(DRP_ID[addr], LSR)&BIT0)
1372   1                              {   
1373   2                                      count=ReadI2C(DRP_ID[addr], RXLVL);
1374   2                                      //data_flag=count;
1375   2                                      
1376   2                                               if(count==0) return 0;
1377   2      
1378   2                                              #ifdef  SC16IS750_DEBUG_PRINT 
                                                      printf("\r\n SC16_ID=%x Data=",(U16) DRP_ID[addr]);
                                                      #endif  
1381   2      
1382   2                                              #ifdef  SC16IS750_DEBUG_PRINT 
                                                      printf("\r\n count=%x Data=",(U16) count);
                                                      #endif  
1385   2      
1386   2                                      #ifdef get_data_buff
1387   2      
1388   2                                      data_temp=ReadByte(DRP_ID[addr]);
1389   2      
1390   2                                      if((data_temp==NAK)||(data_temp==ACK))
1391   2                                      {                               
1392   3                                              if((addr==6)&&(data_temp==NAK));
1393   3                                              else
1394   3                                              RS_tx(data_temp); 
1395   3                                              
1396   3                                              #if 0//ryan@20151106^C
                                                      WriteByte(DRP_ID[addr+1],data_temp); 
                                                      WriteByte(DRP_ID[addr+2],data_temp); 
                                                      #endif
1400   3      
1401   3                                              //if(data_temp==NAK) 
1402   3                                                      //printf("(N=%x)",(U16)addr);   
1403   3                                              
1404   3                                              #ifdef  SC16IS750_DEBUG_PRINT 
                                                      printf("sc16_data=%x ",(U16)data_temp);                                 
                                                      #endif                                  
1407   3                                      }
1408   2                                      else if(data_temp==CAM_MOV) return 1;//ryan@20150417
1409   2      //                              else if((data_temp==STX)&&(count>=9))
1410   2                                      else if((data_temp==STX)&&(count>=5))
1411   2                                      {
1412   3      
1413   3                                      SC16_com_buff[0]=data_temp;
1414   3      
1415   3                                              loop=1;
1416   3                                              while((error_flag==1)&&(loop<=7))
1417   3                                              {
C51 COMPILER V9.01   NED                                                                   12/25/2018 16:49:28 PAGE 24  

1418   4                                                      
1419   4                                                      
1420   4                                              SC16_com_buff[loop]=ReadByte(DRP_ID[addr]);
1421   4      
1422   4      
1423   4                                                      #if 1///ryan@20150605
1424   4                                                              if(SC16_com_buff[loop]==ETX&&((SC16_com_buff[1]>=0x52))&&(etx_flag==0)&&(loop<=3)) 
1425   4                                                              {       
1426   5                                                              etx_flag=1;
1427   5                                                              //loop++;
1428   5                                                              //SC16_com_buff[loop]=ReadByte(DRP_ID[addr]);
1429   5                                                              //error_flag=0;//end loop   //ryan@20150420
1430   5                                                              //printf("get first EXT");
1431   5                                                              }
1432   4                                                              else if(SC16_com_buff[loop]==ETX)
1433   4                                                                      {
1434   5                                                                      loop++;
1435   5                                                                      SC16_com_buff[loop]=ReadByte(DRP_ID[addr]);
1436   5                                                                      error_flag=0;///endi loop //ryan@20150420
1437   5                                                                      //printf("get data");
1438   5                                                                      }
1439   4                                                      #else
                                                              if(SC16_com_buff[loop]==ETX) 
                                                              {       
                                                              loop++;
                                                              SC16_com_buff[loop]=ReadByte(DRP_ID[addr]);
                                                              //buff_flag=0;
                                                              error_flag=0;//ryan@20150420
                                                              }
                                                              #endif
1448   4                                                      
1449   4                                              
1450   4                                                      
1451   4                                              loop++;
1452   4                                      
1453   4                                              }
1454   3      
1455   3                                                      //ryan
1456   3                                                      if((SC16_com_buff[1]==0xff)&&(SC16_com_buff[2]==0x92))
1457   3                                                      {
1458   4                                                      //Cam_boot_count_flag++;                                                
1459   4                                                      
1460   4                                                              Cam_boot_flag=1;
1461   4                                                              //printf("\r\nGot Camera ready");
1462   4                                              
1463   4                                                      //WriteByte(DRP_ID[2],0x02); //view com.
1464   4                                                      //WriteByte(DRP_ID[2],0x37); 
1465   4                                                      //WriteByte(DRP_ID[2],0x52); 
1466   4                                                      //WriteByte(DRP_ID[2],0x03); 
1467   4                                                      //WriteByte(DRP_ID[2],0x64); 
1468   4                                                      }
1469   3                                                      
1470   3                                                      loop_temp=loop-1;
1471   3      
1472   3                                                      if((loop_temp<=4)&&(error_flag==0))
1473   3                                                      {
1474   4                                                      
1475   4                                                      //printf("\r\nRecived a command from device1..");
1476   4                                                              for(loop=0;loop<=4;loop++)
1477   4                                                              {
1478   5                                                              //data_temp=ReadByte(DRP_ID[addr]);                     
1479   5                                                              //SC16_Com[count]=ReadByte(DRP_ID[addr]);
C51 COMPILER V9.01   NED                                                                   12/25/2018 16:49:28 PAGE 25  

1480   5                                                              RS_tx(SC16_com_buff[loop]); 
1481   5                                                              #if 0//ryan@20151106^C
                                                                      WriteByte(DRP_ID[addr+1],SC16_com_buff[loop]); 
                                                                      WriteByte(DRP_ID[addr+2],SC16_com_buff[loop]);                          
                                                                      #endif
1485   5                                                              }               
1486   4                                                                      //}
1487   4                                                      return 1;//if buff are error...
1488   4                                                      }
1489   3                                                      else if((loop_temp<=6)&&(error_flag==0))///ryan@20150602
1490   3                                                              {
1491   4      
1492   4                                                              //printf("\r\nRecived a command from device2..");
1493   4                                                              
1494   4                                                              for(loop=0;loop<=6;loop++)
1495   4                                                              {
1496   5                                                              //data_temp=ReadByte(DRP_ID[addr]);                     
1497   5                                                              //SC16_Com[count]=ReadByte(DRP_ID[addr]);
1498   5                                                              RS_tx(SC16_com_buff[loop]); 
1499   5                                                              #if 0//ryan@20151106^C
                                                                      WriteByte(DRP_ID[addr+1],SC16_com_buff[loop]); 
                                                                      WriteByte(DRP_ID[addr+2],SC16_com_buff[loop]);                          
                                                                      #endif
1503   5                                                              }       
1504   4                                                                      return 1;//if buff are error...
1505   4                                                              }
1506   3                                                      
1507   3                                              //else if((SC16_ComCheck(&SC16_com_buff[0])==1)&&(loop>=8)&&(error_flag==0))
1508   3                                                      #if 1//ryan@20150602
1509   3                                                      else if((SC16_ComCheck(&SC16_com_buff[0])==1)&&(error_flag==0))
1510   3                                                      {
1511   4                                                      return 1;
1512   4                                                      }
1513   3                                                      #endif
1514   3                                                      else if(error_flag==0)
1515   3                                                      {
1516   4                                                      //bcc check
1517   4                                                      buff_flag=SC16_com_buff[0];
1518   4                                                              
1519   4                                              for(loop=1;loop<=7;loop++)
1520   4                                                              buff_flag^=SC16_com_buff[loop];
1521   4                                              
1522   4                                                      if(buff_flag==SC16_com_buff[8])
1523   4                                                      {
1524   5                                              //      printf("\r\nRecived a command from device3..");
1525   5                                                      
1526   5                                                              for(loop=0;loop<=loop_temp;loop++)
1527   5                                                              {
1528   6                                                              //data_temp=ReadByte(DRP_ID[addr]);                     
1529   6                                                              //SC16_Com[count]=ReadByte(DRP_ID[addr]);
1530   6                                                              RS_tx(SC16_com_buff[loop]); 
1531   6                                                              #if 0//ryan220151106
                                                                      WriteByte(DRP_ID[addr+1],SC16_com_buff[loop]); 
                                                                      WriteByte(DRP_ID[addr+2],SC16_com_buff[loop]); 
                                                                      #endif
1535   6                                                              #ifdef  SC16IS750_DEBUG_PRINT 
                                                                      printf("%x ",(U16)SC16_com_buff[loop]);                                 
                                                                      #endif          
1538   6                                                              user_timer[3]=200;
1539   6                                                              }
1540   5                                                      }
1541   4                                                      //else                                          
C51 COMPILER V9.01   NED                                                                   12/25/2018 16:49:28 PAGE 26  

1542   4                                                      //printf("ECOM,");
1543   4                                                      
1544   4                                                      return 1;
1545   4                                                      }
1546   3                                                      else
1547   3                                                              return 1;
1548   3                                      }
1549   2                                      else
1550   2                                              {
1551   3                                      //if data isn't NAK or ACK of value that it should be send 1 byte to devices..
1552   3                                                      #if 0
                                                              RS_tx(data_temp); 
                                                              WriteByte(DRP_ID[addr+1],data_temp); 
                                                              WriteByte(DRP_ID[addr+2],data_temp); 
              
                                              //for(loop=1;loop<=(count-1);loop++)
                                                              for(loop=1;loop<=4;loop++)
                                                              {
                                                              data_temp=ReadByte(DRP_ID[addr]);                       
                                                              //SC16_Com[count]=ReadByte(DRP_ID[addr]);
                                                              RS_tx(data_temp); 
                                                              WriteByte(DRP_ID[addr+1],data_temp); 
                                                              WriteByte(DRP_ID[addr+2],data_temp); 
                                              
                                                              #ifdef  SC16IS750_DEBUG_PRINT 
                                                              printf("%x ",(U16)SC16_com_buff[loop]);                                 
                                                              #endif                          
                                                              }               
              
                                                              //EnUserTimer(USERTMID3,40);
                                                              user_timer[3]=200;
                                                              //printf("\r\n count=%x",(U16) count);
              
                                                              #endif
1576   3                                              }
1577   2      
1578   2                                      
1579   2                                      #else   
                                              //printf("\r\nRecived a command from device4..");
                                              for(loop=0;loop<=(count-1);loop++)
                                              {
                                              data_temp=ReadByte(DRP_ID[addr]);
                                              
                                              //SC16_Com[count]=ReadByte(DRP_ID[addr]);
                                              RS_tx(data_temp); 
                                              #if 0//ryan@20151106
                                              WriteByte(DRP_ID[addr+1],data_temp); 
                                              WriteByte(DRP_ID[addr+2],data_temp); 
                                              #endif
                                                      #ifdef  SC16IS750_DEBUG_PRINT 
                                                      printf("%x ",(U16)SC16_Com[loop]);                                      
                                                      #endif  
                                      
                                              }
                                              #endif
1597   2                                      
1598   2                              //count++;
1599   2                              //Error=TRUE;
1600   2                                                      
1601   2                              }
1602   1      
1603   1              //}
C51 COMPILER V9.01   NED                                                                   12/25/2018 16:49:28 PAGE 27  

1604   1      
1605   1      //for(loop=0;loop<=(count-1);loop++) RS_tx(SC16_Com[loop]); 
1606   1      //for(loop=0;loop<=(count-1);loop++) WriteByte(DRP_ID[addr+1],SC16_Com[loop]); 
1607   1      //for(loop=0;loop<=(count-1);loop++) WriteByte(DRP_ID[addr+2],SC16_Com[loop]); 
1608   1                                      
1609   1      #else
              
              /*
                      if( (ReadI2C(DRP_ID[addr], LSR)&BIT1))
                      {
                      WriteI2C(DRP_ID[addr],FCR,0x03);   //RXFIFO_reset 
                      DELAY_FOR(50);
                      WriteI2C(DRP_ID[addr],FCR,0x01);   //RXFIFO_reset 
                      }
                      else
                              {
                              */
                                      while( (ReadI2C(DRP_ID[addr], LSR)&BIT0)&&(count<=17))
                                      {
                                      //data_temp=ReadByte(DRP_ID[addr]);
                                      SC16_Com[count]=ReadByte(DRP_ID[addr]);
                                      count++;
                                      Error=TRUE;
                                      }
              
                      //      }
              
              for(loop=0;loop<=(count-1);loop++) RS_tx(SC16_Com[loop]); 
              for(loop=0;loop<=(count-1);loop++) WriteByte(DRP_ID[addr+1],SC16_Com[loop]); 
              for(loop=0;loop<=(count-1);loop++) WriteByte(DRP_ID[addr+2],SC16_Com[loop]); 
              #endif
1635   1      
1636   1      
1637   1      return 0;
1638   1      
1639   1      }
1640          //----------------------------------------
1641          /*
1642          void Command_Check(U8 val)//ryan@20150417
1643          {
1644          
1645          
1646          }
1647          */
1648          //----------------------------------------
1649          void Repeat_PWM_Com(void)
1650          {
1651   1                                      WriteByte(PIC32_address,SC16_Com[0]); 
1652   1                                      WriteByte(PIC32_address,SC16_Com[1]); 
1653   1                                      WriteByte(PIC32_address,SC16_Com[2]); 
1654   1                                      WriteByte(PIC32_address,SC16_Com[3]); 
1655   1                                      WriteByte(PIC32_address,SC16_Com[4]); 
1656   1      
1657   1                                      //printf("SET_LED");
1658   1      }
1659          
1660          
1661          //-----------------------------------------
1662          U8 SC16_DataCheck(void)
1663          {
1664   1      
1665   1      U8 Dev_ID=0,Error=FALSE,count=0;
C51 COMPILER V9.01   NED                                                                   12/25/2018 16:49:28 PAGE 28  

1666   1      
1667   1                      #if 0
                                          if( (ReadI2C(DRP_ID[0], LSR)&BIT0))
                                              {
                                                     Data=ReadByte(DRP_ID[0]);
                                                      SC16_Com[SC16_ComAddr]=Data;
                                                      #ifdef  SC16IS750_DEBUG_PRINT 
                                                      printf("\r\nSC16_Com[%x]=%x",(U16)SC16_ComAddr,(U16)Data);
                                                      #endif   
              
                                                      SC16_ComAddr++; 
                                                      Error=TRUE;
                                              }
                              //#elif 0
                                      for(Dev_ID=0;Dev_ID<=8;Dev_ID+=3)
                                      {
                                          if( (ReadI2C(DRP_ID[Dev_ID], LSR)&BIT0))
                                              {                                       
                                                      Data=ReadByte(DRP_ID[Dev_ID]);
                                                      WriteByte(DRP_ID[Dev_ID+1], Data);
                                                      WriteByte(DRP_ID[Dev_ID+2], Data);
                                                      RS_tx(Data);
                                                      //if(DRP_ID[Dev_ID]==DVR_address)
                                                              //   SC16_Com[SC16_ComAddr]=Data;                                               
                                                              
                                                      #ifdef  SC16IS750_DEBUG_PRINT 
                                                      printf("\r\nSC16_Com[%x]=%x",(U16)(SC16_ComAddr),(U16)Data);
                                                      #endif   
                                                      //SC16_ComAddr++;
                                                      Error=TRUE;                             
                                              }
                                              
                                              //Dev_ID+=2;
                                      }
                                      
                                 #else
1702   1      
1703   1                                // if( ReadI2C(DRP_ID[0], LSR)&BIT0)  SC16_SendDataSelect(0);
1704   1                                // if( ReadI2C(DRP_ID[3], LSR)&BIT0)  SC16_SendDataSelect(3);
1705   1                               //  if( ReadI2C(DRP_ID[6], LSR)&BIT0)  SC16_SendDataSelect(6);
1706   1      
1707   1                                          #ifdef power_startup_check
                                                      
                                                          if(DVR_startup_flag==TRUE)
                                                          SC16_SendDataSelect(0);
                                                          else
                                                          check_startup(0);           
                              
                                                          if(Cam_startup_flag==TRUE)
                                                          SC16_SendDataSelect(6);
                                                          else
                                                          check_startup(6);           
                                                      
                                              //  #else                       
                                                
                                                  #endif      
1722   1      
1723   1                                      if(work_flag==0)        
1724   1                                              {
1725   2                                                SC16_SendDataSelect(0);
1726   2                                                 //printf("\r\nSC16_SendDataSelect(0);");
1727   2                                                 work_flag=1;
C51 COMPILER V9.01   NED                                                                   12/25/2018 16:49:28 PAGE 29  

1728   2                                              }
1729   1                                      else if(work_flag==1)
1730   1                                              {
1731   2                                          SC16_SendDataSelect(6);   
1732   2                                                // printf("\r\nSC16_SendDataSelect(6);");
1733   2                                              work_flag=0;
1734   2                                              }
1735   1                                      //else if(work_flag==3)
1736   1                                      //      {
1737   1                                        // SC16_SendDataSelect(3);
1738   1                                        // work_flag=0;
1739   1                                              //}
1740   1      
1741   1                              #endif
1742   1      return Error; 
1743   1      }
1744          //----------------------------------------
1745          
1746          void SC16_data_reset(U16 sel)
1747          {
1748   1      /*
1749   1      #define camera_press            BIT1
1750   1      #define _camera_ang             BIT2
1751   1      #define _camera_rang    BIT3
1752   1      #define _camera_IRD0            BIT4
1753   1      #define _camera_IRD1            BIT5
1754   1      #define _camera_IRD2            BIT6
1755   1      #define _camera_IRD3            BIT7
1756   1      #define _camera_IRD4            BIT8
1757   1      #define _camera_IRD5            BIT9
1758   1      #define _camera_IRD6            BIT10
1759   1      #define _dvr_temp                       BIT11
1760   1      */
1761   1      if(SC16_busy_flag&sel) return;
1762   1      
1763   1              switch(sel)
1764   1              {
1765   2                case camera_temp:  Temp_check() ;break;     //0
1766   2                case camera_press:  Press_check() ;break;     
1767   2                case _camera_ang:  Get_Camera_Ang();break;
1768   2                case _camera_rang: Get_Camera_RAng();break;   
1769   2      #if 0//ryan@20151201
              case _camera_IRD0: break;//Get_Camera_IRD(0x41);break;  
                        case _camera_IRD1: break;//Get_Camera_IRD(0x42);break;        
                        case _camera_IRD2: break;//Get_Camera_IRD(0x43);break;        
                        case _camera_IRD3: break;//Get_Camera_IRD(0x44);break;        
                        case _camera_IRD4: break;//Get_Camera_IRD(0x45);break;                ///8
                        case _camera_IRD5: break;//Get_Camera_IRD(0x46);break;                ///9
                        case _camera_IRD6: break;//Get_Camera_IRD(0x47);break;                //10
              #endif
1778   2                case _dvr_temp: Get_DVR_temp();break;                         //11
1779   2              case camera_version: Get_Camera_Ver();break;                            //11    
1780   2                //case camera_version:    
1781   2                //if(SC16_busy_flag&sel) return;
1782   2                //                            SC16_busy_flag|=sel;
1783   2                //                    Get_Camera_Ver(); break;
1784   2      
1785   2              default: break;
1786   2              }
1787   1      
1788   1      //SC16_busy_flag=1;
1789   1      }
C51 COMPILER V9.01   NED                                                                   12/25/2018 16:49:28 PAGE 30  

1790          //---------------------------------------
1791          U8 Camera_move_loop=1;
1792          extern U8 SC16_com_state;//ryan@20151216
1793          void Camera_move(void)
1794          {
1795   1      //static U8 work_flag;
1796   1      U8 mask[4]={0x01,0x02,0x10,0x20};
1797   1      U8 cam[4]={0x31,0x34,0x41,0x42};
1798   1      U8 BCC[4]={0x07,0x02,0x77,0x74};
1799   1      //U8 loop;
1800   1      #if 1//ryan@20151130
1801   1      
1802   1                              if(Camera_move_loop==1)
1803   1                              {
1804   2                                      if((Camera_flag&0x01)==0x01)
1805   2                                      {
1806   3                                      WriteByte(DRP_ID[2],0x02); 
1807   3                                      WriteByte(DRP_ID[2],0x37); 
1808   3                                      WriteByte(DRP_ID[2],0x31); 
1809   3                                      WriteByte(DRP_ID[2],0x03); 
1810   3                                      WriteByte(DRP_ID[2],0x07); 
1811   3                                      SC16_com_state=2;//rang. polling first//ryan@20151214
1812   3                                      }       
1813   2      
1814   2                                      if((Camera_flag&0x02)==0x02)
1815   2                                      {
1816   3                                      WriteByte(DRP_ID[2],0x02); 
1817   3                                      WriteByte(DRP_ID[2],0x37); 
1818   3                                      WriteByte(DRP_ID[2],0x34); 
1819   3                                      WriteByte(DRP_ID[2],0x03); 
1820   3                                      WriteByte(DRP_ID[2],0x02); 
1821   3                                      SC16_com_state=2;//rang. polling first//ryan@20151214
1822   3                                      }       
1823   2                                      Camera_move_loop=0;
1824   2                              }
1825   1                              else
1826   1                              {
1827   2                                      if((Camera_flag&0x10)==0x10)
1828   2                                      {
1829   3                                      WriteByte(DRP_ID[2],0x02); 
1830   3                                      WriteByte(DRP_ID[2],0x37); 
1831   3                                      WriteByte(DRP_ID[2],0x41); 
1832   3                                      WriteByte(DRP_ID[2],0x03); 
1833   3                                      WriteByte(DRP_ID[2],0x77); 
1834   3                                              SC16_com_state=3;//rang. polling first//ryan@20151214
1835   3                                      }       
1836   2      
1837   2                                      if((Camera_flag&0x20)==0x20)
1838   2                                      {
1839   3                                      WriteByte(DRP_ID[2],0x02); 
1840   3                                      WriteByte(DRP_ID[2],0x37); 
1841   3                                      WriteByte(DRP_ID[2],0x42); 
1842   3                                      WriteByte(DRP_ID[2],0x03); 
1843   3                                      WriteByte(DRP_ID[2],0x74); 
1844   3                                              SC16_com_state=3;//rang. polling first//ryan@20151214
1845   3                                      }       
1846   2      
1847   2                                      Camera_move_loop=1;
1848   2                              }
1849   1      #else
                              for(loop=0;loop<4;loop++)
                              {
C51 COMPILER V9.01   NED                                                                   12/25/2018 16:49:28 PAGE 31  

                                              if((Camera_flag&mask[loop])>=1)
                                              {
                                              WriteByte(DRP_ID[2],0x02); 
                                              WriteByte(DRP_ID[2],0x37); 
                                              WriteByte(DRP_ID[2],cam[loop]); 
                                              WriteByte(DRP_ID[2],0x03); 
                                              WriteByte(DRP_ID[2],BCC[loop]); 
                                              }       
                              }
              #endif
1862   1                      
1863   1      }
1864          
1865          //----------------------------------------
1866          #if 0
              void check_startup(U8 addr)
              {
              
              U8 loop=0,Error=FALSE,count=0,data_temp=0;
              
              
                                      if( ReadI2C(DRP_ID[addr], LSR)&BIT0)
                                      {   
                                              count=ReadI2C(DRP_ID[addr], RXLVL);
                                              
                                                       if((count==0)||(count<=5)) return;
                                                       
                                                      //#ifdef  SC16IS750_DEBUG_PRINT 
                                                      //printf("\r\n SC16_ID=%x Data=",(U16) DRP_ID[addr]);
                                                      //#endif  
                                                      //#ifdef  SC16IS750_DEBUG_PRINT 
                                                      //printf("\r\n count=%x Data=",(U16) count);
                                                      //#endif  
              
                                              for(loop=0;loop<=(count-1);loop++)
                                              {
                                              data_temp=ReadByte(DRP_ID[addr]);
              
                                                      if(addr==0)
                                                      {
                                                         if(DVR_Com[loop]!=data_temp) return;
                                                         Error++;
                                                              if(Error>=5) DVR_startup_flag=1;
                                                                      #ifdef  SC16IS750_DEBUG_PRINT 
                                                                      printf("\r\nDVR_startup=OK");                                   
                                                                      #endif 
                                                      }
                                                      else if(addr==6)
                                                      {
                                                         if(Cam_Com[loop]!=data_temp) return;
                                                         Error++;
                                                              if(Error>=5) Cam_startup_flag=1;
                                                                      #ifdef  SC16IS750_DEBUG_PRINT 
                                                                      printf("\r\nCamera_startup=OK");                                        
                                                                      #endif                                                  
                                                      }
              
                                      
                                              }
                                                              
                                      }
              
C51 COMPILER V9.01   NED                                                                   12/25/2018 16:49:28 PAGE 32  

              
              }
              #endif
1917          //-----------------------------------------
1918          //reset sc16 data
1919          //-----------------------------------------
1920          U8 SC16_ComCheck(U8 *addr)
1921          {
1922   1      
1923   1      //if(*addr!=0x02) return 0;
1924   1      U8 pos=0,temp=0;
1925   1      addr++;
1926   1       switch(*addr)
1927   1              {
1928   2                      case 0x32: 
1929   2                              addr++;
1930   2                              if(*addr==0x34)
1931   2                              {
1932   3                              addr++;
1933   3                              Camera_Ang[3]=*addr;
1934   3                              addr++;                                         
1935   3                              Camera_Ang[2]=*addr;
1936   3                              addr++;                                                                                         
1937   3                              Camera_Ang[1]=*addr;
1938   3                              addr++;                                                                                         
1939   3                              Camera_Ang[0]=*addr;                    
1940   3                              SC16_busy_flag&=~(_camera_ang);
1941   3                             return 1;
1942   3                              }                                       
1943   2                              else if(*addr==0x35)
1944   2                                      {
1945   3                                      addr++;
1946   3                                      Camera_RAng[3]=*addr;
1947   3                                      addr++;                                         
1948   3                                      Camera_RAng[2]=*addr;
1949   3                                      addr++;                                                                                         
1950   3                                      Camera_RAng[1]=*addr;
1951   3                                      addr++;                                                                                         
1952   3                                      Camera_RAng[0]=*addr;                   
1953   3                                      SC16_busy_flag&=~(_camera_rang);
1954   3                                       return 1;
1955   3                                      }
1956   2                              #if 0//ryan@20151106
                                      else if((*addr>=0x41)&&(*addr<=0x47))
                                              {
                                              pos=*addr;
                                              pos-=0x41;                              
                                              temp=pos*4;
                                              addr++;
                                              Camera_IRDA[temp+3]=*addr;
                                              addr++;                                         
                                              Camera_IRDA[temp+2]=*addr;
                                              addr++;                                                                                         
                                              Camera_IRDA[temp+1]=*addr;
                                              addr++;                                                                                         
                                              Camera_IRDA[temp+0]=*addr;                      
                                              SC16_busy_flag&=~(_camera_IRD0<<pos);
                                               return 1;
                                              }
                                      #endif
1974   2                                      else  if(*addr==0x4f)
1975   2                                                      {
C51 COMPILER V9.01   NED                                                                   12/25/2018 16:49:28 PAGE 33  

1976   3                                                      addr++;
1977   3                                                      Camera_ver0=*addr;
1978   3                                                      addr++;                                         
1979   3                                                      Camera_ver1=*addr;
1980   3                                                      addr++;                                                                                         
1981   3                                                      Camera_ver2=*addr;
1982   3                                                      SC16_busy_flag&=~(camera_version);
1983   3                                                        return 1;
1984   3                                                      }       
1985   2                                      
1986   2                              
1987   2                              break;
1988   2                      case 0x34: 
1989   2                                                      addr++;
1990   2                                                      if(*addr==0x31)
1991   2                                                      {
1992   3                                                      addr++;
1993   3                                                      DVR_temp[1]=*addr;
1994   3                                                      addr++;                                         
1995   3                                                      DVR_temp[0]=*addr;
1996   3                                                      SC16_busy_flag&=~(_dvr_temp);
1997   3                                                      return 1;
1998   3                                                      }
1999   2                                                      break;
2000   2                      
2001   2                      //case camera_temp:  Temp_check() ;break;
2002   2                      //case camera_press:  Press_check() ;break;         
2003   2                      /*
2004   2                      case 0x32: 
2005   2                                                      addr++;
2006   2                                                      if(*addr==0x4f)
2007   2                                                      {
2008   2                                                      addr++;
2009   2                                                      Camera_ver0=*addr;
2010   2                                                      addr++;                                         
2011   2                                                      Camera_ver1=*addr;
2012   2                                                      addr++;                                                                                         
2013   2                                                      Camera_ver2=*addr;
2014   2                                                      SC16_busy_flag&=~(camera_version);
2015   2                                                        return 1;
2016   2                                                      }                                                               
2017   2                                                      break;
2018   2                                      */
2019   2                      default:  //printf("\r\n not megawin com");     
2020   2                                                      return 0;
2021   2                                                                      break;
2022   2              }
2023   1              
2024   1      return 0;
2025   1              
2026   1              //if(SC16_ComAddr>=(num-1))
2027   1              //{             
2028   1              //      if((SC16_Com[0]==STX)&&(SC16_BCC_Check(&SC16_Com[0],(num-1))))
2029   1              //      {
2030   1              //              switch(SC16_Com[1])
2031   1              //                      {
2032   1              //                              case Monitor_Com:
2033   1              //                                                              Monitor_set(SC16_Com[2]);       
2034   1              //                                                           break;
2035   1              //                              case PWM_Com:
2036   1              //                                                              PWM_set(SC16_Com[2]);
2037   1              //                                                           break;                                                                              
C51 COMPILER V9.01   NED                                                                   12/25/2018 16:49:28 PAGE 34  

2038   1              //                              default:                     break;
2039   1              //      
2040   1              //                      }
2041   1              //              return TRUE;
2042   1              //      }       
2043   1            //}
2044   1      
2045   1                                              //#ifdef get_data_buff 
2046   1                                              //printf("\r\n Got data from the sc16");                                        
2047   1                                              //#endif 
2048   1               
2049   1           
2050   1      }
2051          
2052          //----------------------------------------
2053          
2054          U8 BCC_Cal(U8 *addr,U8 count)
2055          {
2056   1              U8 f_val=0;
2057   1              U8 s_val=0;
2058   1              U8 loop=0;
2059   1              count--;
2060   1      
2061   1      for(loop=0;loop<=count;loop++)
2062   1      {
2063   2        // f_val=*addr;  
2064   2         
2065   2         f_val^=*addr;  
2066   2        addr++;    
2067   2      }
2068   1      return f_val;
2069   1      
2070   1      /*
2071   1         f_val=*addr;  //XOR 0-3  //0
2072   1         addr++;            ///1
2073   1         //com[0]=*addr;   
2074   1         f_val^=*addr;    
2075   1         addr++;          ///2
2076   1         //com[1]=*addr;
2077   1         f_val^=*addr;    
2078   1         addr++;    ///3
2079   1         f_val^=*addr;
2080   1         //addr++;
2081   1      
2082   1      if(count==8)
2083   1              {
2084   1       addr++;    ///4
2085   1         f_val^=*addr;
2086   1       addr++;    ///5
2087   1         f_val^=*addr;
2088   1       addr++;    ///6
2089   1         f_val^=*addr;
2090   1       addr++;    ///7
2091   1         f_val^=*addr;
2092   1        
2093   1              }
2094   1      
2095   1         addr++;
2096   1      
2097   1      //if(f_val==*addr)
2098   1              return f_val;
2099   1      */
C51 COMPILER V9.01   NED                                                                   12/25/2018 16:49:28 PAGE 35  

2100   1      }
2101          //----------------------------------------
2102          #if 0
              void Get_Data(U8 addr,U8 val)
              {
              
              switch(addr)
              {
              case 1: Send_Camera_Temp();  get_data_addr=0;break; ///1
              case 2: Send_Camera_Press();get_data_addr=0;    break;  ///2
              case 3: Sent_Camera_Ang(); get_data_addr=0;break; //camera angle.///3
              case 4:         Sent_Camera_RAng(); get_data_addr=0;break; //camera Rangle.///4
              case 5: Sent_Camera_IRD(val);get_data_addr=0;get_data_val=0;break;  //camera IRD.///5   
              case 6: Sent_DVR_temp();get_data_addr=0;break;  //DVR_tempe.///6
              case 7: Version_check();  get_data_addr=0;break;                ///megawin cpu version  ///7
              case 8: Camera_Version_check();  get_data_addr=0;break;         ///megawin cpu version  ///7
              }
              get_data_addr=0;
              get_data_val=0;
              }
              #endif
2121          //----------------------------------------
2122          extern U16 timerout4;
2123          extern U16 timerout3;
2124          extern U8  CB_flag;
2125          //#define get_delay 15-10
2126          #define get_delay 50
2127          U8 SC16_BCC_Check(U8 *addr )
2128          {
2129   1              U8 loop;
2130   1              U8 f_val=0;
2131   1              U8 s_val=0;
2132   1         U8  com[3]; 
2133   1      
2134   1      #ifdef BCC_noSTXEXT           
                 addr++;       //XOR 1-2
                 f_val=*addr;
                 com[0]=*addr;
                 addr++;
                 f_val^=*addr;
                 com[1]=*addr;
                 addr++;
              
              #else
2144   1         f_val=*addr;  //XOR 0-3  //0
2145   1         addr++;            ///1
2146   1         com[0]=*addr;   
2147   1         f_val^=*addr;    
2148   1         addr++;          ///2
2149   1         com[1]=*addr;
2150   1         f_val^=*addr;    
2151   1         addr++;    ///3
2152   1         com[2]=*addr;  
2153   1         f_val^=*addr;
2154   1         //addr++;
2155   1      
2156   1      if(Com_pos==6)//ryan@20150602
2157   1      {
2158   2       addr++;    ///4
2159   2         f_val^=*addr;
2160   2       addr++;    ///5
2161   2         f_val^=*addr;
C51 COMPILER V9.01   NED                                                                   12/25/2018 16:49:28 PAGE 36  

2162   2      }else if(Com_pos==8)
2163   1              {
2164   2       addr++;    ///4
2165   2         f_val^=*addr;
2166   2       addr++;    ///5
2167   2         f_val^=*addr;
2168   2       addr++;    ///6
2169   2         f_val^=*addr;
2170   2       addr++;    ///7
2171   2         f_val^=*addr;
2172   2        
2173   2              }
2174   1         #endif
2175   1         addr++;
2176   1      
2177   1                      
2178   1      
2179   1                                                                              
2180   1                      if(f_val==*addr)        
2181   1                      {
2182   2                               if((com[0]==0x37)&&((com[1]>=0x4a&&com[1]<=0x4f)||(com[1]==0x54)||(com[1]==0x55)))
2183   2                              {
2184   3                                       RS_tx(STX);
2185   3                                       RS_tx(com[0]);
2186   3                                       RS_tx(com[1]);                                                          
2187   3                                       RS_tx(ETX);
2188   3                                       RS_tx(f_val);  
2189   3      
2190   3                                      #if 1//ryan@20150706 feeback pip of data to camera
2191   3                      
2192   3                                      if(Cam_boot_flag==1)    
2193   3                                      {
2194   4                                      WriteByte(PIC32_address,STX); 
2195   4                                      WriteByte(PIC32_address,com[0]); 
2196   4                                      WriteByte(PIC32_address,com[1]); 
2197   4                                      WriteByte(PIC32_address,ETX); 
2198   4                                      WriteByte(PIC32_address,f_val); 
2199   4                                      }
2200   3                                      
2201   3                                       #endif
2202   3                              }   
2203   2                               else if(com[0]==0x38&&com[1]>=0x3d&&com[1]<=0x60)
2204   2                                      {
2205   3                                       RS_tx(ACK);
2206   3                                      }       
2207   2                               #if 1//ryan@20150814
2208   2                                              else if((com[0]==0x31)&&(com[1]==0x31)) 
2209   2                                                      {
2210   3                                                      Send_Camera_Temp();
2211   3                                                      //timerout3+=timerout4;
2212   3                                                      //CB_flag=1;    ///timerout3=get_delay;
2213   3                                                      //get_data_addr=1;/// Send_Camera_Temp();               ///1    
2214   3                                                      }
2215   2                                              else if(com[0]==0x31&&(com[1]==0x33))   
2216   2                                                              {
2217   3                                                              Send_Camera_Press();
2218   3                                                              //timerout3+=timerout4;
2219   3                                                              //CB_flag=1;//timerout3=get_delay;
2220   3                                                              //get_data_addr=2; ///Send_Camera_Press();              ///2    
2221   3                                                      }
2222   2                                              else if(com[0]==0x31&&(com[1]==0x34))
2223   2                                                              {
C51 COMPILER V9.01   NED                                                                   12/25/2018 16:49:28 PAGE 37  

2224   3                                                              Sent_Camera_Ang();
2225   3                                                              //timerout3+=timerout4;
2226   3                                                              //CB_flag=1;//timerout3=get_delay;
2227   3                                                              //get_data_addr=3;///    Sent_Camera_Ang(); //camera angle.///3 
2228   3                                                              }
2229   2                                              else if(com[0]==0x31&&(com[1]==0x35))
2230   2                                                              {
2231   3                                                              Sent_Camera_RAng();
2232   3                                                              //timerout3+=timerout4;
2233   3                                                              //CB_flag=1;//timerout3=get_delay;
2234   3                                                              //get_data_addr=4;      /// Sent_Camera_RAng();  //camera Rangle.///4
2235   3                                                              }
2236   2                                              #if 1//not check IRD
2237   2                                              else if(com[0]==0x31&&com[1]>=0x41&&com[1]<=0x47) 
2238   2                                                      {
2239   3                                                      Sent_Camera_IRD(0);
2240   3                                                      //timerout3+=timerout4;
2241   3                                                      //CB_flag=1;//timerout3=get_delay;
2242   3                                                      //get_data_addr=5;      ///Sent_Camera_IRD(com[1]);  //camera IRD.///5  
2243   3                                                      //get_data_val=com[1];
2244   3                                                      }
2245   2                                              #endif
2246   2                                              else if(com[0]==0x33&&(com[1]==0x31))
2247   2                                                              {
2248   3                                                              Sent_DVR_temp();
2249   3                                                              //timerout3+=timerout4;
2250   3                                                              //CB_flag=1;//timerout3=get_delay;
2251   3                                                              //get_data_addr=6;/// Sent_DVR_temp();  //DVR_tempe.///6
2252   3                                                      }
2253   2                                              else if(com[0]==0x31&&com[1]==0x50) 
2254   2                                                              {
2255   3                                                              Version_check();
2256   3                                                              //timerout3+=timerout4;
2257   3                                                              //CB_flag=1;//timerout3=get_delay;
2258   3                                                              //get_data_addr=7;//// Version_check();                 ///megawin cpu version  ///7    
2259   3                                                              }
2260   2                                              else if(com[0]==0x31&&com[1]==0x4f) //Send_Camera_Ver();
2261   2                                                      {
2262   3                                                      Camera_Version_check();
2263   3                                                      //timerout3+=timerout4; 
2264   3                                                      //CB_flag=1;//timerout3=get_delay;
2265   3                                                      //get_data_addr=8;//// Version_check();                 ///PIC cpu s/w version  ///8
2266   3                                                      }
2267   2                               #else
                                                      else if((com[0]==0x31)&&(com[1]==0x31)) Send_Camera_Temp();             ///1                  
                                                      else if(com[0]==0x31&&(com[1]==0x33))    Send_Camera_Press();           ///2
                                                      #if 1//ryan@20150804
                                                      else if(com[0]==0x31&&(com[1]==0x34))    Sent_Camera_Ang(); //camera angle.///3
                                                      else if(com[0]==0x31&&(com[1]==0x35))    Sent_Camera_RAng();  //camera Rangle.///4
                                                      else if(com[0]==0x31&&com[1]>=0x41&&com[1]<=0x47)       Sent_Camera_IRD(com[1]);  //camera IRD.///5     
                                                      else if(com[0]==0x33&&(com[1]==0x31))    Sent_DVR_temp();  //DVR_tempe.///6
                                                      #endif
                                                      else if(com[0]==0x31&&com[1]==0x50)  Version_check();           ///megawin cpu version  ///7                    
                                                      //else if(com[0]==0x31&&com[1]==0x4f) Send_Camera_Ver();
                                              #endif
2279   2                                                                      else 
2280   2                                                                      {                                                               
2281   3      
2282   3                      
2283   3                                                                              
2284   3                                                                              #if 1//ryan@20150602
2285   3                                                                              ///check all of command
C51 COMPILER V9.01   NED                                                                   12/25/2018 16:49:28 PAGE 38  

2286   3                                                                              if(Check_other_Com())
2287   3                                                                              {
2288   4                                                                              
2289   4                                                                              for(loop=0;loop<=Com_pos;loop++)                        
2290   4                                                                              SC16_SendData(SC16_Com[loop]); 
2291   4      
2292   4                                                                              user_timer[5]=4;//ryan@20151130
2293   4                                                                              user_timer[3]=(20);//reset polling time..
2294   4                                                                              
2295   4                                                                              //printf("\r\n Sent COM to Camera");//ryan@20150908
2296   4                                                                              #ifdef power_startup_check
                                                                                      if((Com_flag==dvr_com_flag)&&(DVR_startup_flag==0))
                                                                                      RS_tx(NAK);
              
                                                                                      if((Com_flag==camera_com_flag)&&(Cam_startup_flag==0))
                                                                                      RS_tx(NAK);
                                                                                      #endif
2303   4                                                                              
2304   4                                                                              }
2305   3                                                                              else
2306   3                                                                                      {
2307   4                                                                                      RS_tx(NAK);
2308   4                                                                                      #ifdef  SC16IS750_DEBUG_PRINT 
                                                                                              printf("\r\nCommand_Check fail");
                                                                                              #endif          
2311   4                      
2312   4                                                                                      }
2313   3                                                                              #endif
2314   3                                                                              
2315   3                                                                      return FALSE;
2316   3                                                                      }
2317   2                                                              
2318   2                              #ifdef  SC16IS750_DEBUG_PRINT 
                                      printf("\r\nSC16_BCC_Check pass");
                                      #endif
2321   2                              return TRUE;
2322   2                                                      
2323   2                      }
2324   1                      else
2325   1                      {
2326   2                              RS_tx(NAK);
2327   2                              #ifdef  SC16IS750_DEBUG_PRINT 
                                      printf("\r\nSC16_BCC_Check fail");
                                      #endif          
2330   2                            return FALSE;
2331   2                      }
2332   1      
2333   1                      
2334   1                      
2335   1      }
2336          
2337          //-----------------------------------------
2338          
2339          U8 Check_other_Com(void)
2340          {
2341   1      
2342   1      if((SC16_Com[1]==0xff)){ //ryan@20150415
2343   2              Com_flag=camera_com_flag;  
2344   2              return TRUE;
2345   2      }
2346   1      
2347   1      //02,37,53,03,65, Camera Stop cammand..
C51 COMPILER V9.01   NED                                                                   12/25/2018 16:49:28 PAGE 39  

2348   1      
2349   1      if((SC16_Com[1]==0x37)&&((SC16_Com[2]==0x31)||(SC16_Com[2]==0x34)||(SC16_Com[2]==0x53))){
2350   2      
2351   2                      if(SC16_Com[2]==0x31) //ryan@20150416
2352   2                              {
2353   3                              Camera_flag=((Camera_flag&0x30)|0x01);//set/clear  up move
2354   3                              RS_tx(ACK);
2355   3                              }
2356   2                      else if(SC16_Com[2]==0x34)
2357   2                              {
2358   3                              Camera_flag=((Camera_flag&0x30)|0x02);//set/clear down move
2359   3                              RS_tx(ACK);                     
2360   3                              }
2361   2                      else
2362   2                              Camera_flag=0x00; //clear all move
2363   2      
2364   2                      
2365   2              Com_flag=camera_com_flag;  
2366   2              return TRUE;
2367   2      }
2368   1      
2369   1      if((SC16_Com[1]==0x37)&&(SC16_Com[2]>=0x41)&&(SC16_Com[2]<=0x47)) {
2370   2      
2371   2                      if(SC16_Com[2]==0x41)//ryan@20150416
2372   2                              {
2373   3                              Camera_flag=((Camera_flag&0x03)|0x10);//set/clear CCW move
2374   3                              RS_tx(ACK);
2375   3                              }
2376   2                      else if(SC16_Com[2]==0x42)
2377   2                              {
2378   3                              Camera_flag=((Camera_flag&0x03)|0x20);//set/clear CW move
2379   3                              RS_tx(ACK);
2380   3                              }
2381   2      
2382   2                              
2383   2              Com_flag=camera_com_flag;  
2384   2              return TRUE;
2385   2      }
2386   1      
2387   1      if((SC16_Com[1]==0x31)&&(SC16_Com[2]>=0x57&&SC16_Com[2]<=0x5c))
2388   1                              {
2389   2                              RS_tx(ACK);
2390   2                              Set_Video((SC16_Com[2]-0x57),SC16_Com[3]);//for TW2835 video set
2391   2                              return TRUE;
2392   2                              }
2393   1      
2394   1      
2395   1      
2396   1      return TRUE;//ryan@21050602
2397   1      
2398   1      if((SC16_Com[1]==0x37)&&(SC16_Com[2]>=0x50)&&(SC16_Com[2]<=0x52)) {
2399   2              Com_flag=dvr_com_flag;  
2400   2              return TRUE;
2401   2      }
2402   1      
2403   1      if((SC16_Com[1]==0x38)&&(SC16_Com[2]>=0x31)&&(SC16_Com[2]<=0x3c)) {
2404   2              Com_flag=camera_com_flag;  
2405   2              return TRUE;
2406   2      }
2407   1      
2408   1      if((SC16_Com[1]==0x31)&&((SC16_Com[2]==0x34)||(SC16_Com[2]==0x35))){
2409   2              Com_flag=camera_com_flag;  
C51 COMPILER V9.01   NED                                                                   12/25/2018 16:49:28 PAGE 40  

2410   2              return TRUE;
2411   2      }
2412   1      
2413   1      if((SC16_Com[1]==0x31)&&(SC16_Com[2]>=0x41)&&(SC16_Com[2]<=0x47))  {
2414   2              Com_flag=camera_com_flag;       
2415   2              return TRUE;
2416   2      }
2417   1      if((SC16_Com[1]==0x31)&&(SC16_Com[2]>=0x4f)&&(SC16_Com[2]<=0x53)) {
2418   2              Com_flag=camera_com_flag;               
2419   2              return TRUE;
2420   2      }
2421   1      
2422   1      
2423   1      if((SC16_Com[1]==0x33)&&((SC16_Com[2]==0x31)||(SC16_Com[2]==0x4f))) {
2424   2              Com_flag=dvr_com_flag;                  
2425   2              return TRUE;
2426   2      }
2427   1      
2428   1      if((SC16_Com[1]==0x33)&&(SC16_Com[2]>=0x35)&&(SC16_Com[2]<=0x37)) {
2429   2              Com_flag=dvr_com_flag;                  
2430   2              return TRUE;
2431   2      }
2432   1      
2433   1      #if 1//ryan@20151210
2434   1      if((SC16_Com[1]==0x33)&&(SC16_Com[2]>=0x51)&&(SC16_Com[2]<=0x5b)){
2435   2              Com_flag=dvr_com_flag;                  
2436   2              return TRUE;
2437   2      }
2438   1      
2439   1      if((SC16_Com[1]==0x33)&&((SC16_Com[2]>=0x5c)||(SC16_Com[2]==0x61))){
2440   2              Com_flag=camera_com_flag;               
2441   2              return TRUE;
2442   2      }
2443   1      
2444   1      #else
              if((SC16_Com[1]==0x33)&&(SC16_Com[2]>=0x51)&&(SC16_Com[2]<=0x53)){
                      Com_flag=dvr_com_flag;                  
                      return TRUE;
              }
              
              if((SC16_Com[1]==0x33)&&((SC16_Com[2]==0x5c)||(SC16_Com[2]==0x5d))){
                      Com_flag=camera_com_flag;               
                      return TRUE;
              }
              #endif
2455   1      //if((SC16_Com[1]==0x32)&&((SC16_Com[2]==0x31)||(SC16_Com[2]==0x4f))) {
2456   1      //      Com_flag=dvr_com_flag;                  
2457   1      //      return TRUE;
2458   1      //}
2459   1      //if((SC16_Com[1]==0x32)&&(SC16_Com[2]>=0x33)&&(SC16_Com[2]<=0x35)) return TRUE;
2460   1      //if((SC16_Com[1]==0x32)&&(SC16_Com[2]>=0x41)&&(SC16_Com[2]<=0x47)) return TRUE;
2461   1      
2462   1      
2463   1      if((SC16_Com[1]==0x37)&&(SC16_Com[2]>=0x50)&&(SC16_Com[2]<=0x52)){
2464   2              Com_flag=dvr_com_flag;                  
2465   2              return TRUE;
2466   2      }
2467   1      
2468   1      
2469   1      return FALSE;
2470   1      
2471   1      }
C51 COMPILER V9.01   NED                                                                   12/25/2018 16:49:28 PAGE 41  

2472          
2473          //----------------------------------------
2474          #if 0
              U8 parity(U8 ino)
              {
                      U8 noofones = 0;
              //      unsigned long mask = 0x00000001ul; /* start at first bit */
              
                      U8 mask = 0x01; /* start at first bit */
              
                      while(mask != 0) /* until all bits tested */
                      {
                              if(mask & ino) /* if bit is 1, increment noofones */
                              {
                                      noofones++;
                              }
                              mask = mask << 1; /* go to next bit */
                      }
              
                      /* if noofones is odd, least significant bit will be 1 */
                      return (noofones & 1); 
              
              
              }
              #endif
2497          //-----------------------------------------
2498          //U8 Com_check(U8 com,U8 start, U8 count)
2499          //{
2500            
2501          
2502          //}
2503          
2504          //-----------------------------------------
2505          #if 0
              U8 ADT75_init(void)
              {
              
              U8 Ctemp=0;
              U16 Dtemp=0;
              
              //ADT75_SetCon(0x55);
              //Dtemp=ADT75_GetTemp();
              //Ctemp=ADT75_GetCon();
              ADT75_SetThyst(0x4420);
              ADT75_SetTOs(0x5220);
              ADT75_SetCon(0x02);
              
              
              #ifdef  ADT75_Debug
              Printf("GetThyst=%X",(U16)ADT75_GetThyst());
              Printf(" GetTOs=%X  ",(U16)ADT75_GetTOs());
              Printf(" GetCon=%X  ",(U16)ADT75_GetCon());
                  Printf("GetTemp=%X degree\r\n",(U16)((ADT75_GetTemp()>>4)/16));
               //   Printf("ADT75_GetCon=%X\r\n", ADT75_GetCon());
              #endif   
              
              
              return 1;
              
              }
              #endif
2533          //-----------------------------------------
C51 COMPILER V9.01   NED                                                                   12/25/2018 16:49:28 PAGE 42  

2534          
2535          void ResetDevice(U8 addr)
2536          {
2537   1       register   U8 temp;
2538   1          temp = ReadI2C(addr, IOContro);
2539   1          temp |= 0x08;
2540   1           WriteI2C(addr, IOContro, temp);
2541   1            
2542   1      //    WriteRegister(SC16IS750_REG_IOCONTROL, temp_iocontrol);   
2543   1      //    temp_iocontrol = ReadRegister(SC16IS750_REG_IOCONTROL);
2544   1      //    temp_iocontrol |= 0x08;
2545   1      //    WriteRegister(SC16IS750_REG_IOCONTROL, temp_iocontrol); 
2546   1          
2547   1        //  return; 
2548   1      }
2549          //-----------------------------------------
2550          U16 SetBaudrate(U8 addr, U32 baudrate) //return error of baudrate parts per thousand
2551          {
2552   1      
2553   1      //register   U16 divisor;
2554   1       U32 divisor;
2555   1      
2556   1       U8 prescaler;
2557   1       U8 temp_lcr;//,temp_mcr;
2558   1         
2559   1         // uint32_t actual_baudrate;
2560   1         //  int16_t error;
2561   1          //uint16_t divisor;
2562   1         // uint8_t prescaler;
2563   1         // uint32_t actual_baudrate;
2564   1        //  int16_t error;
2565   1         // uint8_t temp_lcr;
2566   1      
2567   1          if ( (ReadI2C(addr,MCR)&0x80) == 0) { //if prescaler==1
2568   2              prescaler = 1;
2569   2          } else {
2570   2              prescaler = 4;
2571   2          }
2572   1      
2573   1              //baudrate=9600;
2574   1      
2575   1         divisor = (SC16IS750_CRYSTCAL_FREQ/prescaler)/(baudrate*16);
2576   1      
2577   1      
2578   1      
2579   1      #ifdef SC16IS750_DEBUG_PRINT
              Printf("\r\n");
              Printf("SetBaudrate_Dev_addr=%x\r\n",(U16) addr);
              Printf("SetBaudrate_MCR=%x\r\n",(U16) ReadI2C(addr,MCR));
              Printf("SetBaudrate_prescaler=%x\r\n",(U16) prescaler);
              Printf("SetBaudrate_divisor=%x\r\n",(U16) divisor);
              #endif 
2586   1                      
2587   1              WriteI2C(addr, LCR, 0x00); /// WriteRegister(SC16IS750_REG_LCR,temp_lcr); 
2588   1      
2589   1          temp_lcr = ReadI2C(addr,LCR); ///ReadRegister(SC16IS750_REG_LCR);
2590   1              
2591   1          temp_lcr |= 0x80;
2592   1              
2593   1          WriteI2C(addr, LCR, temp_lcr); /// WriteRegister(SC16IS750_REG_LCR,temp_lcr); 
2594   1          //write to DLL
2595   1           WriteI2C(addr, DLL, (U8)divisor); ///WriteRegister(SC16IS750_REG_DLL,(uint8_t)divisor);
C51 COMPILER V9.01   NED                                                                   12/25/2018 16:49:28 PAGE 43  

2596   1          //write to DLH
2597   1            WriteI2C(addr, DLH, (U8)(divisor>>8)); /// WriteRegister(SC16IS750_REG_DLH,(uint8_t)(divisor>>8));
2598   1      
2599   1      #ifdef SC16IS750_DEBUG_PRINT
              Printf("SetBaudrate_DLL=%x\r\n",(U16) ReadI2C(addr,DLL));
              Printf("SetBaudrate_DLH=%x\r\n",(U16) ReadI2C(addr,DLH));
              #endif 
2603   1      
2604   1          temp_lcr &= 0x7F;
2605   1         WriteI2C(addr, LCR, temp_lcr); ///WriteRegister(SC16IS750_REG_LCR,temp_lcr); 
2606   1      
2607   1      return 1;
2608   1         /* 
2609   1          actual_baudrate = (SC16IS750_CRYSTCAL_FREQ/prescaler)/(16*divisor);
2610   1          error = ((float)actual_baudrate-baudrate)*1000/baudrate;
2611   1      #ifdef  SC16IS750_DEBUG_PRINT   
2612   1          Serial.print("Desired baudrate: ");
2613   1          Serial.println(baudrate,DEC);
2614   1          Serial.print("Calculated divisor: ");
2615   1          Serial.println(divisor,DEC);
2616   1          Serial.print("Actual baudrate: ");
2617   1          Serial.println(actual_baudrate,DEC);    
2618   1          Serial.print("Baudrate error: ");
2619   1          Serial.println(error,DEC);    
2620   1      #endif     
2621   1          
2622   1          return error;
2623   1       */
2624   1      }
2625          //-----------------------------------------
2626          void SetLine(U8 addr, U8 data_length, U8  parity_select, U8  stop_length )
2627          {
2628   1          U8 temp_lcr;
2629   1          temp_lcr = ReadI2C(addr,LCR); ///ReadRegister(SC16IS750_REG_LCR);
2630   1          temp_lcr &= 0xC0; //Clear the lower six bit of LCR (LCR[0] to LCR[5]
2631   1      //#ifdef  SC16IS750_DEBUG_PRINT 
2632   1      //    Serial.print("LCR Register:0x");
2633   1      //    Serial.println(temp_lcr,DEC);
2634   1      //#endif   
2635   1          switch (data_length) {            //data length settings
2636   2              case 5:
2637   2                  break;
2638   2              case 6:
2639   2                  temp_lcr |= 0x01;
2640   2                  break;
2641   2              case 7:
2642   2                  temp_lcr |= 0x02;
2643   2                  break;
2644   2              case 8:
2645   2                  temp_lcr |= 0x03;
2646   2                  break;
2647   2              default:
2648   2                  temp_lcr |= 0x03;
2649   2                  break;
2650   2          }
2651   1      
2652   1          if ( stop_length == 2 ) {
2653   2              temp_lcr |= 0x04;
2654   2          }
2655   1          
2656   1          switch (parity_select) {            //parity selection length settings
2657   2              case 0:                         //no parity
C51 COMPILER V9.01   NED                                                                   12/25/2018 16:49:28 PAGE 44  

2658   2                   break;
2659   2              case 1:                         //odd parity
2660   2                  temp_lcr |= 0x08;
2661   2                  break;
2662   2              case 2:                         //even parity
2663   2                  temp_lcr |= 0x18;
2664   2                  break;
2665   2              case 3:                         //force '1' parity
2666   2                  temp_lcr |= 0x03;
2667   2                  break;
2668   2              case 4:                         //force '0' parity
2669   2                  break;
2670   2              default:
2671   2                  break;
2672   2          } 
2673   1          
2674   1          WriteI2C(addr, LCR, temp_lcr);/// WriteRegister(SC16IS750_REG_LCR,temp_lcr);
2675   1      }
2676          //-----------------------------------------
2677          /*
2678          void GPIOSetPinMode(U8 addr,U8 pin_number, U8 i_o)
2679          {
2680              U8 temp_iodir;
2681              
2682              temp_iodir = ReadI2C(addr,IODir); ///ReadRegister(SC16IS750_REG_IODIR);
2683              if ( i_o == OUTPUT ) {
2684                temp_iodir |= (0x01 << pin_number);
2685              } else {
2686                temp_iodir &= (U8)~(0x01 << pin_number);
2687              } 
2688              
2689              WriteI2C(addr, IODir, temp_iodir);///WriteRegister(SC16IS750_REG_IODIR, temp_iodir);
2690              //return;
2691          }
2692          
2693          void GPIOSetPinState(U8 addr,U8 pin_number, U8 pin_state)
2694          {
2695              U8 temp_iostate;
2696              
2697              temp_iostate =  ReadI2C(addr,IOState);///ReadRegister(SC16IS750_REG_IOSTATE);
2698              if ( pin_state == 1 ) {
2699                temp_iostate |= (0x01 << pin_number);
2700              } else {
2701                temp_iostate &= (U8)~(0x01 << pin_number);
2702              } 
2703              
2704              WriteI2C(addr, IODir, IOState);///WriteRegister(SC16IS750_REG_IOSTATE, temp_iostate);
2705            //  return;
2706          }
2707          
2708          U8 GPIOGetPinState(U8 addr,U8 pin_number)
2709          {
2710               uint8_t temp_iostate;
2711              
2712              temp_iostate = ReadI2C(addr,IOState);///ReadRegister(SC16IS750_REG_IOSTATE);
2713              if ( temp_iostate & (0x01 << pin_number)== 0 ) {
2714                return 0;
2715              } 
2716              return 1;
2717             // return;
2718          }
2719          
C51 COMPILER V9.01   NED                                                                   12/25/2018 16:49:28 PAGE 45  

2720          */
2721          //-----------------------------------------
2722          void GPIOSetPortMode(U8 addr,U8 port_io)
2723          {
2724   1      
2725   1       WriteI2C(addr, IODir, port_io); ///WriteRegister(SC16IS750_REG_IODIR, port_io);
2726   1        //  return;
2727   1      
2728   1      }
2729          //-----------------------------------------
2730          void GPIOSetPortState(U8 addr,U8 port_state)
2731          {
2732   1       WriteI2C(addr, IOState, port_state); /// WriteRegister(SC16IS750_REG_IOSTATE, port_state);
2733   1      }
2734          //-----------------------------------------
2735          U8 GPIOGetPortState(U8 addr)
2736          {
2737   1      //#ifdef  SC16IS750_DEBUG_PRINT 
2738   1       //   printf("\r\n**Addr=%X PortState=%X\r\n",(U16)addr,(U16) ReadI2C(addr,IOState));
2739   1          //Serial.println(ReadRegister(SC16IS750_REG_RXLVL), DEC);
2740   1      //#endif    
2741   1          return  ReadI2C(addr,IOState);////ReadRegister(SC16IS750_REG_IOSTATE);
2742   1      
2743   1      }
2744          //-----------------------------------------
2745          #if 0
              U8 FIFOAvailableData(U8 addr)
              {
              #ifdef  SC16IS750_DEBUG_PRINT 
                  printf("\r\n**Available data=%X",(U16)ReadI2C(addr,RXLVL));
                  //Serial.println(ReadRegister(SC16IS750_REG_RXLVL), DEC);
              #endif      
                 return ReadI2C(addr,RXLVL);///ReadRegister(SC16IS750_REG_RXLVL);
              }
              //-----------------------------------------
              U8 FIFOAvailableSpace(U8 addr)
              {
              
              #ifdef  SC16IS750_DEBUG_PRINT 
                  printf("\r\n**Available Space=%X",ReadI2C(addr,TXLVL));
                  //Serial.println(ReadRegister(SC16IS750_REG_RXLVL), DEC);
              #endif   
                 return ReadI2C(addr,TXLVL);///ReadRegister(SC16IS750_REG_TXLVL);
              
              }
              
              //-----------------------------------------
              
              void EnableTransmit(U8 addr,U8 OnOff)
              {
                  U8 temp_efcr;
                  temp_efcr = ReadI2C(addr,EFCR);///ReadRegister(SC16IS750_REG_EFCR);
                  if ( OnOff == 0) {
                      temp_efcr |= 0x04;       
                  } else {   
                      temp_efcr &= 0xFB;
                  }   
                  WriteI2C(addr, EFCR, temp_efcr); ///WriteRegister(SC16IS750_REG_EFCR,temp_efcr);
                  
                  //return;
              }
              #endif
C51 COMPILER V9.01   NED                                                                   12/25/2018 16:49:28 PAGE 46  

2782          //-----------------------------------------
2783          #if 0
              void flush(U8 addr)  //Transmit Holding Register Empty indicator.
              {
                      U8 tmp_lsr;
                      
                      do {
                           #ifdef  SC16IS750_DEBUG_PRINT 
                           printf("\r\n**THR is busy..=%X",addr);
                          //Serial.println(ReadRegister(SC16IS750_REG_RXLVL), DEC);
                          #endif
                              tmp_lsr = ReadI2C(addr,LSR);///ReadRegister(SC16IS750_REG_LSR);
                              
                      } while ((tmp_lsr&0x20) ==0);
              
              
              }
              #endif
2800          //---------------------------------------------------------
2801          #if 0
              U8 ping(U8 addr)
              {
              
                      WriteI2C(addr, SPR, 0x55);///WriteRegister(SC16IS750_REG_SPR,0x55);
                      ///if (ReadRegister(SC16IS750_REG_SPR) !=0x55) {
              if (ReadI2C(addr,SPR) !=0x55) {
                           #ifdef  SC16IS750_DEBUG_PRINT 
                           printf("*ping is fail(0x55)=%X\r\n",(U16)addr);
                           #endif
                              return 0;
                      }
              
                      WriteI2C(addr, SPR, 0xAA);///WriteRegister(SC16IS750_REG_SPR,0xAA);
                      //if (ReadRegister(SC16IS750_REG_SPR) !=0xAA) {
                    if (ReadI2C(addr,SPR)!=0xAA) {
                          #ifdef  SC16IS750_DEBUG_PRINT 
                          printf("*ping is fail(0xAA)=%X\r\n",(U16)addr);
                           #endif
                              return 0;
                      }
              
                          #ifdef  SC16IS750_DEBUG_PRINT 
                           printf("*ping is pass, Address=%X\r\n",(U16)addr);
                           #endif
                          
                      return 1;
              
              }
              #endif
2831          //-----------------------------------------
2832          
2833          //-----------------------------------------
2834          
2835          void WriteByte(U8 addr, U8 val)
2836          {
2837   1      
2838   1       /*  
2839   1              U8 tmp_lsr;
2840   1              while ( FIFOAvailableSpace() == 0 ){
2841   1      #ifdef  SC16IS750_DEBUG_PRINT 
2842   1                      Serial.println("No available space");
2843   1      #endif          
C51 COMPILER V9.01   NED                                                                   12/25/2018 16:49:28 PAGE 47  

2844   1              
2845   1              };
2846   1      
2847   1      #ifdef  SC16IS750_DEBUG_PRINT 
2848   1          Serial.println("++++++++++++Data sent");
2849   1      #endif          
2850   1          WriteRegister(SC16IS750_REG_THR,val);
2851   1      */
2852   1      
2853   1      //      do { 
2854   1      //              tmp_lsr = ReadI2C(addr,LSR);///ReadRegister(SC16IS750_REG_LSR);
2855   1      //      } while ((tmp_lsr&0x20) ==0);
2856   1      
2857   1              
2858   1              WriteI2C(addr, THR, val);///WriteRegister(SC16IS750_REG_THR,val);
2859   1              
2860   1      
2861   1          
2862   1      }
2863          
2864          U8 ReadByte(U8 addr)
2865          {
2866   1      //      volatile U8 val;
2867   1              U8 val;
2868   1              #if 1
2869   1              val = ReadI2C(addr,RHR);///ReadRegister(SC16IS750_REG_RHR);    
2870   1                return val;
2871   1              #else
                      if (FIFOAvailableData(addr) == 0)
                      {
              
              #ifdef  SC16IS750_DEBUG_PRINT 
              printf("\r\n**No data available");
              #endif          
                              //return -1;
                              return '\0';
                      } 
                      else 
                      {
                        
                              #ifdef  SC16IS750_DEBUG_PRINT 
                              printf("\r\n** available ID=%x ,Data=%x",(U16)addr, (U16) ReadI2C(addr,RXLVL));
                              #endif   
              
                              val = ReadI2C(addr,RHR);///ReadRegister(SC16IS750_REG_RHR);    
                        return val;
              
                      }
              
                      #endif
2894   1              
2895   1      
2896   1      }
2897          #if 0
              void TW2835_get(U8 page)
              {
              U8 x,loop=0,step=0;
              U16 val=0;
              
              
              step=0;
              val=0;
C51 COMPILER V9.01   NED                                                                   12/25/2018 16:49:28 PAGE 48  

              
              /*
              for(x=0;x<=2;x++)
              {
              val=(TW28_ReadByte(page,0x8c+step)+(((TW28_ReadByte(page,0x8f+step)&BIT2&BIT3)<<6)));
              printf("\r\n Vin=%x,HDELAY_PB=%x",(U16) x ,(U16)val);
              step+=0x10;
              val=0;
              }
              
              */
              /*
              step=0;
              val=0;
              for(x=0;x<=2;x++)
              {
              val=(TW28_ReadByte(page,0x02+step)+(((TW28_ReadByte(page,0x06+step)&BIT0&BIT1)<<8)));
              printf("\r\n Vin=%x,HDELAY_XY=%x",(U16) x ,(U16)val);
              step+=0x10;
              val=0;
              }
              */
              
              
              step=0;
              val=0;
              for(x=0;x<=2;x++)
              {
              //TW28_WriteByte(page,0x24,0);
              val=(TW28_ReadByte(page,0x04+step)+(((TW28_ReadByte(page,0x06+step)&BIT4)<<4)));
              printf("\r\n Vin=%x,VDELAY_XY=%x",(U16) x ,(U16)val);
              step+=0x10;
              val=0;
              }
              TW28_WriteByte(1,0x74,10);
              printf("\r\n OSD start=%x",(U16)TW28_ReadByte(1,0x74));
              
              
              /*
              step=0;
              val=0;
              for(x=0;x<=2;x++)
              {
              val=(TW28_ReadByte(page,0x03+step)+(((TW28_ReadByte(page,0x06+step)&BIT2&BIT3)<<6)));
              printf("\r\n Vin=%x,HAvtive_XY=%x",(U16) x ,(U16)val);
              step+=0x10;
              val=0;
              }
              
              step=0;
              val=0;
              for(x=0;x<=2;x++)
              {
              val=(TW28_ReadByte(page,0x05+step)+(((TW28_ReadByte(page,0x06+step)&BIT5)<<3)));
              printf("\r\n Vin=%x,VAvtive_XY=%x",(U16) x ,(U16)val);
              step+=0x10;
              val=0;
              }
              */
              
              }
              #endif
C51 COMPILER V9.01   NED                                                                   12/25/2018 16:49:28 PAGE 49  

2968          
2969          //-----------------------------------------
2970          #if 0
              U16 peek(void)
              {
                      /*
                      if ( peek_flag == 0 ) { 
                              peek_buf =ReadByte();
                              if (  peek_buf >= 0 ) { 
                                      peek_flag = 1;
                              }
                      } 
                      */
                      return 1 ;//peek_buf;
                              
              }
              #endif
2985          //-----------------------------------------
2986          #if 0
              void Set_INT(void)
              {
              //INT_flag=0;
              
              EX0=1;
              IT0=1;
              IE0=0;  //flag
                  
              EX1=1;
              IT1=1;
              IE1=0;  //flag
              
              EX2=1;
              IT2=1;    //'1' falling edge trigger/ '0' low level trigger
              IE2=0;    //flag
              }
              #endif
3004          //----------------------------------------
3005          
3006          void MCTRL_set(void)
3007          {
3008   1      
3009   1      //... P[7:4]:INT[5:2], P2_3:HALE, P2_2:HRDB, P2_1:HWRB, P2_0:HSPB
3010   1      P2_0=0;///HSPB=0;
3011   1      P2_1=1;///HWRB=1;
3012   1      P2_2=1;///HRDB=1;
3013   1      P2_3=0;///HALE=0;
3014   1      }
3015          //-----------------------------------------
3016          /*
3017          //-----------------------------------------
3018          
3019          void Int0_interrupt(void) interrupt 0 using 1
3020          {
3021          
3022          IE0=0;
3023          EA=0;
3024          
3025          
3026          EA=1;
3027          
3028          
3029          }
C51 COMPILER V9.01   NED                                                                   12/25/2018 16:49:28 PAGE 50  

3030          
3031          void Int1_interrupt(void) interrupt 2 using 1
3032          {
3033          IE1=0;
3034          EA=0;
3035          
3036          
3037          EA=1;
3038          
3039          
3040          }
3041          
3042          void Int2_interrupt(void) interrupt 6 using 1
3043          {
3044          
3045          IE2=0;
3046          EA=0;
3047          
3048          
3049          EA=1;
3050          
3051          
3052          }
3053          */
3054          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   3785    ----
   CONSTANT SIZE    =     15    ----
   XDATA SIZE       =    130      68
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
