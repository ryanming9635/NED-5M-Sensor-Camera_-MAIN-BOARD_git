C51 COMPILER V9.50a   MAIN                                                                 02/18/2019 18:00:32 PAGE 1   


C51 COMPILER V9.50a, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\OBJ\Main.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE Main.c LARGE OPTIMIZE(9,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\OBJ\Main.l
                    -st) TABS(2) OBJECT(.\OBJ\Main.obj)

line level    source

   1          //  **************************************************************************
   2          //
   3          //       Copyright (c) 1992-2006 Professonal Computer Technology Co., Ltd
   4          //
   5          //      All rights are reserved. Reproduction in whole or in parts is
   6          //  prohibited without the prior written consent of the copyright owner.
   7          //  --------------------------------------------------------------------------
   8          //
   9          //  Module: Main.C
  10          //
  11          //  Purpose: Implementation of Main.
  12          //
  13          //  Version: 0.01                                   2006/10/22 10:39下午
  14          //
  15          //  Compiler: Keil 8051 C Compiler v7.2
  16          //
  17          //  Reference:
  18          //
  19          //
  20          //
  21          //  --------------------------------------------------------------------------
  22          //  Modification:
  23          //
  24          //  R0.01 2006/10/22 10:39下午 Phoenix Chuang
  25          //  Reason:
  26          //    1. Original.
  27          //  Solution:
  28          //  
  29          //  **************************************************************************
  30          //  -----------------------------------
  31          //      Header Files
  32          //  ----------------------------------- 
  33          #include "types.h"
  34          #include "Main.h"
  35          #include "Timer.h"
  36          #include "UART.h"
  37          #include "BusCtrl.h"
  38          #include "TW2835_Init.h"
  39          #include "CommandShell.h"
  40          #include "OSDAction.h"
  41          #include "NED.h"    //add by ryan.
  42          #include "Printf.h"
  43          //#include "SST89x5xxRD2.H"
  44          
  45          //  ------------------------------------
  46          //      Macro Definitions
  47          //  ------------------------------------ 
  48          
  49          
  50          //  ------------------------------------
  51          //      Type Definitions
  52          //  ------------------------------------
  53          
  54          
C51 COMPILER V9.50a   MAIN                                                                 02/18/2019 18:00:32 PAGE 2   

  55          //  ------------------------------------
  56          //      Variables Definitions
  57          //  ------------------------------------
  58            U16 _delay;
  59            U8 bdata commFlag;
  60            sbit comm_chk_flag = commFlag^0;
  61            sbit osd_chk_flag = commFlag^1;
  62            COMMAND_BUFFER RScommand;
  63            bit VlossFlag;
  64          //------------------------------
  65          bit data_chk_flag=0;    //ryan..
  66            
  67          U16 ADC_Val[2]={0,0};
  68          U8 m_current=0;
  69          U8 PIP_flag=0;
  70          U8 Main_f=1;
  71          U8 Small_f=2;
  72          U8 timer2_loop;
  73          U8 boot_flag=1;
  74          extern U8 Temp_timeout;
  75          extern U8 Com_pos;
  76          extern U8 Com_Addr;
  77          extern U8 Com_start;
  78          extern U8 Com_end;
  79          extern U8 Com_run;
  80          extern U8 Monitor_current;
  81          extern U8 Monitor_mode;
  82          extern U8 Monitor_state;
  83          extern U8 Back_f;
  84          extern U8 Shrink_f;
  85          extern  U8 Crop_f;//20150413
  86          extern U8 Shrink_only_f;
  87          extern  U8 DRP_ID[9];
  88          extern BYTE RsRxRp,RsRxWp;
  89          extern U8 Camera_temp0;
  90          extern U8 Camera_temp1;
  91          extern U8 Camera_press0;
  92          extern U8 Camera_press1;
  93          extern U8 Camera_press2;
  94          extern U8 Camera_press3;
  95          extern U16 SC16_busy_flag;
  96          extern  U8 work_flag=0;//20150814
  97           U8 SC16_com_state=0;
  98          extern U8 Camera_ver0;
  99          extern U8 Camera_ver1;
 100          extern U8 Camera_ver2;
 101          
 102          extern U8 get_data_addr;
 103          extern U8 get_data_val;
 104          
 105          extern U8 Camera_flag;
 106          
 107          U16 timerout1=0;  
 108          U16 timerout2=0;  
 109          U16 timerout3=0; 
 110          U16 timerout4=0;
 111          U8 Temp_timeout=1;
 112          U8 CB_flag=0;
 113          U8 CB_timeout=0;
 114          //extern U16 USERTMVAL6;
 115          //-------------------------------
 116          
C51 COMPILER V9.50a   MAIN                                                                 02/18/2019 18:00:32 PAGE 3   

 117          //data U8 *mode="mode 0\r\n";
 118          // char *test="hscom 1 1 ch0:1%1bx ch1:0%1bx ch2:0%1bx ch3:0%1bx\n\r";
 119          
 120          //code U8 *test="hscom 1 1 ch1:12 ch0:02 ch2:02 ch3:03\r\n";  //camA
 121           //char *test="hscom 1 1 ch1:12 ch0:02 ch2:02 ch3:03\n\r";  //camB
 122           //char *test="hscom 2 2 ch0:12 ch1:02 ch2:02 ch3:03\n\r";  //camB+A
 123           //char *test="hscom 2 2 ch2:02 ch3:13 ch0:02 ch1:02\n\r";  //camR+C
 124           
 125          //  ------------------------------------
 126          //      Function Prototypes
 127          //  ------------------------------------
 128          
 129          
 130          
 131          // ===========================================================================
 132          //                      Parallel function description
 133          // ===========================================================================
 134          //
 135          //  Command Shell for Debug
 136          //
 137          
 138          
 139          void CommandShell(void)
 140          {
 141   1      
 142   1          data BYTE ch;
 143   1          static BYTE etx_flag=0;//ryan@20150605
 144   1      
 145   1          if( RS_RxReady() == true )
 146   1          { 
 147   2          
 148   2          WDTCR|=0x10;
 149   2              ch=RS_rx();
 150   2      
 151   2                  #ifdef  UART_debug
                          printf("%x",(U16)(ch));
                          #endif
 154   2                        
 155   2              #if 1        
 156   2                
 157   2                if(ch==STX&&Com_start==0)
 158   2                {
 159   3                Com_pos=1;
 160   3                //RScommand.WritePtr=1;
 161   3                SC16_Com[0]=ch; 
 162   3                  #ifdef  SC16IS750_DEBUG_PRINT 
                          printf("\r\nCom_pos=%x  data=%x",(U16) (Com_pos-1), (U16) SC16_Com[Com_pos-1]);
                          printf("\r\nCom_start");
                          #endif  
 166   3                Com_start=1;
 167   3                }
 168   2                ///ryan@20150605
 169   2              else if((ch==ETX)&&((SC16_Com[1]==0x52)||(SC16_Com[1]==0x53))&&(etx_flag==0)&&Com_pos<=3)
 170   2                  {
 171   3                  etx_flag=1;
 172   3                  SC16_Com[Com_pos]=ch;           
 173   3                  Com_pos++;
 174   3                  }
 175   2                else if(ch==ETX&&Com_end==0)
 176   2                {
 177   3      
 178   3                  SC16_Com[Com_pos]=ch;           
C51 COMPILER V9.50a   MAIN                                                                 02/18/2019 18:00:32 PAGE 4   

 179   3                  Com_pos++;
 180   3                  Com_end=1;
 181   3                  etx_flag=0;///end of loop
 182   3                  #ifdef  SC16IS750_DEBUG_PRINT 
                          printf("\r\nCom_pos=%x  data=%x",(U16) (Com_pos-1), (U16) SC16_Com[Com_pos-1]);
                          printf("\r\nCom_end");
                          #endif  
 186   3                }
 187   2                else if(Com_end==1)
 188   2                {
 189   3                  
 190   3                SC16_Com[Com_pos]=ch; 
 191   3      
 192   3                  #ifdef  SC16IS750_DEBUG_PRINT 
                          printf("\r\nCom_pos=%x  data=%x",(U16) (Com_pos), (U16) SC16_Com[Com_pos]);
                          printf("\r\nBCC check..");
                          #endif  
 196   3                          #ifdef  UART_debug
                          printf("*");
                          #endif
 199   3                    
 200   3                  if(SC16_BCC_Check(&SC16_Com[0]))
 201   3                  {
 202   4                  RScommand.commFlage = true;
 203   4      
 204   4                    RScommand.commBuf[0]=SC16_Com[1];  
 205   4                    RScommand.commBuf[1]='\0';
 206   4                  
 207   4                  Com_run=SC16_Com[2];
 208   4              
 209   4                  RScommand.WritePtr=2;
 210   4                  }
 211   3                  else  
 212   3                  {             
 213   4                  ResetCommSell();
 214   4                  }
 215   3          
 216   3                }
 217   2                else
 218   2                  {
 219   3                  SC16_Com[Com_pos]=ch;           
 220   3                  Com_pos++;
 221   3                  if(Com_pos>8) ResetCommSell();
 222   3        
 223   3                  #ifdef  SC16IS750_DEBUG_PRINT 
                          printf("\r\nCom_pos=%x  data=%x",(U16) (Com_pos-1), (U16) SC16_Com[Com_pos-1]);
                          #endif  
 226   3                  }
 227   2      
 228   2      #else
                  switch(ch) {
                        #if 1
                      
                    case 0x03:
                      RScommand.commBuf[RScommand.WritePtr] = '\0';
                      RScommand.commFlage = true;
                      chkStartCommShell(RScommand.commBuf);
                      if( comm_chk_flag ) NewLine();
              
                      #ifdef  SC16IS750_DEBUG_PRINT 
                   printf("\r\nget data=%x %x %x %x",(U16)RScommand.commBuf[0],(U16)RScommand.commBuf[1]\
                     ,(U16)RScommand.commBuf[2],(U16)RScommand.commBuf[3]);
C51 COMPILER V9.50a   MAIN                                                                 02/18/2019 18:00:32 PAGE 5   

                      
                        #endif  
                      
                      break;
                      #elif 0
                      
                    case '\r':
                      RScommand.commBuf[RScommand.WritePtr] = '\0';
                      RScommand.commFlage = true;
                      chkStartCommShell(RScommand.commBuf);
                      if( comm_chk_flag ) NewLine();
                      break;
                      #endif  
                    case 0x08:
                      RScommand.WritePtr--;
                      break;
              
                    default:
                      RScommand.commBuf[RScommand.WritePtr] = ch;
                      RScommand.WritePtr++;
                      break;
              
                      
                  }
                  #endif
 266   2      
 267   2        }
 268   1           else
 269   1            {
 270   2      timerout4=0;
 271   2            }
 272   1           
 273   1      
 274   1           
 275   1      }
 276          
 277          
 278          // ===========================================================================
 279          //
 280          //
 281          //
 282          #if 0
              void NewLine(void)
              {
                puts("\r\n");                   
              }
              #endif
 288          // ===========================================================================
 289          //
 290          //
 291          //
 292          #if 0
              void PutsP(BYTE *ptr)
              {
                data BYTE ch;
                
                while(*ptr!='\0') {
                  ch = *ptr++;
                  RS_tx(ch);
                }
              }
              #endif
C51 COMPILER V9.50a   MAIN                                                                 02/18/2019 18:00:32 PAGE 6   

 303          // ===========================================================================
 304          //
 305          //  Restart Command Shell 
 306          //
 307          void ResetCommSell(void)
 308          {
 309   1        //if( comm_chk_flag ) PutsP("Debug Program >");
 310   1        
 311   1        Com_start=0;  //ryan..
 312   1        Com_end=0;
 313   1        Com_pos=0;
 314   1        SC16_Com[0]=0;
 315   1        SC16_Com[1]=0;
 316   1        SC16_Com[2]=0;
 317   1        SC16_Com[3]=0;
 318   1        SC16_Com[4]=0;
 319   1        SC16_Com[5]=0;
 320   1        SC16_Com[6]=0;
 321   1        SC16_Com[7]=0;
 322   1        SC16_Com[8]=0;
 323   1        
 324   1        RScommand.WritePtr = 0;
 325   1        RScommand.commFlage = false;
 326   1        RScommand.commBuf[0] = '\0';
 327   1      }
 328          
 329          // ===========================================================================
 330          //
 331          //  Falsh OSD Contril
 332          //
 333          void PCT_FlashOSDCtrl(U8 _on)
 334          {
 335   1        if(_on) osd_chk_flag=false;
 336   1        else osd_chk_flag=true;
 337   1      }
 338          
 339          
 340          // ===========================================================================
 341          //
 342          //  Initial Command Shell 
 343          //
 344          void InitialCommShell(void)
 345          {
 346   1        comm_chk_flag=false;
 347   1        osd_chk_flag=false;
 348   1      
 349   1        //VlossState=0;
 350   1        VlossFlag=0;
 351   1        VlossCount=0;
 352   1      }
 353          
 354          // ===========================================================================
 355          //
 356          //  Start Command Shell 
 357          //
 358          #if 0
              void chkStartCommShell(char *ptr)
              {
                if( comm_chk_flag ) return;
                if( strcmp(ptr,"PCT")==0 ) comm_chk_flag=true;
              }
              #endif
C51 COMPILER V9.50a   MAIN                                                                 02/18/2019 18:00:32 PAGE 7   

 365          void Wait_ms(U16 Tms)
 366          
 367          {
 368   1      //  #define CPU_CLK_KHZ   40000
 369   1      #define CPU_CLK_KHZ   22118
 370   1      #define CPU_SPEED 1
 371   1      #define CountStick      (1000000U/((CPU_CLK_KHZ*CPU_SPEED)/12))/20    
 372   1      
 373   1      //#define CountStick      (1000000U/((CPU_CLK_KHZ*CPU_SPEED)/12))/10  
 374   1                 U16 count;
 375   1      
 376   1                 while(Tms)
 377   1      
 378   1                 {
 379   2      
 380   2                           for(count=0; count<CountStick; count++);//total 20 clock for this loop
 381   2      
 382   2                           Tms--;
 383   2      
 384   2                 }
 385   1      }
 386          
 387          // ===========================================================================
 388          //
 389          //
 390          //
 391          
 392          extern  U8 Cam_boot_flag;//ryan@20151201
 393          void main(void)
 394          {
 395   1        U8 Counter=0;
 396   1        U16 readtemp=0;
 397   1        U8 OsdCount1=200;//Kane @HS 2007 0725 Ver3.4
 398   1        U8 OsdCount2=100;//Kane @HS 2007 0725 Ver3.4
 399   1        U8 Camera_speed=0;
 400   1        // U8 loop=0,lp2=0,lp3=0;  //ryan..
 401   1       // U8 x,y,z;
 402   1      
 403   1        #if 0
               char busw1[14]={"busw 0 1 A1 11"};  
               char busw2[14]={"busw 0 1 A2 D7"};  
               char yvmix[8]={"yvmix 2 "};
               
              char mode[7]={"mode 0 "};
               char test[38]={"hscom 3 3 ch0:12 ch1:12 ch2:12 ch3:03 "};
              
               #endif
 412   1      
 413   1      InitialMPU(); 
 414   1       PWM_init(); 
 415   1      
 416   1      //ADC_FPBS();
 417   1      #if 0
              
                while(0)
              {
              //P0=0x00;
              //printf(">");//ryan..
              //HCSB1=0; HCSB0=0;
              //P3_1=0;
              I2C_SDA=1;
              USERTMVAL1=2;
C51 COMPILER V9.50a   MAIN                                                                 02/18/2019 18:00:32 PAGE 8   

              while(USERTMVAL1>=2);
              I2C_SDA=0;
              USERTMVAL1=2;
              while(USERTMVAL1>=2);
              
              #if 0
              MDATA=0x00; 
              HSPB  = 0;
              HWRB  = 0;
              HRDB  = 0;
              HALE  = 0;
              HCSB0 = 0;
              HCSB1 = 0;
              
              
              //  MCTRL=1;
              Wait_ms(1);
              //P3_1=1;
              
              MDATA=0xff; 
              HSPB  = 1;
              HWRB  = 1;
              HRDB  = 1;
              HALE  = 1;
              HCSB0 = 1;
              HCSB1 = 1;
              //  MCTRL=0;
              Wait_ms(1);
              #endif
              //P0=0xff;
              //HCSB1=1; HCSB0=1;
              //Wait_ms(20);
              //ping(DVR_address);
              //ping(RF_ID_address);
              //ping(Camera_address);
              
              }
              
              #endif
 466   1      
 467   1        InitialCommShell();
 468   1        ResetCommSell();
 469   1      
 470   1      #if 1
 471   1      /*
 472   1      Set_PWM_Output(0,0);
 473   1      Set_PWM_Output(1,0);
 474   1      Set_PWM_Output(2,0);
 475   1      Set_PWM_Output(3,0);
 476   1      Set_PWM_Output(4,0);
 477   1      Set_PWM_Output(5,0);
 478   1      */
 479   1        
 480   1      Power_onoff(0);
 481   1      SC16_init();
 482   1      
 483   1      Monitor_set(Monitor_offset+3);
 484   1      #if 0
              boot_flag=2;//ryan@20181130.
              Monitor_set(Monitor_offset+3);//ryan@20181130.
              boot_flag=0;//ryan@20181130.
              #else
C51 COMPILER V9.50a   MAIN                                                                 02/18/2019 18:00:32 PAGE 9   

 489   1      
 490   1       #endif
 491   1      ///TW28_WriteByte(1,0xab,0x0a);//ryan@20150522 color bar
 492   1      
 493   1      
 494   1      #endif
 495   1      
 496   1      #if 0 
              TW28_WriteByte(1,0x11,0x00);
              TW28_WriteByte(1,0x19,0x00);
              TW28_WriteByte(1,0x21,0x00);
              TW28_WriteByte(1,0x29,0x00);
              #endif
 502   1      
 503   1      GPIO_check();   //TX有錯誤所以開機只做一次baudrate設定
 504   1      
 505   1      //TW28_WriteByte(0,0x25,0x80);  //ryan
 506   1      EnUserTimer(USERTMID3,40);    
 507   1      EnUserTimer(USERTMID4,480);
 508   1      timerout1=480;
 509   1      //EnUserTimer(USERTMID5,16);//for camera moving//300ms
 510   1      EnUserTimer(USERTMID5,4);//for camera moving//300ms
 511   1      timerout2=600+600+600;//for camera speed//15s
 512   1      //EnUserTimer(USERTMID6,600+600+600);//for camera speed//15s
 513   1      Camera_speed=(((DVR_GetIO()&0x3f)&0x10)>>4);
 514   1      
 515   1        while(1){
 516   2            
 517   2        CommandShell();
 518   2        if(RScommand.commFlage == true) PCT_RunCommShell(RScommand.commBuf); 
 519   2        if(RScommand.commFlage == true) ResetCommSell(); 
 520   2           
 521   2        if(VlossFlag==1)
 522   2        {
 523   3          if(PCT_CheckSystem())//Kane Modified
 524   3            VlossFlag=0;
 525   3        }
 526   2      
 527   2        //<<<<<<<<<<<<<<<<<<<<<<<
 528   2          
 529   2        if(RS_RxReady()) EnUserTimer(USERTMID1,OsdCount1);//Kane @HS 2007 0725 Ver3.4
 530   2      
 531   2      
 532   2      
 533   2        if(USERTMVAL1==1)
 534   2        {
 535   3        //PCT_AudioActionForHS();
 536   3        //PCT_OSDActionForHS();
 537   3        //PCT_FlashOSDCtrl(OFF);
 538   3        DisUserTimer(USERTMID1);
 539   3        EnUserTimer(USERTMID0,OsdCount2);//Kane @HS 2007 0725 Ver3.4  // Reset Scan Time, Delay Check and show
 540   3        }
 541   2      
 542   2                   if((USERTMVAL0==1)&&(Com_start==0)) 
 543   2                  {
 544   3                   // Temp_check(); 
 545   3                      //Press_check(); 
 546   3                  PCT_GetVideoSignalStatus(); // Check and Show "VLoss", scan time = 500ms
 547   3                  //GPIO_check();   //ryan..
 548   3                  #ifndef screen3
 549   3                    if(Monitor_state!=Monitor_mode)
 550   3                    {
C51 COMPILER V9.50a   MAIN                                                                 02/18/2019 18:00:32 PAGE 10  

 551   4                    Monitor_set(Monitor_mode);
 552   4                    }
 553   3                  #endif
 554   3                  
 555   3                  //#if 1///#ifdef  get_data_debug
 556   3                    //printf("\r\n RsRxRp=%x",(U16) RsRxRp);  
 557   3                    //#endif
 558   3                    
 559   3                  EnUserTimer(USERTMID0,20);
 560   3                    
 561   3                   }
 562   2      
 563   2        if((USERTMVAL5==1)&&(Camera_flag>=1)&&(Cam_boot_flag==1))//trigger the  up,down,ccw,cw functions
 564   2        {
 565   3          EnUserTimer(USERTMID5,4);
 566   3          Camera_move();
 567   3         
 568   3        }
 569   2      
 570   2      
 571   2        
 572   2      
 573   2          #if 0///ryan@20150804
                   Temp_check(); 
                    Press_check(); 
                  #else
 577   2      
 578   2        
 579   2          if((USERTMVAL3==1)&&(Camera_flag==0)&&(Cam_boot_flag==1)) 
 580   2          {
 581   3            #ifdef  get_data_debug
                      printf("\r\n SC16_com_state=%x",(U16) SC16_com_state);
                      #endif  
 584   3      
 585   3          SC16_data_reset(buff_sel(SC16_com_state));
 586   3          SC16_com_state++;
 587   3          EnUserTimer(USERTMID3,40);
 588   3          if(SC16_com_state>=buff_num) SC16_com_state=0;
 589   3          //work_flag=1;
 590   3          } 
 591   2          else
 592   2          SC16_DataCheck();   //check sc16i750 
 593   2      
 594   2      
 595   2          if(timerout1==1)
 596   2          {
 597   3          SC16_busy_flag=0;
 598   3          timerout1=480;
 599   3                  #ifdef  get_data_debug
                        printf("\r\n SC16_busy_flag_clear=%x",(U16) SC16_busy_flag);
                        #endif  
 602   3          }
 603   2      #endif
 604   2      
 605   2      
 606   2        //SC16_DataCheck();   //check sc16i750 
 607   2      
 608   2      //set camera speed
 609   2      if((timerout2==1)&&(Cam_boot_flag==1))
 610   2      {
 611   3      Set_Camera_speed(Camera_speed); 
 612   3      timerout2=0;
C51 COMPILER V9.50a   MAIN                                                                 02/18/2019 18:00:32 PAGE 11  

 613   3      }
 614   2      
 615   2          WDTCR|=0x10;
 616   2      
 617   2          #if 0//ryan@20151106
                  while(CB_flag==1)
                  {
                    //if((get_data_addr)&&(timerout3>=CB_delay))
                    if(timerout3>=CB_delay)
                    {
                    Get_Data(get_data_addr, get_data_val);
                    
                    CB_flag=0;
                    timerout4=0;
                    }
                    WDTCR|=0x10;          
                  }
                  
                  timerout3=0;
                  #endif
 633   2      
 634   2      
 635   2      
 636   2        }
 637   1        OsdCount1=10;//Kane @HS 2007 0725 Ver3.4
 638   1        OsdCount2 = 20;//Kane @HS 2007 0725 Ver3.4
 639   1      
 640   1         
 641   1      }
 642          
 643          //void main_loop(void)
 644          //{
 645          
 646          
 647          //}
 648          // ===========================================================================
 649          //
 650          //
 651          //
 652          void InitialMPU(void){
 653   1      
 654   1        IP = 0x00;
 655   1        IE = 0x00;    
 656   1      
 657   1      //  PCON = 0x80;  // Set SMOD bit7 in power ctrl reg     //smod=1
 658   1                // This bit doubles the baud rate 
 659   1        PCON = 0x00;  // Clear SMOD bit7 in power ctrl reg   //smod=0
 660   1                // This bit doubles the baud rate 
 661   1        //watch dog
 662   1         WDTCR=0x27;   //pre-scaling value: 256  //4s will reset
 663   1         
 664   1        PSW  = 0x00;  // Set Program state Register
 665   1        TMOD = 0x22;  // Set Timer MODE Register
 666   1      //  TMOD = 0x12;  // Set Timer MODE Register
 667   1                // Timer0: MODE=1, 16-BIT Timer
 668   1                // Timer1: MODE=2, 8-BIT Auto Reload )
 669   1        //  TCON = 0x00;  // Set Timer0/Timer1 Control Register
 670   1          TCON = 0x00;  // Set Timer0/Timer1 Control Register
 671   1                // Timer0=OFF,Timer1=OFF
 672   1      //  SCON = 0x52;  // Setup Serial control Register
 673   1      //      SCON = 0x00;
 674   1                // Mode 1: Start Bit=1,Stop Bit=1,Data Bit=8 
C51 COMPILER V9.50a   MAIN                                                                 02/18/2019 18:00:32 PAGE 12  

 675   1                // and ready Transmit
 676   1                // REN: enable receiver 
 677   1        
 678   1        InitialUART();
 679   1        InitialTimer0();
 680   1            InitialTimer2();
 681   1          
 682   1      
 683   1      //XICON=0x00;
 684   1      //AUXIE=0x00; 
 685   1      AUXR=0;
 686   1      AUXR1=0;
 687   1        TI = 1;     //* Set TI to indicate ready to xmit */
 688   1        EA=1;
 689   1        _nop_();
 690   1          
 691   1      
 692   1      
 693   1      #if 0
              
              CL=0; //PCA counter..
              CH=0;
              CMOD=0x04; // PWM use to  timer-0
              CCON=0x40;  
              
              //CMOD=0x00; // PWM use to  crystal
              //CL=(65536-High);    //PCA counter..
              //CH=(65536-High)>>8;
              //CL=1;    //PCA counter..
              //CH=128;
              
              AUXR2|=0x80;    //Fosc/12 for timer-0
              //CMOD=0x00;///  /12    ///22.1184MHz
              //CMOD=0x02;/// /2
              
              CCAP0L=0x00;
              CCAP0H =(256-128);
              
              CCAP1L=0x00;
              CCAP1H =(256-128);
              
              CCAP2L=0x00;
              CCAP2H =(256-128);
              
              CCAP3L=0x00;
              CCAP3H =(256-128);
              
              CCAP4L=0x00;
              CCAP4H =(256-128);
              
              CCAP5L=0x00;
              CCAP5H =(256-128);
              
              CCAPM0  = 0x42;
              CCAPM1  = 0x42;
              CCAPM2  = 0x42;
              CCAPM3  = 0x42;
              CCAPM4  = 0x42;
              CCAPM5  = 0x42;
              
              PCAPWM0 = 0x00;
              PCAPWM1 = 0x00;
C51 COMPILER V9.50a   MAIN                                                                 02/18/2019 18:00:32 PAGE 13  

              PCAPWM2 = 0x00;
              PCAPWM3 = 0x00;
              PCAPWM4 = 0x00;
              PCAPWM5 = 0x00;
              
              
               //-------------------------------
              #endif
 745   1      P0M0=0;
 746   1      P0M1=0;
 747   1      
 748   1      P1M0|=0x03;   //ADC0 & ADC1
 749   1      P1M1&=0xFC;  
 750   1       
 751   1      P2M0=0;
 752   1      P2M1=0;
 753   1      
 754   1      P3M0=0x00;
 755   1      P3M1=0x00;
 756   1       
 757   1      P4M0=0x00;
 758   1      P4M1=0x04;
 759   1      P4_1=0;
 760   1      
 761   1      
 762   1      P1_2=0;
 763   1      P1_3=0;
 764   1      P1_4=0;
 765   1      P1_5=0;
 766   1      P1_6=0;
 767   1      P1_7=0;
 768   1      
 769   1      //P1_1=1;//ryan@20150908
 770   1      
 771   1      }
 772          //----------------------------------------------------------
 773          
 774          void Set_PWM_Output (U8 addr, U8 val)
 775          {
 776   1      #ifdef _LED_PWM_HALF
 777   1        #ifdef _LED_PWM_DECREASE
 778   1        U8 num[6]={255,243,237,232,226,222};//0%,5%,7%,9%,11%,13%
 779   1        #else 
                U8 num[6]={255,200+28,150+53,100+79+5,50+103,0+128};//0%,10%,20%,30%,40%,50%
                #endif
 782   1      #else
              U8 num[6]={255,200,150,100,50,0};//0%,20%,40%,60%,80%,100%
              #endif
 785   1      
 786   1      //CL=0; //PCA counter..
 787   1      //CH=0;
 788   1      //CMOD=0x04; // PWM use to  timer-0
 789   1      //CCON=0x40; 
 790   1      //AUXR2|=0x80;    //Fosc/12 for timer-0
 791   1      
 792   1      
 793   1      
 794   1       switch(addr)
 795   1          {
 796   2          case 0: 
 797   2                  CCAP0L=0x00;  
 798   2                    if(val==0)  CCAPM0=0x00;
C51 COMPILER V9.50a   MAIN                                                                 02/18/2019 18:00:32 PAGE 14  

 799   2                else   CCAPM0=0x42;                 
 800   2                    
 801   2                       CCAP0H =num[val];      
 802   2                       PCAPWM0 = 0x00;
 803   2                      break;
 804   2          case 1: 
 805   2                  CCAP1L=0x00;  
 806   2                    if(val==0)  CCAPM1=0x00;
 807   2                else   CCAPM1=0x42;                 
 808   2                
 809   2                     CCAP1H =num[val];    
 810   2                      PCAPWM1 = 0x00;
 811   2                      break;
 812   2          case 2:  
 813   2                  CCAP2L=0x00;  
 814   2                    if(val==0)  CCAPM2=0x00;
 815   2                else   CCAPM2=0x42;
 816   2                
 817   2                      CCAP2H =num[val];   
 818   2                      PCAPWM2 = 0x00;
 819   2                      break; 
 820   2          case 3:
 821   2                  CCAP3L=0x00;  
 822   2                    if(val==0)  CCAPM3=0x00;
 823   2                else   CCAPM3=0x42; 
 824   2                
 825   2                      CCAP3H =num[val];   
 826   2                      PCAPWM3 = 0x00;
 827   2                      break;
 828   2          case 4:
 829   2                  CCAP4L=0x00;  
 830   2                    if(val==0)  CCAPM4=0x00;
 831   2                else   CCAPM4=0x42; 
 832   2                
 833   2                      CCAP4H =num[val];  
 834   2                      PCAPWM4 = 0x00;
 835   2                      break;
 836   2          case 5:
 837   2                  CCAP5L=0x00;  
 838   2                    if(val==0)  CCAPM5=0x00;
 839   2                else   CCAPM5=0x42;
 840   2                
 841   2                      CCAP5H =num[val];  
 842   2                      PCAPWM5 = 0x00;
 843   2                      break;
 844   2           default: 
 845   2            break;
 846   2          }
 847   1      
 848   1      
 849   1      }
 850          
 851          //-----------------------------------------------------------
 852          void PWM_init(void)
 853          {
 854   1      
 855   1      CL=0; //PCA counter..
 856   1      CH=0;
 857   1      CMOD=0x04; // PWM use to  timer-0
 858   1      //CMOD=0x00; // PWM use to  timer-0
 859   1      
 860   1      CCON=0x40;  
C51 COMPILER V9.50a   MAIN                                                                 02/18/2019 18:00:32 PAGE 15  

 861   1      
 862   1      //CMOD=0x00; // PWM use to  crystal
 863   1      //CL=(65536-High);    //PCA counter..
 864   1      //CH=(65536-High)>>8;
 865   1      //CL=1;    //PCA counter..
 866   1      //CH=128;
 867   1      
 868   1      AUXR2|=0x80;    //Fosc/12 for timer-0
 869   1      //CMOD=0x00;///  /12    ///22.1184MHz
 870   1      //CMOD=0x02;/// /2
 871   1      
 872   1      /*
 873   1      CCAP0L=0x00;
 874   1      CCAP0H =(256-128);
 875   1      
 876   1      CCAP1L=0x00;
 877   1      CCAP1H =(256-128);
 878   1      
 879   1      CCAP2L=0x00;
 880   1      CCAP2H =(256-128);
 881   1      
 882   1      CCAP3L=0x00;
 883   1      CCAP3H =(256-128);
 884   1      
 885   1      CCAP4L=0x00;
 886   1      CCAP4H =(256-128);
 887   1      
 888   1      CCAP5L=0x00;
 889   1      CCAP5H =(256-128);
 890   1      
 891   1      CCAPM0  = 0x42;
 892   1      CCAPM1  = 0x42;
 893   1      CCAPM2  = 0x42;
 894   1      CCAPM3  = 0x42;
 895   1      CCAPM4  = 0x42;
 896   1      CCAPM5  = 0x42;
 897   1      
 898   1      PCAPWM0 = 0x00;
 899   1      PCAPWM1 = 0x00;
 900   1      PCAPWM2 = 0x00;
 901   1      PCAPWM3 = 0x00;
 902   1      PCAPWM4 = 0x00;
 903   1      PCAPWM5 = 0x00;
 904   1      */
 905   1      }
 906          
 907          //-----------------------------------------
 908          U8 Monitor_set(U8 val)
 909          {
 910   1      char busw1[14]={"busw 0 1 A1 11"};  
 911   1      char busw2[14]={"busw 0 1 A2 D7"};  
 912   1      char yvmix[8]={"yvmix 4 "};
 913   1      char mode[7]={"mode 0 "};
 914   1      
 915   1      
 916   1      //char conf[38]={"hscom 2 2 ch0:12 ch1:12 ch2:02 ch3:03 "};
 917   1      //char conf1[38]={"hscom 1 1 ch0:12 ch1:02 ch2:02 ch3:03 "};
 918   1      //ch0 Camera  
 919   1      //ch1 DVR       
 920   1      //ch2 Rear
 921   1      
 922   1      
C51 COMPILER V9.50a   MAIN                                                                 02/18/2019 18:00:32 PAGE 16  

 923   1      #ifdef OSD_off
 924   1      
 925   1      char conf1[38]={"hscom 1 1 ch0:10 ch1:00 ch2:00 ch3:00 "};   // C
 926   1      char conf2[38]={"hscom 1 1 ch2:10 ch1:00 ch0:00 ch3:00 "};   // R
 927   1      char conf3[38]={"hscom 1 1 ch1:10 ch0:00 ch2:00 ch3:00 "};  // D
 928   1      
 929   1      char conf4[38]={"hscom 2 2 ch2:10 ch0:10 ch1:00 ch3:00 "};   //CR
 930   1      char conf5[38]={"hscom 2 2 ch0:10 ch2:10 ch1:00 ch3:00 "};  //RC
 931   1      
 932   1      char conf6[38]={"hscom 2 2 ch1:10 ch0:10 ch2:00 ch3:00 "};  // DC
 933   1      #ifdef recorder_video_only
 934   1      char conf7[38]={"hscom 1 1 ch1:10 ch0:00 ch2:00 ch3:00 "};  // D
 935   1      #else
              char conf7[38]={"hscom 2 2 ch0:10 ch1:10 ch2:00 ch3:00 "};  // CD
              #endif
 938   1      
 939   1      char conf8[38]={"hscom 2 2 ch1:10 ch2:10 ch0:00 ch3:00 "};  // DR
 940   1      char conf9[38]={"hscom 2 2 ch2:10 ch1:10 ch2:00 ch3:00 "};  // RD
 941   1      
 942   1      char conf10[38]={"hscom 3 3 ch0:10 ch1:10 ch2:10 ch3:00 "};
 943   1      
 944   1      #else
              char conf1[38]={"hscom 1 1 ch0:12 ch1:02 ch2:02 ch3:03 "};   // C
              char conf2[38]={"hscom 1 1 ch2:12 ch1:02 ch0:02 ch3:03 "};   // R
              char conf3[38]={"hscom 1 1 ch1:12 ch0:02 ch2:02 ch3:03 "};  // D
              
              char conf4[38]={"hscom 2 2 ch2:12 ch0:12 ch1:02 ch3:03 "};   //CR
              char conf5[38]={"hscom 2 2 ch0:12 ch2:12 ch1:02 ch3:03 "};  //RC
              
              char conf6[38]={"hscom 2 2 ch1:12 ch0:12 ch2:02 ch3:03 "};  // DC
              char conf7[38]={"hscom 2 2 ch0:12 ch1:12 ch2:02 ch3:03 "};  // CD
              
              char conf8[38]={"hscom 2 2 ch1:12 ch2:12 ch0:02 ch3:03 "};  // DR
              char conf9[38]={"hscom 2 2 ch2:12 ch1:12 ch2:02 ch3:03 "};  // RD
              
              char conf10[38]={"hscom 3 3 ch0:12 ch1:12 ch2:12 ch3:03 "};
              
              #endif
 961   1      
 962   1      char conf11[38]={"hscom 1 1 ch3:00 ch1:00 ch2:00 ch0:00 "};
 963   1      
 964   1      //PU8  ptr;
 965   1      U8 Error=0;
 966   1      U8 ch=0;
 967   1      
 968   1      ch=(val-Monitor_offset);
 969   1      
 970   1      #ifdef Crop_Shrink_flag//20150413
 971   1      if(ch>=10)
 972   1        ch=ch-4;
 973   1      else
 974   1      {
 975   2        Crop_f=0;//clear Crop_f   
 976   2      }
 977   1      #endif
 978   1      
 979   1       Monitor_state=val;  
 980   1      
 981   1      switch(ch)
 982   1      {
 983   2      case 0: PIP_flag=1;       //PinP[ON]
 984   2          break;
C51 COMPILER V9.50a   MAIN                                                                 02/18/2019 18:00:32 PAGE 17  

 985   2      case 1:  PIP_flag=0;      //PinP[OFF]
 986   2          break;
 987   2      case 2:             //[Front]
 988   2          /*
 989   2          if(Shrink_only_f)
 990   2          {
 991   2          Back_f=1;     
 992   2          }
 993   2          else    
 994   2          {
 995   2          Back_f=0;     
 996   2              Main_f=1;  
 997   2          }
 998   2          */
 999   2            //if(Shrink_only_f==1)
1000   2          //  {
1001   2            //Back_f=0;     
1002   2            //}
1003   2            //else
1004   2            //{
1005   2            Back_f=0;     
1006   2                Main_f=1;  
1007   2            //Shrink_only_f=0;
1008   2            //}
1009   2          break;    
1010   2      case 3:             //[Rear]
1011   2      /*
1012   2          if(Shrink_only_f)
1013   2          {
1014   2          Back_f=0;
1015   2          }
1016   2          else
1017   2          {
1018   2          Back_f=1;  
1019   2              Main_f=2;
1020   2          }
1021   2          */
1022   2            //if((Shrink_only_f==1)&&(PIP_flag==1))
1023   2            //{
1024   2            //Back_f=1;     
1025   2            //}
1026   2            //else
1027   2            //{
1028   2            Back_f=1;  
1029   2                  Main_f=2;
1030   2            //Shrink_only_f=0;
1031   2            //}
1032   2          break;    
1033   2      case 4:   Shrink_f=1;     ///[Shrink]
1034   2          Main_f=4;
1035   2          Shrink_only_f=0;
1036   2          break;    
1037   2      case 5:  Shrink_f=0;        ////[Crop]  
1038   2          Main_f=1;
1039   2          Shrink_only_f=0;
1040   2              break;
1041   2      #ifdef Crop_Shrink_flag     //ryan@20150413
1042   2      case 6:                //crop+shrink
1043   2        Crop_f=0x14;
1044   2        Shrink_only_f=0;
1045   2            break;
1046   2      case 7:            //shrink+crop
C51 COMPILER V9.50a   MAIN                                                                 02/18/2019 18:00:32 PAGE 18  

1047   2        Crop_f=0x41;
1048   2        Shrink_only_f=1;
1049   2         break;
1050   2      #endif
1051   2      default:  Main_f=1; break;
1052   2      }
1053   1      
1054   1      
1055   1      if(Crop_f>=1)
1056   1      {
1057   2      m_current=Crop_f;//ryan@20150413  
1058   2      }
1059   1      else if(PIP_flag==1)
1060   1        {
1061   2          if(Back_f==1)
1062   2            {
1063   3      
1064   3              if(Shrink_only_f==1)
1065   3              {
1066   4              //Main_f=4;
1067   4              //Small_f=2;  
1068   4      
1069   4              Main_f=2;
1070   4              Small_f=4;  
1071   4              }
1072   3              else
1073   3              {
1074   4      
1075   4                  if(Shrink_f==1)
1076   4                  {             
1077   5                    Main_f=2;
1078   5                    Small_f=4;
1079   5                  }
1080   4                  else
1081   4                  { 
1082   5                    Main_f=2;
1083   5                    Small_f=1;            
1084   5                  }
1085   4              }
1086   3            }
1087   2          else
1088   2            {
1089   3              if(Shrink_only_f==1)
1090   3              {
1091   4              //Main_f=2;
1092   4              //Small_f=4;  
1093   4      
1094   4              Main_f=4;
1095   4              Small_f=2;        
1096   4              }
1097   3              else
1098   3              {
1099   4                  if(Shrink_f==1)
1100   4                  {
1101   5                    Main_f=4;
1102   5                    Small_f=2;
1103   5                  }
1104   4                  else
1105   4                  {
1106   5                    Main_f=1;
1107   5                    Small_f=2;            
1108   5                  }
C51 COMPILER V9.50a   MAIN                                                                 02/18/2019 18:00:32 PAGE 19  

1109   4              }
1110   3            }
1111   2      
1112   2          m_current=(Main_f<<4)|Small_f;
1113   2            
1114   2        }
1115   1      else
1116   1      {
1117   2            
1118   2            if(Back_f)
1119   2            {
1120   3                  Main_f=2;
1121   3                  
1122   3                      m_current=Main_f<<4;//add
1123   3      
1124   3            }
1125   2            else
1126   2            {
1127   3            
1128   3                  if(Shrink_f==1)
1129   3                  {
1130   4                  Main_f=4;
1131   4                  Small_f=2;
1132   4                  m_current=Main_f<<4;//add
1133   4                  }
1134   3                  else
1135   3                  {               
1136   4                  //Main_f=1;
1137   4                  //Small_f=2;              
1138   4        
1139   4                      if(Shrink_only_f)
1140   4                        {
1141   5                        m_current=0x41;
1142   5                        }
1143   4                      else
1144   4                      {
1145   5                      Main_f=1;
1146   5                      Small_f=2;
1147   5                      m_current=Main_f<<4;//add
1148   5                      }
1149   4                  }
1150   3              
1151   3            }
1152   2              
1153   2          //m_current=Main_f<<4;
1154   2          
1155   2      }         
1156   1      /*
1157   1      if(boot_flag==2)
1158   1      {
1159   1      ///read 0xA1
1160   1      //memcpy ((RScommand.commBuf), busr1, sizeof(busr1) );
1161   1      //PCT_RunCommShell(RScommand.commBuf);
1162   1      //printf("%x",(U16)(ch));
1163   1      //printf("\r\nReadAsicByte == %x", (U16)TW28_ReadByte(1, 0xA1));
1164   1      
1165   1      memcpy ((RScommand.commBuf), busw1, sizeof(busw1) );
1166   1      PCT_RunCommShell(RScommand.commBuf); 
1167   1      
1168   1      //memcpy ((RScommand.commBuf), busw2, sizeof(busw2) );
1169   1      //PCT_RunCommShell(RScommand.commBuf); 
1170   1      
C51 COMPILER V9.50a   MAIN                                                                 02/18/2019 18:00:32 PAGE 20  

1171   1      //memcpy ((RScommand.commBuf), mode, sizeof(mode)  );
1172   1      //PCT_RunCommShell(RScommand.commBuf); 
1173   1      return 0;
1174   1      }
1175   1      else
1176   1        */
1177   1        
1178   1      if(boot_flag)
1179   1      {  
1180   2      
1181   2      //InitialCommShell();
1182   2      PCT_InitialTW2835();  // Initial RssetN for TW2835
1183   2      //ResetCommSell();
1184   2      
1185   2      #if 0///ryan@20181217
              
              //printf("(A)");
              memcpy ((RScommand.commBuf), busw1, sizeof(busw1) );
              PCT_RunCommShell(RScommand.commBuf); 
              //printf("(B)");
              memcpy ((RScommand.commBuf), busw2, sizeof(busw2) );
              PCT_RunCommShell(RScommand.commBuf); 
              //printf("(C)");
              memcpy ((RScommand.commBuf), mode, sizeof(mode)  );
              PCT_RunCommShell(RScommand.commBuf); 
              //printf("(D)");
              
              #endif
1199   2      
1200   2      TW28_WriteByte(1, 0xA1, 0x11);
1201   2      TW28_WriteByte(1, 0xA2, 0xD7);
1202   2      
1203   2      //printf("(0xA1=%x)", (U16)TW28_ReadByte(1, 0xA1));
1204   2      //printf("(0xA2=%x)", (U16)TW28_ReadByte(1, 0xA2));
1205   2      
1206   2      
1207   2      
1208   2      }
1209   1      else
1210   1      {
1211   2        #ifdef black_change
                  #if 1 
                  TW28_WriteByte(1,0x11,0x00);
                  TW28_WriteByte(1,0x19,0x00);
                  TW28_WriteByte(1,0x21,0x00);
                  //TW28_WriteByte(1,0x29,0x00);
              
                  TW28_WriteByte(0,0xc3,0xf8);
                  TW28_WriteByte(0,0xc4,0xff);
                  TW28_WriteByte(1,0x0f,0x00);/// black boundary color
                  //TW28_WriteByte(1,0x5f,0x30);
                  #endif
                  
                memcpy ((RScommand.commBuf), conf11, sizeof(conf11) );
                PCT_RunCommShell(RScommand.commBuf); 
                Wait_ms(25+100+100);
                #endif
1228   2      }
1229   1      
1230   1      
1231   1      #ifdef screen3
              if(boot_flag==1) m_current=10;
C51 COMPILER V9.50a   MAIN                                                                 02/18/2019 18:00:32 PAGE 21  

              #endif
1234   1      
1235   1      switch(m_current)
1236   1      {
1237   2      #if 1
1238   2        #if 1//ryan
1239   2      case 0x10: memcpy ((RScommand.commBuf), conf1, sizeof(conf1) ); TW28_WriteByte(1,0x0f,0x03);break;  //C
1240   2      case 0x20: memcpy ((RScommand.commBuf), conf2, sizeof(conf2) ); TW28_WriteByte(1,0x0f,0x03);break;  //R
1241   2      case 0x40: memcpy ((RScommand.commBuf), conf1, sizeof(conf1) ); TW28_WriteByte(1,0x0f,0x03);break;  //D
1242   2      case 0x12: memcpy ((RScommand.commBuf), conf4, sizeof(conf4) ); break;  //CR
1243   2      case 0x21: memcpy ((RScommand.commBuf), conf5, sizeof(conf5) ); break;  //RC
1244   2      case 0x14: memcpy ((RScommand.commBuf), conf6, sizeof(conf6) ); break;  //DC
1245   2      case 0x41: memcpy ((RScommand.commBuf), conf7, sizeof(conf7) ); break;  //CD
1246   2      case 0x24: memcpy ((RScommand.commBuf), conf5, sizeof(conf5) ); 
1247   2      
1248   2              if(Shrink_only_f)
1249   2        //      memcpy ((RScommand.commBuf), conf8, sizeof(conf8) ); 
1250   2              memcpy ((RScommand.commBuf), conf9, sizeof(conf9) ); 
1251   2      
1252   2              //else
1253   2              //memcpy ((RScommand.commBuf), conf4, sizeof(conf4) ); 
1254   2              
1255   2              break;  //DR
1256   2      
1257   2      case 0x42:     memcpy ((RScommand.commBuf), conf4, sizeof(conf4) );
1258   2          
1259   2              if(Shrink_only_f)
1260   2        //      memcpy ((RScommand.commBuf), conf9, sizeof(conf9) ); 
1261   2              memcpy ((RScommand.commBuf), conf8, sizeof(conf8) ); 
1262   2      
1263   2              //else
1264   2              //memcpy ((RScommand.commBuf), conf4, sizeof(conf4) ); 
1265   2            
1266   2              break;  //RD
1267   2      
1268   2        #else
              case 0x10: memcpy ((RScommand.commBuf), conf1, sizeof(conf1) ); TW28_WriteByte(1,0x0f,0x03);break;  //C
              case 0x20: memcpy ((RScommand.commBuf), conf2, sizeof(conf2) ); TW28_WriteByte(1,0x0f,0x03);break;  //R
              case 0x40: memcpy ((RScommand.commBuf), conf3, sizeof(conf3) ); TW28_WriteByte(1,0x0f,0x03);break;  //D
              case 0x12: memcpy ((RScommand.commBuf), conf4, sizeof(conf4) ); break;  //CR
              case 0x21: memcpy ((RScommand.commBuf), conf5, sizeof(conf5) ); break;  //RC
              case 0x14: memcpy ((RScommand.commBuf), conf6, sizeof(conf6) ); break;  //DC
              case 0x41: memcpy ((RScommand.commBuf), conf7, sizeof(conf7) ); break;  //CD
              case 0x24: memcpy ((RScommand.commBuf), conf8, sizeof(conf8) ); break;  //DR
              case 0x42: memcpy ((RScommand.commBuf), conf9, sizeof(conf9) ); break;  //RD
                #endif
1279   2      #ifdef screen3
              case 10:      memcpy ((RScommand.commBuf), conf10, sizeof(conf10) ); break;
              #endif
1282   2      
1283   2      default:
1284   2          memcpy ((RScommand.commBuf), conf1, sizeof(conf1) ); break;
1285   2      #else
              case 0x00: memcpy ((RScommand.commBuf), conf1, sizeof(conf1) ); break;
              case 0x01: memcpy ((RScommand.commBuf), conf2, sizeof(conf2) ); break;
              case 0x10: memcpy ((RScommand.commBuf), conf4, sizeof(conf4) ); break;
              case 0x11: memcpy ((RScommand.commBuf), conf3, sizeof(conf3) ); break;
              #ifdef screen3
              case 4:       memcpy ((RScommand.commBuf), conf5, sizeof(conf5) ); break;
              #endif
              
              default:
C51 COMPILER V9.50a   MAIN                                                                 02/18/2019 18:00:32 PAGE 22  

                  memcpy ((RScommand.commBuf), conf1, sizeof(conf1) ); break;
              #endif  
1297   2      }
1298   1      
1299   1      #ifdef screen3
              if(boot_flag) 
              {
                 m_current=0;      
              }
              #endif
1305   1      
1306   1      boot_flag=0;
1307   1      //printf("RScommand.commBuf=%s\r\n",RScommand.commBuf);  //ryan
1308   1      PCT_RunCommShell(RScommand.commBuf); 
1309   1      
1310   1      
1311   1      switch(m_current)
1312   1      {
1313   2      //#if 1
1314   2      case 0x10: Bound_Set(0x00); break;  //C
1315   2      case 0x20: Bound_Set(0x00); break;  //R
1316   2      case 0x40: Bound_Set(0x00);Error=1; break;  //D
1317   2      case 0x12: Bound_Set(0x01); break;  //CR
1318   2      case 0x21: Bound_Set(0x01); break;  //RC
1319   2      case 0x14: Bound_Set(0x01); break;  //DC
1320   2      case 0x41: Bound_Set(0x01); break;  //CD
1321   2      case 0x24: Bound_Set(0x01); Error=1;break;  //DR
1322   2      case 0x42: Bound_Set(0x01);Error=1; break;  //RD
1323   2      
1324   2      default:
1325   2           break;
1326   2      }
1327   1      
1328   1      #ifdef  black_change
              TW28_WriteByte(0,0xc3,0x01);
              TW28_WriteByte(0,0xc4,0x00);
              #endif
1332   1      
1333   1      
1334   1          #ifdef  Monitor_debug
                printf("\r\nMonitor mode=%x, m_current=%x ",(U16)ch, (U16)m_current); 
                  //printf(" ,return=%x", (U16)Error);
                
                   
              
                  if(Error==1)
                  {
                    //SC16_Com
                      //RS_tx(STX);
                      // RS_tx(SC16_Com[1]);
                      // RS_tx(SC16_Com[2]);                 
                      // RS_tx(ETX);
                      // RS_tx(SC16_Com[4]);
                       RS_tx(0x35);
                     RS_tx(0x35);
                      RS_tx(0x35);
                        printf(" Error=1");
                  } 
                  #endif  
1354   1      
1355   1      return Error;
1356   1      
C51 COMPILER V9.50a   MAIN                                                                 02/18/2019 18:00:32 PAGE 23  

1357   1      }
1358          
1359          //-----------------------------------------
1360          
1361          U8 PWM_set(U8 val)
1362          {
1363   1      
1364   1      U8 Error=0,ch=0,set_val=0;
1365   1      
1366   1      if(val>=PWM1_offset&&val<=(PWM6_offset+6))
1367   1      {
1368   2      ch=((val-PWM1_offset)/6);
1369   2        set_val=(val-PWM1_offset)%6;
1370   2      
1371   2        
1372   2          Set_PWM_Output(ch,set_val);
1373   2      
1374   2          #ifdef  SC16IS750_DEBUG_PRINT 
                  printf("\r\nPWM_set ch=%x , val=%x",(U16)ch,(U16)set_val);
                    #endif   
1377   2          
1378   2            Error=1;
1379   2      }
1380   1      
1381   1      return Error;
1382   1      }
1383          
1384          //-----------------------------------------
1385          
1386          void Temp_check(void)
1387          {
1388   1      U16 val=0;
1389   1      //U8 loop=0;
1390   1      
1391   1      //val=(ADT75_GetTemp()>>4)/16;
1392   1      val=(ADT75_GetTemp()>>4)/16;
1393   1      if((P1_1==0))
1394   1        val=99;
1395   1      //else if(val&0x0800==1)
1396   1        //val=0;
1397   1      #if 1
1398   1      
1399   1        //val&=99;//ryan@20150909
1400   1      
1401   1      if((val%10)>9);
1402   1      else
1403   1      Camera_temp0=(U8)(val%10)+0x30;
1404   1      
1405   1      Camera_temp1=(U8)(val/10)+0x30;
1406   1          
1407   1          //if(Temp_timeout==1)
1408   1          //  {
1409   1          //printf("\r\nTemp_check=%x",val);
1410   1          //Temp_timeout= 120;
1411   1          //  }
1412   1      #else
              SC16_Com[0]=STX;
              SC16_Com[1]=0x32;
              SC16_Com[2]=0x31;
              SC16_Com[3]=(U8)(val/10)+0x30;
              SC16_Com[4]=(U8)(val%10)+0x30;
              SC16_Com[5]=0x20;
C51 COMPILER V9.50a   MAIN                                                                 02/18/2019 18:00:32 PAGE 24  

              SC16_Com[6]=0x20;
              SC16_Com[7]=ETX;
              SC16_Com[8]=0;
              
              #ifdef BCC_noSTXEXT          ////XOR 1-6
              for(loop=1;loop<=6;loop++)
              SC16_Com[8]^=SC16_Com[loop];
              #else                                 //XOR 0-7
              for(loop=0;loop<=7;loop++)
              SC16_Com[8]^=SC16_Com[loop];
              #endif
              
              
              
                for(loop=0;loop<=8;loop++)
                {
                RS_tx(SC16_Com[loop]);
                //DELAY_FOR(200);
                }
              #endif
1439   1      
1440   1      }
1441          
1442          //---------------------------------------------------
1443          
1444          
1445          void Press_check(void)
1446          {
1447   1      
1448   1      //#define _2V  101300  ///2.0V
1449   1      //#define _3V  199400  ////3.0V
1450   1      //#define _1V_step   311
1451   1      //#define press_offset   0
1452   1      //#define ap_offset 60-8
1453   1      
1454   1      
1455   1      U16 val=0;
1456   1      U8 loop=0;
1457   1      #if 1
1458   1      
1459   1      
1460   1      #define _2V  101300  ///2.0V
1461   1      #define _3V  199400  ////3.0V
1462   1      #define _1V_step   310//0//311///one step=0.0031V refernec voltage=3.3V
1463   1      #define press_offset  (-31)//// (50+30-1) ///1.850V offset to 2.0V ryan@20180727
1464   1      #define ap_offset 60-8
1465   1      
1466   1      //U32 temp_val=0;
1467   1      float temp_val=0;
1468   1      val=ADC_FPBS();
1469   1      
1470   1      val=val+press_offset;
1471   1      temp_val=val;
1472   1      
1473   1      #ifdef  press_debug 
              printf("\r\nADC_FPBS()=%x ",(U16)val);
              #endif  
1476   1          
1477   1      #if 1//ryan@20180727
1478   1      #if 1//ryan@20181203
1479   1        //壓力P=101.3*((ADC-281)/281)=大氣壓力[KPa]
1480   1        //ADC=562 壓力P=101.3*((562-281)/281)=101.3[KPa]//標準
C51 COMPILER V9.50a   MAIN                                                                 02/18/2019 18:00:32 PAGE 25  

1481   1        //ADC=500 壓力P=101.3*((500-281)/281)=78.9[KPa]
1482   1        //ADC=844 壓力P=101.3*((844-281)/281)=200.4[KPa]
1483   1        temp_val=(101.3)*((temp_val-281)/281);
1484   1        
1485   1      #else//>2.0  645*0.0031=2.0V
              {
                  if(temp_val<=967)   ///<3V  967*0.0031=3.0V
                    {
                    temp_val=(((((temp_val*_1V_step)/100)-2000)*98)+101300);
                    }
                  else
                    {
                     temp_val=199400;
                    }
              }
              else                ///2.0V to 1.6V
              {
                if(temp_val>=(516+1))   ///>1.6 V   516*0.0031=1.6V
                    {
                      temp_val=(((((temp_val*_1V_step)/100)-1600)*98)+62100);
                    }
                  else
                    {
                    temp_val=62100;
                    }
                  
              }
                #endif
1509   1      #else
              if(temp_val>=(_1V_step*2))   ///>2.0  
              {
                  if(temp_val<=(_1V_step*3))   ///<3V
                    {
                      //temp_val=(val-_1V_step)*487;
                      temp_val=((_1V_step*3)-temp_val)*(316+ap_offset);
                    }
                  else
                    {
                     temp_val=199400;
                    }
              }
              else                ///2.0V to 1.6V
              {
                //if(temp_val>=328)   ///>1.6 V
                if(temp_val>=499)   ///>1.6 V
                    {
                      //temp_val=((_1V_step*2)-val)*478;
                      temp_val=((_1V_step*2)-val)*210;
                    }
                  else
                    {
                    temp_val=62100;
                    }
              }
              #endif
1536   1      
1537   1      #if 1//ryan@20181203
1538   1      val=(U16)(temp_val*10);
1539   1      temp_val=(U16)(temp_val*10);
1540   1      #else
              val=(temp_val/100);
              temp_val=val;
C51 COMPILER V9.50a   MAIN                                                                 02/18/2019 18:00:32 PAGE 26  

              #endif
1544   1      
1545   1      if((val>=1003)&&(val<=1023))
1546   1      {
1547   2      val=1013;
1548   2      }
1549   1      else if(val>9999)  val=9999;
1550   1      
1551   1      //val=1994;
1552   1      
1553   1      Camera_press3=(val/1000)+0x30;  val=(val%1000);
1554   1      Camera_press2=(val/100)+0x30;  val=(val%100);
1555   1      Camera_press1=(val/10)+0x30;  val=(val%10);
1556   1      Camera_press0=val+0x30;
1557   1      
1558   1      
1559   1          #ifdef  press_debug 
                  printf("\r\nGet_press=%x ",(U16)temp_val);
                    #endif  
1562   1      
1563   1      
1564   1      
1565   1      
1566   1      #else
              Camera_press1=(U8)(val/10)+0x30;
              Camera_press0=(U8)(val%10)+0x30;
              
              
              /*
              SC16_Com[0]=STX;
              SC16_Com[1]=0x32;
              SC16_Com[2]=0x31;
              SC16_Com[3]=(U8)(val/10)+0x30;
              SC16_Com[4]=(U8)(val%10)+0x30;
              SC16_Com[5]=0x20;
              SC16_Com[6]=0x20;
              SC16_Com[7]=ETX;
              SC16_Com[8]=0;
              
              #ifdef BCC_noSTXEXT          ////XOR 1-6
              for(loop=1;loop<=6;loop++)
              SC16_Com[8]^=SC16_Com[loop];
              #else                                 //XOR 0-7
              for(loop=0;loop<=7;loop++)
              SC16_Com[8]^=SC16_Com[loop];
              #endif
              
              
              
                for(loop=0;loop<=8;loop++)
                {
                RS_tx(SC16_Com[loop]);
                //DELAY_FOR(200);
                }
              
              
                  #ifdef  SC16IS750_DEBUG_PRINT 
                  printf("\r\nGet_press=%x ",(U16)val);
                    #endif  
              
                  */
              
C51 COMPILER V9.50a   MAIN                                                                 02/18/2019 18:00:32 PAGE 27  

              #endif
1606   1      }
1607          
1608          //---------------------------------------------------
1609          void Version_check(void)
1610          {
1611   1      
1612   1      //U16 val=0;
1613   1      U8 loop;
1614   1      
1615   1      SC16_Com[0]=STX;
1616   1      SC16_Com[1]=0x32;
1617   1      SC16_Com[2]=0x50;
1618   1      SC16_Com[3]=Ver0+0x30;
1619   1      SC16_Com[4]=Ver1+0x30;
1620   1      //SC16_Com[5]=Ver2+0x30;
1621   1      SC16_Com[5]=Ver2;
1622   1      SC16_Com[6]=0x20;
1623   1      SC16_Com[7]=ETX;
1624   1      SC16_Com[8]=0;
1625   1      
1626   1      #ifdef BCC_noSTXEXT          ////XOR 1-6
              for(loop=1;loop<=6;loop++)
              SC16_Com[8]^=SC16_Com[loop];
              #else                                 //XOR 0-7
1630   1      for(loop=0;loop<=7;loop++)
1631   1      SC16_Com[8]^=SC16_Com[loop];
1632   1      #endif
1633   1      
1634   1      
1635   1      
1636   1        for(loop=0;loop<=8;loop++)
1637   1        {
1638   2        RS_tx(SC16_Com[loop]);
1639   2        //DELAY_FOR(200);
1640   2        }
1641   1      
1642   1      }
1643          
1644          void Camera_Version_check(void)
1645          {
1646   1      //U16 val=0;
1647   1      U8 loop;
1648   1      
1649   1      SC16_Com[0]=STX;
1650   1      SC16_Com[1]=0x32;
1651   1      SC16_Com[2]=0x4f;
1652   1      SC16_Com[3]=Camera_ver0;
1653   1      SC16_Com[4]=Camera_ver1;
1654   1      //SC16_Com[5]=Ver2+0x30;
1655   1      SC16_Com[5]=Camera_ver2;
1656   1      SC16_Com[6]=0x20;
1657   1      SC16_Com[7]=ETX;
1658   1      SC16_Com[8]=0;
1659   1      
1660   1      #ifdef BCC_noSTXEXT          ////XOR 1-6
              for(loop=1;loop<=6;loop++)
              SC16_Com[8]^=SC16_Com[loop];
              #else                                 //XOR 0-7
1664   1      for(loop=0;loop<=7;loop++)
1665   1      SC16_Com[8]^=SC16_Com[loop];
1666   1      #endif
C51 COMPILER V9.50a   MAIN                                                                 02/18/2019 18:00:32 PAGE 28  

1667   1      
1668   1      
1669   1      
1670   1        for(loop=0;loop<=8;loop++)
1671   1        {
1672   2        RS_tx(SC16_Com[loop]);
1673   2        //DELAY_FOR(200);
1674   2        }
1675   1      
1676   1      }
1677          //---------------------------------------------------
1678          
1679          // ===========================================================================
1680          // END of File 
1681          // ===========================================================================


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2669    ----
   CONSTANT SIZE    =    467    ----
   XDATA SIZE       =     69     490
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      1       1
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      2    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
